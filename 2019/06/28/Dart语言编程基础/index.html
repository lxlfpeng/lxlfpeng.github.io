<!DOCTYPE html><html lang="zh-CN" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Dart语言编程基础 | 鹏哥的Blog</title><meta name="author" content="peng"><meta name="copyright" content="peng"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#0d0d0d"><meta name="description" content="一.Dart 简述在Dart中，一切都是对象，每个对象都是一个类的实例，所有对象都继承自Object。 Dart是强类型的，也有自动推断类型的机制。 二.变量。1.变量的声明。Dart中定义变量有两种方式，一种是静态类型语言常用的方式，显式指定变量类型，另一种则是动态语言的常用方式，不指定类型，由vm自动推断。  变量的默认值:未初始化的变量的初始值为null。甚至具有数字类型的变量最初也是nul">
<meta property="og:type" content="article">
<meta property="og:title" content="Dart语言编程基础">
<meta property="og:url" content="https://lxlfpeng.github.io/2019/06/28/Dart%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/index.html">
<meta property="og:site_name" content="鹏哥的Blog">
<meta property="og:description" content="一.Dart 简述在Dart中，一切都是对象，每个对象都是一个类的实例，所有对象都继承自Object。 Dart是强类型的，也有自动推断类型的机制。 二.变量。1.变量的声明。Dart中定义变量有两种方式，一种是静态类型语言常用的方式，显式指定变量类型，另一种则是动态语言的常用方式，不指定类型，由vm自动推断。  变量的默认值:未初始化的变量的初始值为null。甚至具有数字类型的变量最初也是nul">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://lxlfpeng.github.io/images/about_avatar.webp">
<meta property="article:published_time" content="2019-06-27T16:00:00.000Z">
<meta property="article:modified_time" content="2025-04-12T15:02:01.840Z">
<meta property="article:author" content="peng">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://lxlfpeng.github.io/images/about_avatar.webp"><link rel="shortcut icon" href="/images/favicon.webp"><link rel="canonical" href="https://lxlfpeng.github.io/2019/06/28/Dart%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Dart语言编程基础',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  isShuoshuo: false
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/images/about_avatar.webp" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">127</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">59</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">24</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/categories"><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background: linear-gradient(20deg, #0062be, #925696, #cc426e, #fb0347);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src="/images/nav_logo.webp" alt="Logo"><span class="site-name">鹏哥的Blog</span></a><a class="nav-page-title" href="/"><span class="site-name">Dart语言编程基础</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/categories"><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Dart语言编程基础</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2019-06-27T16:00:00.000Z" title="发表于 2019-06-28 00:00:00">2019-06-28</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Flutter%E5%BC%80%E5%8F%91/">Flutter开发</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">11k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>41分钟</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="一-Dart-简述"><a href="#一-Dart-简述" class="headerlink" title="一.Dart 简述"></a>一.Dart 简述</h1><p>在Dart中，一切都是对象，每个对象都是一个类的实例，所有对象都继承自Object。 Dart是强类型的，也有自动推断类型的机制。</p>
<h1 id="二-变量。"><a href="#二-变量。" class="headerlink" title="二.变量。"></a>二.变量。</h1><h3 id="1-变量的声明。"><a href="#1-变量的声明。" class="headerlink" title="1.变量的声明。"></a>1.变量的声明。</h3><p>Dart中定义变量有两种方式，一种是静态类型语言常用的方式，显式指定变量类型，另一种则是动态语言的常用方式，不指定类型，由vm自动推断。</p>
<blockquote>
<p>变量的默认值:未初始化的变量的初始值为null。甚至具有数字类型的变量最初也是null，因为在Dart中没有基础的数据类型，所有的都是对象类型.数字——就像dart中的其他东西一样是对象。</p>
</blockquote>
<h3 id="2-显式指定类型来定义变量"><a href="#2-显式指定类型来定义变量" class="headerlink" title="2. 显式指定类型来定义变量"></a>2. 显式指定类型来定义变量</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void main() &#123;</span><br><span class="line">  // 通过显式指定类型来定义变量</span><br><span class="line">  String name = &quot;张三&quot;;</span><br><span class="line">  num age = 18;</span><br><span class="line">  name = 1; //报错，显示指定的变量的类型是无法改变的</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-隐式推导变量"><a href="#3-隐式推导变量" class="headerlink" title="3. 隐式推导变量."></a>3. 隐式推导变量.</h3><p>无需指定变量的数据类型，变量会根据值的类型进行推导.使用关键字var.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void main() &#123;</span><br><span class="line">//使用var定义变量，即使未显式指定类型，在初始化时一旦赋值后类型就被固定，因此使用var定义的变量如果在初始化时进行赋值了则不能改变数据类型</span><br><span class="line">  var id = 100;</span><br><span class="line">  var number;</span><br><span class="line">  number = &quot;2019&quot;;</span><br><span class="line">  id = &quot;10010&quot;; // 代码错误，无法运行，number变量已确定为int类型</span><br><span class="line">  number = 19;//代码可以运行因为初始化时进行了类型推到所以可以运行</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-动态数据类型"><a href="#4-动态数据类型" class="headerlink" title="4 动态数据类型."></a>4 动态数据类型.</h3><p>如想动态改变变量的数据类型，应当使用dynamic或Object来定义变量。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">dynamic var1 = &quot;hello&quot;;//在这里初始化的是一个sting 类型的</span><br><span class="line">var1 = 52;//在这里又改变成了 int 类型</span><br><span class="line">print(var1);    // 最后的结果时Int类型</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Object var2 = 20;// Object声明变量是int类型</span><br><span class="line">var2 = &quot;张三&quot;; //修改为String类型</span><br><span class="line">print(var2);    // 张三</span><br></pre></td></tr></table></figure>
<h5 id="dynamic"><a href="#dynamic" class="headerlink" title="dynamic:"></a>dynamic:</h5><p>所有dart 对象的基础类型，在大多数情况下，不直接使用它 通过它定义的变量会关闭类型检查，这意味着 dynamix x&#x3D; ‘hal’; x.foo();这段静态类型检查不会报错，<br>但是运行时会crash，因为x 并没有foo（） 方法，所以建议大家在编程时不要直接使用dynamic；</p>
<h5 id="object"><a href="#object" class="headerlink" title="object:"></a>object:</h5><p>是Dart 对象的基类，当你定义： object o &#x3D;xxx ;时这个时候系统会认为o 是个对象，你可以调用o的toString()和hashCode()方法，因为Object 提供了这些方法，但是如果你尝试调用o.foo()时，<br>因为o 并没有foo（） 方法，静态类型检查会运行报错。</p>
<blockquote>
<p>综上不难看出dynamic 与object 的最大的区别是在静态类型检查上。dynamic在编译期不检测，object在编译器则会检测.</p>
</blockquote>
<p><strong>建议在编写代码时，尽可能显式指定变量类型，这样可以提升代码可读性与调试的便利性。</strong></p>
<h1 id="三-常量。"><a href="#三-常量。" class="headerlink" title="三.常量。"></a>三.常量。</h1><p>Dart中定义常量也有两种方式，一种使用final关键字，同Java中的用法， 一个 final 变量只能赋值一次；另一种是Dart的方式，使用const关键字定义。</p>
<h3 id="1-Final-修饰符定义常量"><a href="#1-Final-修饰符定义常量" class="headerlink" title="1.Final 修饰符定义常量"></a>1.Final 修饰符定义常量</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void main() &#123;</span><br><span class="line">  // final 定义常量</span><br><span class="line">  final  age = 18;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-const修饰符定义常量"><a href="#2-const修饰符定义常量" class="headerlink" title="2.const修饰符定义常量"></a>2.const修饰符定义常量</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void main() &#123;</span><br><span class="line">  // const 定义常量</span><br><span class="line">  const name = &#x27;张三&#x27;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-final-和-const-的区别"><a href="#3-final-和-const-的区别" class="headerlink" title="3. final 和 const 的区别"></a>3. final 和 const 的区别</h3><p> const声明时必须赋值，不然会报错，final 声明时可以不用先赋值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void main() &#123;</span><br><span class="line">  final name;</span><br><span class="line">  const age; //报错，声明时必须赋值</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>final定义的常量是运行时常量，final声明变量只能赋值一次，并不要求赋的值一定是编译时常量，可以是常量也可以不是。 在程序运行的时候赋值，赋值后值不再改变。<br>const常量则是编译时常量 要求在声明时初始化，并且赋值必需为编译时常量。</p>
</blockquote>
<h3 id="4-变量的命名规则："><a href="#4-变量的命名规则：" class="headerlink" title="4.变量的命名规则："></a>4.变量的命名规则：</h3><ul>
<li>变量名称必须由数字、字母、下划线和美元符($)组成。</li>
<li>注意：标识符开头不能是数字。</li>
<li>标识符不能是保留字和关键字。   </li>
<li>变量的名字是区分大小写的如: age和Age是不同的变量。在实际的运用中，也建议，不要用一个单词大小写区分两个变量。</li>
<li>标识符(变量名称)一定要见名思意 ：变量名称建议用名词，方法名称建议用动词。</li>
</ul>
<h1 id="四-常用数据类型。"><a href="#四-常用数据类型。" class="headerlink" title="四.常用数据类型。"></a>四.常用数据类型。</h1><table>
<thead>
<tr>
<th>类型</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>Number</td>
<td>可以理解为是 数字数据类型</td>
<td>包括两类，int 整形，double 浮点形</td>
</tr>
<tr>
<td>String</td>
<td>字符串</td>
<td>可以使用三引号来创建包含多行的字符串</td>
</tr>
<tr>
<td>Boolean</td>
<td>布尔类型</td>
<td>取值只有 true false</td>
</tr>
<tr>
<td>List</td>
<td>数组</td>
<td>List 类似java中的数组与集合var list &#x3D;[1，2，4，5];</td>
</tr>
<tr>
<td>Map</td>
<td>键值数据类型</td>
<td>Map 类似java中的hashmap</td>
</tr>
</tbody></table>
<h3 id="1-数值类型"><a href="#1-数值类型" class="headerlink" title="1.数值类型"></a>1.数值类型</h3><p>不像Java把类型分的特别细，比如整数类型，就有byte、short、int 、long 。Dart 内置支持两种数值类型，分别是int 和double ，它们的大小都是64位(具体取决于平台)。<br>数值类型转换:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void main() &#123;</span><br><span class="line">  var one = int.parse(&#x27;1&#x27;); // String 转 int</span><br><span class="line">  var onePointOne = double.parse(&#x27;1.1&#x27;); // String 转 double</span><br><span class="line">  String oneAsStr = 1.toString(); // int 转 String</span><br><span class="line">  String piAsStr = 3.14159.toStringAsFixed(2); //double 转 String 保留两位 &#x27;3.14&#x27;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="2-字符串类型"><a href="#2-字符串类型" class="headerlink" title="2.字符串类型"></a>2.字符串类型</h3><h5 id="Dart可以使用单引号或双引号来创建字符串"><a href="#Dart可以使用单引号或双引号来创建字符串" class="headerlink" title="Dart可以使用单引号或双引号来创建字符串"></a>Dart可以使用单引号或双引号来创建字符串</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var str1 = &quot;hello&quot;;</span><br><span class="line">var str2 = &#x27;world&#x27;;</span><br></pre></td></tr></table></figure>
<h5 id="Dart可以使用三引号来创建包含多行的字符串"><a href="#Dart可以使用三引号来创建包含多行的字符串" class="headerlink" title="Dart可以使用三引号来创建包含多行的字符串"></a>Dart可以使用三引号来创建包含多行的字符串</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  var multiLine1 = &quot;&quot;&quot;xxxxxxx</span><br><span class="line">xxxxxxx</span><br><span class="line">&quot;&quot;&quot;;</span><br><span class="line"></span><br><span class="line">  var multiLine2 = &#x27;&#x27;&#x27;yyyyyyy</span><br><span class="line">yyyyy</span><br><span class="line">&#x27;&#x27;&#x27;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="Dart支持使用”-”操作符拼接字符串"><a href="#Dart支持使用”-”操作符拼接字符串" class="headerlink" title="Dart支持使用”+”操作符拼接字符串"></a>Dart支持使用”+”操作符拼接字符串</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var hw = &quot;hello&quot; + &quot; world&quot;;</span><br></pre></td></tr></table></figure>
<h5 id="Dart提供了插值表达式”-”，也可以用于拼接字符串"><a href="#Dart提供了插值表达式”-”，也可以用于拼接字符串" class="headerlink" title="Dart提供了插值表达式”${}”，也可以用于拼接字符串"></a>Dart提供了插值表达式”${}”，也可以用于拼接字符串</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var name = &quot;张三&quot;;</span><br><span class="line">var str = &quot;hello，$&#123;name&#125;&quot;;</span><br><span class="line">print(str); // hello，张三</span><br></pre></td></tr></table></figure>
<h5 id="与kotlin类似，Dart使用”-”来比较字符串的内容"><a href="#与kotlin类似，Dart使用”-”来比较字符串的内容" class="headerlink" title="与kotlin类似，Dart使用”&#x3D;&#x3D;”来比较字符串的内容"></a>与kotlin类似，Dart使用”&#x3D;&#x3D;”来比较字符串的内容</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(&quot;hello&quot; == &quot;world&quot;);</span><br></pre></td></tr></table></figure>

<h5 id="其他字符串操作功能"><a href="#其他字符串操作功能" class="headerlink" title="其他字符串操作功能"></a>其他字符串操作功能</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">void main() &#123;</span><br><span class="line">  var str = &quot;hello word&quot;;</span><br><span class="line">  //字符串判断</span><br><span class="line">  print(str.length); // 字符串长度</span><br><span class="line">  print(str.isEmpty); // 是否为空</span><br><span class="line">  print(str.isNotEmpty); //是否不为空</span><br><span class="line"></span><br><span class="line">  //字符串分割</span><br><span class="line">  print(str.substring(0， 2)); // 字符串分割，含头不含尾</span><br><span class="line">  print(str.substring(3)); // 字符串分割，从指定index至末尾</span><br><span class="line">  String str2 = &quot;a，d，d d，c，，&quot;;</span><br><span class="line">  List&lt;String&gt; strs = str2.split(&quot;，&quot;); //使用，分割，返回的是一个数组</span><br><span class="line"></span><br><span class="line">  //字符串包含</span><br><span class="line">  print(str.startsWith(&quot;xx&quot;)); //是否以‘xx’开头</span><br><span class="line">  print(str.startsWith(&quot;xx&quot;， 3)); //是否以‘xx’开头 从index=3开始判断</span><br><span class="line">  print(str.endsWith(&quot;xx&quot;)); // 是否以‘xx’结尾</span><br><span class="line">  print(str.contains(&quot;xx&quot;)); //是否包含‘xx’</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-布尔类型"><a href="#4-布尔类型" class="headerlink" title="4.布尔类型"></a>4.布尔类型</h3><p>Dart中的布尔类型用法同Java，仅有false、true两个值，不能使用0、非0或者null、非null来表达false和true。与Java不同的是，布尔类型的默认值为null。</p>
<h3 id="5-列表"><a href="#5-列表" class="headerlink" title="5.列表"></a>5.列表</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var list = [1， 2， 3];// 创建列表</span><br><span class="line">print(list[0]);//获取下表为0的元素</span><br><span class="line">print(list.length);// 下标从0开始。使用length可以访问list的长度</span><br><span class="line">list.add(5);// 可以使用add添加元素</span><br><span class="line"></span><br><span class="line">var constantList = const [1， 2， 3];// 可在list字面量前添加const关键字，定义一个不可改变的 列表（编译时常量）</span><br><span class="line">constantList[1] = 1;     // 报错 无法进行修改</span><br></pre></td></tr></table></figure>
<h3 id="6-映射"><a href="#6-映射" class="headerlink" title="6.映射"></a>6.映射</h3><p>又称为关联数组，相当于Java中的HashMap。</p>
<h5 id="通过字面量创建Map"><a href="#通过字面量创建Map" class="headerlink" title="通过字面量创建Map"></a>通过字面量创建Map</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var person = &#123;</span><br><span class="line">  &#x27;name&#x27; : &#x27;张三&#x27;，</span><br><span class="line">  &#x27;age&#x27;: &#x27;30&#x27;，</span><br><span class="line">  &#x27;sex&#x27; : &#x27;男&#x27;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="使用Map类的构造函数创建对象"><a href="#使用Map类的构造函数创建对象" class="headerlink" title="使用Map类的构造函数创建对象"></a>使用Map类的构造函数创建对象</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var person = new Map();</span><br><span class="line">// 往Map中添加键值对</span><br><span class="line">person[&#x27;name&#x27;] = &#x27;张三&#x27;;</span><br><span class="line">person[&#x27;age&#x27;] = &#x27;30&#x27;;</span><br><span class="line">person[&#x27;sex&#x27;] = &#x27;男&#x27;;</span><br></pre></td></tr></table></figure>
<h5 id="获取Map的长度"><a href="#获取Map的长度" class="headerlink" title="获取Map的长度"></a>获取Map的长度</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(person.length);</span><br></pre></td></tr></table></figure>
<h5 id="查找Map"><a href="#查找Map" class="headerlink" title="查找Map"></a>查找Map</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pirnt(person[&quot;name&quot;]);</span><br><span class="line">print(person[&quot;height&quot;]);    // 键不存在则返回 null</span><br></pre></td></tr></table></figure>

<h1 id="四-流程控制。"><a href="#四-流程控制。" class="headerlink" title="四.流程控制。"></a>四.流程控制。</h1><h3 id="1-if和else"><a href="#1-if和else" class="headerlink" title="1.if和else"></a>1.if和else</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">if 和 else</span><br><span class="line">if (表达式1) &#123;</span><br><span class="line">    分支1</span><br><span class="line">&#125; else if （表达式2） &#123;</span><br><span class="line">    分支2</span><br><span class="line">&#125; else&#123;</span><br><span class="line">    分支3</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>dart的if else 必须是bool型</p>
</blockquote>
<h3 id="2-循环-for，while-和-do-while"><a href="#2-循环-for，while-和-do-while" class="headerlink" title="2.循环 for，while 和 do-while"></a>2.循环 for，while 和 do-while</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">for (初始语句;条件表达式;结束语句)&#123;</span><br><span class="line">    循环体语句</span><br><span class="line">&#125;</span><br><span class="line">例如:</span><br><span class="line">for (var i = 0; i &lt; 2; i++) &#123;</span><br><span class="line">  callbacks.add(() =&gt; print(i));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">while (条件) &#123;</span><br><span class="line">   循环体语句</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">do&#123;</span><br><span class="line">   循环体语句</span><br><span class="line">&#125; while(条件) </span><br></pre></td></tr></table></figure>
<h3 id="3-switch-case"><a href="#3-switch-case" class="headerlink" title="3.switch case"></a>3.switch case</h3><p>在 Dart 中 switch 语句使用 &#x3D;&#x3D; 比较整数，字符串，或者编译时常量。 比较的对象必须都是同一个类的实例（并且不可以是子类）， 类必须没有对 &#x3D;&#x3D; 重写。 枚举类型可以用于 switch 语句。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">var command = &#x27;OPEN&#x27;;</span><br><span class="line">switch (command) &#123;</span><br><span class="line">  case &#x27;CLOSED&#x27;:</span><br><span class="line">    executeClosed();</span><br><span class="line">    break;</span><br><span class="line">  case &#x27;PENDING&#x27;:</span><br><span class="line">    executePending();</span><br><span class="line">    break;</span><br><span class="line">  case &#x27;APPROVED&#x27;:</span><br><span class="line">    executeApproved();</span><br><span class="line">    break;</span><br><span class="line">  case &#x27;DENIED&#x27;:</span><br><span class="line">    executeDenied();</span><br><span class="line">    break;</span><br><span class="line">  case &#x27;OPEN&#x27;:</span><br><span class="line">    executeOpen();</span><br><span class="line">    break;</span><br><span class="line">  default:</span><br><span class="line">    executeUnknown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-break-continue"><a href="#4-break-continue" class="headerlink" title="4.break continue"></a>4.break continue</h3><p>break语句可以结束for等代码块。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void breakDemo() &#123;</span><br><span class="line">  break1:</span><br><span class="line">  for (var i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">    // break2:</span><br><span class="line">    for (var j = 0; j &lt; 5; j++) &#123;</span><br><span class="line">      if (i == 2 &amp;&amp; j == 2) &#123;</span><br><span class="line">        break break1;</span><br><span class="line">      &#125;</span><br><span class="line">      print(&quot;loop:$j+$i&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  print(&quot;...&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>continue语句可以结束当前循环，开始下一次的循环迭代过程。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void continueDemo() &#123;</span><br><span class="line">  forloop1:</span><br><span class="line">  for (var i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">    // forloop2:</span><br><span class="line">    for (var j = 0; j &lt; 5; j++) &#123;</span><br><span class="line">      if (i == 2 &amp;&amp; j == 2) &#123;</span><br><span class="line">        continue forloop1;</span><br><span class="line">      &#125;</span><br><span class="line">      print(&quot;loop:$j+$i&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="五-函数。"><a href="#五-函数。" class="headerlink" title="五.函数。"></a>五.函数。</h1><h3 id="1-方法定义"><a href="#1-方法定义" class="headerlink" title="1.方法定义"></a>1.方法定义</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">返回类型  方法体  (参数1，  参数2， ...)&#123;</span><br><span class="line">    方法体...</span><br><span class="line">    return 返回值</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果一个函数没有显示声明返回值，Dart 会自动推导它的返回值类型。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 声明返回值</span><br><span class="line">int add(int a， int b) &#123;</span><br><span class="line">  return a + b;</span><br><span class="line">&#125;</span><br><span class="line">// 不声明返回值</span><br><span class="line">void add2(int a， int b) &#123;</span><br><span class="line">  return a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果一个函数没有显示的 return，那么它默认会返回 null。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fun()&#123;&#125;</span><br><span class="line"></span><br><span class="line">print(fun() == null) //true    </span><br></pre></td></tr></table></figure>
<p>如果一个函数只有一句表达式，可以使用简写：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bool isMan(String sex) =&gt; sex == &#x27;男&#x27;;</span><br><span class="line"></span><br><span class="line">isMan(String sex) =&gt; sex == &#x27;男&#x27;;</span><br></pre></td></tr></table></figure>
<h3 id="2-命名参数"><a href="#2-命名参数" class="headerlink" title="2.命名参数"></a>2.命名参数</h3><p>顾名思义 就是给参数定了个名字，和kotlin里面的具名函数一样.<br>通过 {} 符号，可以用于指定函数参数的名称。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void makeHotPot(&#123;required String water， required String seasoning， String meat = &quot;羊肉卷&quot;&#125;) &#123;</span><br><span class="line">  print(water+seasoning+meat);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，Dart 支持我们给参数设置默认值。<br>调用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void main() &#123;</span><br><span class="line">  makeHotPot(water: &quot;矿泉水&quot;， seasoning: &quot;麻辣底料&quot;);</span><br><span class="line">  makeHotPot(water: &quot;矿泉水&quot;， seasoning: &quot;麻辣底料&quot;，meat:&quot;麻辣牛肉&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>使用 required 修饰的参数，表示必要的参数，在调用的时候你不能遗漏它。</p>
<h3 id="3-位置参数"><a href="#3-位置参数" class="headerlink" title="3.位置参数"></a>3.位置参数</h3><p>使用中括号[]括起来的参数是函数的位置参数，代表该参数可传可不传，位置参数只能放在函数的参数列表的最后面。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 位置参数可以有多个，比如[String a， int b]</span><br><span class="line">test(String name， int age， [String hobby]) &#123;</span><br><span class="line">  StringBuffer sb = new StringBuffer();</span><br><span class="line">  sb.write(&quot;hello， this is $name and I am $age years old&quot;);</span><br><span class="line">  if (hobby != null) &#123;</span><br><span class="line">    sb.write(&quot;， my hobby is $hobby&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  print(sb.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-匿名函数"><a href="#4-匿名函数" class="headerlink" title="4.匿名函数"></a>4.匿名函数</h3><p>多数函数是有名字的， 比如 main()和 print()。 也可以创建没有名字的函数，这种函数被称为 匿名函数， 有时候也被称为 lambda 或者 closure(闭包函数) 。 匿名函数可以赋值到一个变量中<br>匿名方法看起来与命名方法类似，在括号之间可以定义参数，参数之间用逗号分割。</p>
<p>后面大括号中的内容则为函数体：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">([[类型] 参数[， …]]) &#123;</span><br><span class="line">  函数体;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>注意：参数类型是可以选的，可以不带。<br>无参数的匿名函数:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 传入一个函数对象，并执行该函数</span><br><span class="line">void runFunc(Function func)&#123;</span><br><span class="line">  func();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main(List&lt;String&gt; args) &#123;</span><br><span class="line">  runFunc(()&#123;print(&quot;匿名函数&quot;);&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>带参数的匿名函数:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void runFunc(Function(String name) func)&#123;</span><br><span class="line">  func(&quot;张三&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main() &#123;</span><br><span class="line">  runFunc((name)&#123;print(name);&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-局部函数"><a href="#5-局部函数" class="headerlink" title="5.局部函数"></a>5.局部函数</h3><p>在Dart中还有一种可以直接定义在函数体内部的函数，可以把称为局部函数或者内嵌函数。<br>函数声明可以出现顶层，比如常见的main函数等等。局部函数的好处就是从作用域角度来看，它可以访问外部函数变量，并且还能避免引入一个额外的外部函数，使得整个函数功能职责统一。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//定义外部函数getSoda</span><br><span class="line">String getSoda(String water) &#123;</span><br><span class="line">  //定义内部函数makeSoda</span><br><span class="line">  String makeSoda(String water) &#123;</span><br><span class="line">    return water + &quot;糖&quot; + &quot;果汁&quot; + &quot;二氧化碳&quot;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return makeSoda(water);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6-顶层函数和静态函数"><a href="#6-顶层函数和静态函数" class="headerlink" title="6.顶层函数和静态函数"></a>6.顶层函数和静态函数</h3><p>在Dart中有一种特别的函数，在面向对象语言中比如Java，并不能直接定义一个函数的，而是需要定义一个类，然后在类中定义函数。<br>但是在Dart中可以不用在类中定义函数，而是直接基于dart文件顶层定义函数，这种函数我们一般称为顶层函数。最常见就是main函数了。<br>而静态函数就和Java中类似，依然使用static关键字来声明，然后必须是定义在类的内部的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//顶层函数，不定义在类的内部</span><br><span class="line">main() &#123;</span><br><span class="line">  print(&#x27;hello dart&#x27;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-函数作为参数"><a href="#4-函数作为参数" class="headerlink" title="4.函数作为参数"></a>4.函数作为参数</h3><p>在 Dart 中，函数本身也是个对象，它对应的类型是Function，这意味着函数可以当做变量的值或者作为一个方法入传参数值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">void sayHello(var name)&#123;</span><br><span class="line">  print(&#x27;hello， $name&#x27;);</span><br><span class="line">&#125;</span><br><span class="line">//参数时一个函数</span><br><span class="line">void callHello(Function func， var name)&#123;</span><br><span class="line">  func(name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void main()&#123;</span><br><span class="line">  // 函数变量</span><br><span class="line">  var helloFuc = sayHello;</span><br><span class="line">  // 调用函数</span><br><span class="line">  helloFuc(&#x27;张三&#x27;);</span><br><span class="line">  // 函数参数</span><br><span class="line">  callHello(helloFuc，&#x27;李四&#x27;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="六-异常处理"><a href="#六-异常处理" class="headerlink" title="六. 异常处理"></a>六. 异常处理</h1><p>异常是表示发生了意外的错误，如果没有捕获异常，引发异常的隔离程序将被挂起，并且程序将被终止；Dart可以抛出并捕获异常，但与java相反，Dart的所有异常都是未检查的异常，方法不声明它们可能抛出哪些异常，也不需要捕获任何异常。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">  breedMoreLlamas();</span><br><span class="line">&#125; on OutOfLlamasException &#123;</span><br><span class="line">  // 一个特定的异常</span><br><span class="line">  buyMoreLlamas();</span><br><span class="line">&#125; on Exception catch (e) &#123;</span><br><span class="line">  // 其他异常</span><br><span class="line">  print(&#x27;Unknown exception: $e&#x27;);</span><br><span class="line">&#125; catch (e) &#123;</span><br><span class="line">  // 没有指定类型， 则处理所有</span><br><span class="line">  print(&#x27;Something really unknown: $e&#x27;);</span><br><span class="line">&#125;finally&#123;</span><br><span class="line">      print(&#x27;finally&#x27;);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>可以通过on 关键词来指定异常类型，finally一般用于释放资源等一些操作，它表示最后一定会执行的意思，即便try…catch中有return，它里面的代码也会承诺执行。</p>
<h1 id="七-类"><a href="#七-类" class="headerlink" title="七.类"></a>七.类</h1><h3 id="类的定义"><a href="#类的定义" class="headerlink" title="类的定义"></a>类的定义</h3><p>Dart 是一门面向对象的编程语言，所有对象都是某个类的实例，所有类继承了Object类。</p>
<ul>
<li>类的定义用class关键字。</li>
<li>如果未显式定义构造函数，会默认一个空的构造函数。</li>
<li>类首字母必须大写。</li>
<li>使用new关键字和构造函数来创建对象。<br>一个简单的类：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">  var name;</span><br><span class="line">  var age;</span><br><span class="line"></span><br><span class="line">  // 构造器</span><br><span class="line">  Person(this.name， this.age);</span><br><span class="line"></span><br><span class="line">  // 实例方法</span><br><span class="line">  String getDescribe() &#123;</span><br><span class="line">    return &quot;我叫$name我今年$age岁&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main() &#123;</span><br><span class="line"></span><br><span class="line">  var person = new Person(&quot;张三&quot;， &quot;50&quot;);</span><br><span class="line">  var name = person.name;</span><br><span class="line">  var describe = person.getDescribe();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
Dart 通过. 来调用类成员变量和方法的。和Kotlin一样还可以通过.?来避免null对象。</li>
</ul>
<h3 id="类的引入"><a href="#类的引入" class="headerlink" title="类的引入"></a>类的引入</h3><p>在要使用的 dart 文件中引入 Person 类：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &#x27;lib/Person.dart&#x27;;</span><br></pre></td></tr></table></figure>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>自定义类的默认构造函数:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">  String name;</span><br><span class="line">  int age;</span><br><span class="line">  // 默认构造函数</span><br><span class="line">  Person(String name， int age) &#123;</span><br><span class="line">    print(&#x27;这是构造函数里面的内容 这个方法在实例化的时候触发&#x27;);</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.age = age;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  void getInfo() &#123;</span><br><span class="line">    print(&#x27;$&#123;this.name&#125;-----$&#123;this.age&#125;&#x27;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main() &#123;</span><br><span class="line">  var p1 = new Person(&#x27;张三&#x27;， 30);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>默认构造函数的简写</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">  String name;</span><br><span class="line">  int age;</span><br><span class="line">  // 默认构造函数的简写</span><br><span class="line">  Person(this.name， this.age);</span><br><span class="line"></span><br><span class="line">  void getInfo() &#123;</span><br><span class="line">    print(&#x27;$&#123;this.name&#125;-----$&#123;this.age&#125;&#x27;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main() &#123;</span><br><span class="line">  var p1 = new Person(&#x27;张三&#x27;， 30);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="命名构造函数"><a href="#命名构造函数" class="headerlink" title="命名构造函数"></a>命名构造函数</h3><p>自定义命名函数:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">  String name;</span><br><span class="line">  int age;</span><br><span class="line">  // 默认构造函数的简写</span><br><span class="line">  Person(this.name， this.age);</span><br><span class="line">  //命名构造函数</span><br><span class="line">  Person.now() &#123;</span><br><span class="line">    print(&#x27;我是命名构造函数&#x27;);</span><br><span class="line">  &#125;</span><br><span class="line">  // 可以定义多个命名函数</span><br><span class="line">  Person.setInfo(String name， int age) &#123;</span><br><span class="line">    print(&#x27;我是命名构造函数&#x27;);</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.age = age;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main() &#123;</span><br><span class="line">  // var p1 = new Person(&#x27;张三&#x27;， 30);// 默认实例化类是调用的是默认构造函数</span><br><span class="line"></span><br><span class="line">   var p2 = new Person.now();//调用命名构造函数</span><br><span class="line"></span><br><span class="line">  var p3 = new Person.setInfo(&#x27;李四&#x27;， 30);//调用命名构造函数</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="初始化列表"><a href="#初始化列表" class="headerlink" title="初始化列表"></a>初始化列表</h3><ul>
<li>初始化列表会在构造方法体执行之前执行。</li>
<li>使用逗号分隔初始化列表。</li>
<li>初始化列表常用于设置final属性的值。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">void  main() &#123;</span><br><span class="line"></span><br><span class="line">    var map = &#123;&#x27;name&#x27;: &#x27;jack&#x27;， &#x27;age&#x27;: 20， &#x27;gender&#x27;: &#x27;男&#x27;&#125;;</span><br><span class="line">    var p = Person.withMap(map);</span><br><span class="line">      </span><br><span class="line">    </span><br><span class="line">    print(p.name);</span><br><span class="line">    print(p.age);</span><br><span class="line">    print(p.gender);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class  Person &#123;</span><br><span class="line"></span><br><span class="line">    String name;</span><br><span class="line">    int age;</span><br><span class="line">    final  String gender;</span><br><span class="line">  </span><br><span class="line">    Person(this.name， this.age， this.gender);</span><br><span class="line">  </span><br><span class="line">    Person.withMap(Map map) : this.name = map[&#x27;name&#x27;] ， this.gender = map[&#x27;gender&#x27;] &#123;       //this.gender = map[&#x27;gender&#x27;]  会在构造方法执行前进行赋值，此种方式主要用于final属性的赋值      </span><br><span class="line">        this.age = map[&#x27;age&#x27;];    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="类中的getter和setter修饰符"><a href="#类中的getter和setter修饰符" class="headerlink" title="类中的getter和setter修饰符"></a>类中的getter和setter修饰符</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Rect &#123;</span><br><span class="line">  num height;</span><br><span class="line">  num width;</span><br><span class="line"></span><br><span class="line">  Rect(this.height， this.width);</span><br><span class="line"></span><br><span class="line">  // get 方法</span><br><span class="line">  get area &#123;</span><br><span class="line">    return this.height * this.width;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // set 方法</span><br><span class="line">  set areaHeight(value) &#123;</span><br><span class="line">    this.height = value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void main() &#123;</span><br><span class="line">  Rect r = new Rect(10， 4);</span><br><span class="line">  //调用set方法</span><br><span class="line">  r.areaHeight = 6;</span><br><span class="line">  //直接通过访问属性的方式访问area</span><br><span class="line">  print(&quot;面积:$&#123;r.area&#125;&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="类变量的可见性"><a href="#类变量的可见性" class="headerlink" title="类变量的可见性"></a>类变量的可见性</h3><p>在 Dart 中，没有private、protected、public这些关键词，如果要声明一个变量是私有的，则在变量名前添加下划线_，声明了私有的变量，只在本类库中可见。私有属性及私有方法， 只有放在单独的文件 class 中生效.默认类中的所有属性和方法是public的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">  String _secret; // 私有属性 只有放在单独的文件 class 中生效</span><br><span class="line">  // 私有方法</span><br><span class="line">  void _run() &#123;</span><br><span class="line">    print(&#x27;private function _run&#x27;);</span><br><span class="line">  &#125;</span><br><span class="line">  // 对外暴露私有方法</span><br><span class="line">  void executeRun() &#123;</span><br><span class="line">    this._run();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="类中的静态成员-静态方法"><a href="#类中的静态成员-静态方法" class="headerlink" title="类中的静态成员 静态方法"></a>类中的静态成员 静态方法</h3><p>使用static关键字来实现类级别的变量和函数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">  static String name = &#x27;张三&#x27;;</span><br><span class="line">  static void show() &#123;</span><br><span class="line">    print(name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main() &#123;</span><br><span class="line">  print(Person.name);</span><br><span class="line">  Person.show();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>静态方法只能访问静态属性，不能访问非静态成员。非静态方法可以访问静态属性。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">  static String name = &#x27;张三&#x27;;</span><br><span class="line">  int age = 29;</span><br><span class="line"></span><br><span class="line">  static void show() &#123;</span><br><span class="line">    print(name);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  void printInfo() &#123;</span><br><span class="line">    //非静态方法可以访问静态成员</span><br><span class="line">    print(name); //访问静态属性</span><br><span class="line">    print(this.age); //访问非静态属性</span><br><span class="line">    show(); //调用静态方法</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  static void printInfo2() &#123;</span><br><span class="line">    //静态方法不能访问非静态成员</span><br><span class="line">    print(name); //访问静态属性</span><br><span class="line">    show(); //调用静态方法</span><br><span class="line">    // print(this.age); //报错 不能访问非静态属性</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main() &#123;</span><br><span class="line">  // Person p = new Person();</span><br><span class="line">  // p.printInfo();</span><br><span class="line"></span><br><span class="line">  Person.printInfo2();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="静态变量"><a href="#静态变量" class="headerlink" title="静态变量"></a>静态变量</h5><ul>
<li>静态变量(类变量)对于类范围的状态和常量非常有用。</li>
<li>静态变量在使用之前不会初始化。</li>
</ul>
<h5 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h5><p>静态方法(类方法)不能在实例操作，因此它没有访问this的权限。</p>
<blockquote>
<p>为了常用或广泛使用的实用程序和功能，考虑使用顶层函数，而不是静态方法。可以使用静态方法作为编译时常量。例如，可以将静态方法作为参数传递给常量构造函数。</p>
</blockquote>
<h1 id="八-抽象类和接口"><a href="#八-抽象类和接口" class="headerlink" title="八.抽象类和接口"></a>八.抽象类和接口</h1><h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>Dart 的抽象类和Java差不多，除了抽象类是不能被实例化的，可以声明抽象方法之外，和一般类没有区别。抽象类不能实例化，可以当做抽象类来 extends 也可以当做接口来 implements，dart 中没有 interface 这个关键字，接口也是抽象类实现的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">abstract class Animal &#123;</span><br><span class="line">  speak(); // 抽象方法  必须实现</span><br><span class="line">  printInfo() &#123;  // 不需要实现</span><br><span class="line">    print(&#x27;not abstract method&#x27;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Dog extends Animal &#123;</span><br><span class="line">  @override</span><br><span class="line">  speak() &#123;</span><br><span class="line">    print(&#x27;wang!&#x27;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Cat extends Animal &#123;</span><br><span class="line">  @override</span><br><span class="line">  speak() &#123;</span><br><span class="line">    print(&#x27;miao&#x27;);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="隐式的接口"><a href="#隐式的接口" class="headerlink" title="隐式的接口"></a>隐式的接口</h3><p>每个类都是都是隐式的接口，包括类的方法和属性。如果你想创建一个类A不继承B的实现，可以实现B的接口来创建类A。一个类允许通过implements 关键词可以实现多个接口。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// 每个类都是一个隐式的接口，所以Person类也是个接口，包括成员属性和方法.</span><br><span class="line">class Person &#123;</span><br><span class="line">  // 可在接口中实现， 但仅对这个库可见.</span><br><span class="line">  final _name;</span><br><span class="line"></span><br><span class="line">  // 构造函数不能够被接口实现</span><br><span class="line">  Person(this._name);</span><br><span class="line"></span><br><span class="line">  // 可在接口中实现.</span><br><span class="line">  String greet(String who) =&gt; &#x27;Hello， $who. I am $_name.&#x27;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 实现Person接口.</span><br><span class="line">class Impostor implements Person &#123;</span><br><span class="line">  get _name =&gt; &#x27;&#x27;;</span><br><span class="line"></span><br><span class="line">  String greet(String who) =&gt; &#x27;Hi $who. Do you know who I am?&#x27;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">String greetBob(Person person) =&gt; person.greet(&#x27;Bob&#x27;);</span><br><span class="line"></span><br><span class="line">void main() &#123;</span><br><span class="line">  print(greetBob(Person(&#x27;Kathy&#x27;)));</span><br><span class="line">  print(greetBob(Impostor()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现多个接口</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class Point implements Comparable， Location &#123;...&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Mixin混入"><a href="#Mixin混入" class="headerlink" title="Mixin混入"></a>Mixin混入</h3><p>在通过implements实现某个类时，类中所有的方法都必须被重新实现 (无论这个类原来是否已经实现过该方法)。但是某些情况下，一个类可能希望直接复用之前类的原有实现方案，怎么做呢?<br>使用继承吗？但是Dart只支持单继承，那么意味着你只能复用一个类的实现。<br>Dart提供了另外一种方案: Mixin混入的方式:<br>除了可以通过class定义类之外，也可以通过mixin关键字来定义一个类。只是通过mixin定义的类用于被其他类混入使用，通过with关键字来进行混入。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">main(List&lt;String&gt; args) &#123;</span><br><span class="line">  var superMan = SuperMain();</span><br><span class="line">  superMan.run();</span><br><span class="line">  superMan.fly();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mixin Runner &#123;</span><br><span class="line">  run() &#123;</span><br><span class="line">    print(&#x27;在奔跑&#x27;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mixin Flyer &#123;</span><br><span class="line">  fly() &#123;</span><br><span class="line">    print(&#x27;在飞翔&#x27;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// implements的方式要求必须对其中的方法进行重新实现</span><br><span class="line">// class SuperMan implements Runner， Flyer &#123;&#125;</span><br><span class="line"></span><br><span class="line">class SuperMain with Runner， Flyer &#123;</span><br><span class="line"></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h1 id="八-类的继承"><a href="#八-类的继承" class="headerlink" title="八.类的继承"></a>八.类的继承</h1><h3 id="extends-关键字"><a href="#extends-关键字" class="headerlink" title="extends 关键字"></a>extends 关键字</h3><p>子类继承父类使用 extends 关键字，dart 没有多继承.重写方法最好加上 @override 注解，便于协作.子类构造方法中，如果要初始化父类构造方法，使用 super 关键字，比如: </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Dog(String name， int age， [String nickName]) : super(name， age);</span><br></pre></td></tr></table></figure>
<p>子类中调用父类的方法使用 <code>super.fun()</code><br>使用extends创建子类，super引用父类，子类可以重写实例方法、getter和setter，使用@override注释重写，使用@proxy注释来忽略警告。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Television &#123;</span><br><span class="line">    void turnOn() &#123;</span><br><span class="line">        _illuminateDisplay();</span><br><span class="line">        _activateIrSensor();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class SmartTelevision extends Television &#123;</span><br><span class="line">    void turnOn();</span><br><span class="line">    _bootNetworkInterface();</span><br><span class="line">    _initializeMemory();</span><br><span class="line">    _upgradeApps();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="重写成员"><a href="#重写成员" class="headerlink" title="重写成员"></a>重写成员</h3><p>可以使用 @override 关键字，子类可以重写实例的方法，getters和setters。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class SmartTelevision extends Television &#123;</span><br><span class="line">  @override</span><br><span class="line">  void turnOn() &#123;...&#125;</span><br><span class="line">  // ···</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="重写操作符"><a href="#重写操作符" class="headerlink" title="重写操作符"></a>重写操作符</h3><p>你可以重写以下表中显示的运算符。例如，如果定义Vecor类，则可以定义+方法来添加两个vectors。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Vector &#123;</span><br><span class="line">  final int x， y;</span><br><span class="line"></span><br><span class="line">  Vector(this.x， this.y);</span><br><span class="line"></span><br><span class="line">  Vector operator +(Vector v) =&gt; Vector(x + v.x， y + v.y);</span><br><span class="line">  Vector operator -(Vector v) =&gt; Vector(x - v.x， y - v.y);</span><br><span class="line"></span><br><span class="line">  // Operator == and hashCode not shown. For details， see note below.</span><br><span class="line">  // ···</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void main() &#123;</span><br><span class="line">  final v = Vector(2， 3);</span><br><span class="line">  final w = Vector(2， 2);</span><br><span class="line"></span><br><span class="line">  assert(v + w == Vector(4， 5));</span><br><span class="line">  assert(v - w == Vector(0， 1));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="noSuchMethod"><a href="#noSuchMethod" class="headerlink" title="noSuchMethod()"></a>noSuchMethod()</h3><p>当用户调用你定义的类中不存在的属性与方法时，可以做出一些响应，通过重写noSuchMethod()。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">  @override</span><br><span class="line">  void noSuchMethod(Invocation invocation) &#123;</span><br><span class="line">    print(&#x27;You tried to use a non-existent member: &#x27; +</span><br><span class="line">        &#x27;$&#123;invocation.memberName&#125;&#x27;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="九-枚举"><a href="#九-枚举" class="headerlink" title="九. 枚举"></a>九. 枚举</h1><p>枚举类型，通常称为枚举，是一种特殊类型的类，用于表示固定数量的常量值。</p>
<h3 id="使用枚举"><a href="#使用枚举" class="headerlink" title="使用枚举"></a>使用枚举</h3><p>使用enum关键词来声明一个枚举类型。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">enum Color &#123; red， green， blue &#125;</span><br></pre></td></tr></table></figure>
<p>枚举中的每个值都有一个index索引，它返回枚举声明中值的从零开始的位置。例如，第一个值具有索引0，第二个值具有索引1。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">print(Color.red.index == 0);//true</span><br><span class="line">print(Color.green.index == 1);//true</span><br><span class="line">print(Color.blue.index == 2);//true</span><br></pre></td></tr></table></figure>
<p>若要获取枚举中所有值的列表，请使用枚举的values常量。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Color&gt; colors = Color.values;</span><br><span class="line">assert(colors[2] == Color.blue);</span><br></pre></td></tr></table></figure>
<p>你可以在switch语句中使用枚举，如果不处理枚举的所有值，将会收到警告:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var aColor = Color.blue;</span><br><span class="line"></span><br><span class="line">switch (aColor) &#123;</span><br><span class="line">  case Color.red:</span><br><span class="line">    print(&#x27;Red as roses!&#x27;);</span><br><span class="line">    break;</span><br><span class="line">  case Color.green:</span><br><span class="line">    print(&#x27;Green as grass!&#x27;);</span><br><span class="line">    break;</span><br><span class="line">  default: // 没有default，将会报错</span><br><span class="line">    print(aColor); // &#x27;Color.blue&#x27;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>枚举类型有以下限制:</p>
<ul>
<li>不能子类化、混合或实现枚举。</li>
<li>不能显式实例化枚举。</li>
</ul>
<h1 id="十-泛型"><a href="#十-泛型" class="headerlink" title="十. 泛型"></a>十. 泛型</h1><p>泛型是程序设计语言的一种特性。允许程序员在强类型程序设计语言中编写代码时定义一些可变部分，那些部分在使用前必须作出指明。<br>从字面的意思理解来看，泛型，泛就是模糊、暂不确定暂定的意思。可以这样理解，使用泛型就是，定义的一个类型，类型暂不确定，给使用给一个占位符给代替，在使用的时候可以给确定其定义的类型。</p>
<h3 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h3><p>泛型方法可以约束一个方法使用同类型的参数、返回同类型的值，可以约束里面的变量类型。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">T getData&lt;T&gt; (T val) &#123;</span><br><span class="line">  return val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getData&lt;String&gt;(&#x27;123&#x27;);</span><br><span class="line">getData&lt;int&gt;(123);</span><br><span class="line">getData&lt;double&gt;(123);</span><br><span class="line">// getData&lt;bool&gt;(123); //  约束了类型是 bool 但是传入了 int，所以编译器会报错：</span><br></pre></td></tr></table></figure>

<h3 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h3><p>声明泛型类，比如声明一个 Array 类，实际上就是 List 的别名，而 List 本身也支持泛型的实现。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Array&lt;T&gt; &#123;</span><br><span class="line">  List _list = new List&lt;T&gt;();</span><br><span class="line">  Array();</span><br><span class="line">  void add&lt;T&gt;(T value) &#123;</span><br><span class="line">    this._list.add(value);</span><br><span class="line">  &#125;</span><br><span class="line">  get value&#123;</span><br><span class="line">    return this._list;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用泛型类:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List l1 = new List&lt;String&gt;();</span><br><span class="line">// l1.add(12); //报错，泛型是String却添加了int类型</span><br><span class="line">l1.add(&#x27;asd&#x27;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h3><p>下面声明了一个 Storage 接口，然后 Cache 实现了接口，能够约束存储的 value 的类型：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">abstract class Storage&lt;T&gt;&#123;</span><br><span class="line">  Map m = new Map();</span><br><span class="line">  void set(String key， T value);</span><br><span class="line">  void get(String key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Cache&lt;T&gt; implements Storage&lt;T&gt; &#123;</span><br><span class="line">  @override</span><br><span class="line">  Map m = new Map();</span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line">  void get(String key) &#123;</span><br><span class="line">    print(m[key]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line">  void set(String key， T value) &#123;</span><br><span class="line">    print(&#x27;set successed!&#x27;);</span><br><span class="line">    m[key] = value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用泛型接口实现的类：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Cache ch = new Cache&lt;String&gt;();</span><br><span class="line">ch.set(&#x27;name&#x27;， &#x27;123&#x27;);</span><br><span class="line">// ch.set(&#x27;name&#x27;， 1232); // 报错，类型不匹配</span><br><span class="line">ch.get(&#x27;name&#x27;);</span><br></pre></td></tr></table></figure>
<h1 id="十一-使用类库"><a href="#十一-使用类库" class="headerlink" title="十一.使用类库"></a>十一.使用类库</h1><p>有生命力的编程语言，它背后都有一个强大的类库，它们可以让我们站在巨人的肩膀上，又免于重新造轮子。</p>
<h3 id="导入类库"><a href="#导入类库" class="headerlink" title="导入类库"></a>导入类库</h3><p>在Dart里面，通过import关键词来导入类库。<br>内置的类库使用dart:开头引入：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &#x27;dart:io&#x27;;</span><br></pre></td></tr></table></figure>

<p>第三方类库或者本地的dart文件用package:开头：<br>比如导入用于网络请求的dio库：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &#x27;package:dio/dio.dart&#x27;;</span><br></pre></td></tr></table></figure>
<p>Dart 应用本身就是一个库，比如我的应用名是blog，导入其他文件夹的类：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import &#x27;package:blog/common/net_utils.dart&#x27;;</span><br><span class="line">import &#x27;package:blog/model/user.dart&#x27;;</span><br></pre></td></tr></table></figure>
<p>Dart 通过pub.dev来管理类库，类似Java世界的Maven 或者Node.js的npm一样，你可以在里面找到非常多实用的库。</p>
<h3 id="解决类名冲突"><a href="#解决类名冲突" class="headerlink" title="解决类名冲突"></a>解决类名冲突</h3><p>如果导入的类库有类名冲突，可以通过as使用别名来避免这个问题：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import &#x27;package:lib1/lib1.dart&#x27;;</span><br><span class="line">import &#x27;package:lib2/lib2.dart&#x27; as lib2;</span><br><span class="line"></span><br><span class="line">// 使用来自 lib1 的 Element</span><br><span class="line">Element element1 = Element();</span><br><span class="line"></span><br><span class="line">// 使用来自 lib2 的 Element</span><br><span class="line">lib2.Element element2 = lib2.Element();</span><br></pre></td></tr></table></figure>
<h3 id="导入部分类"><a href="#导入部分类" class="headerlink" title="导入部分类"></a>导入部分类</h3><p>在一个dart文件中，可能会存在很多个类，如果你只想引用其中几个，你可以增加show或者hide来处理：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//文件：my_lib.dart中</span><br><span class="line">class One &#123;&#125;</span><br><span class="line"></span><br><span class="line">class Two&#123;&#125;</span><br><span class="line"></span><br><span class="line">class Three&#123;&#125;</span><br><span class="line">使用show导入One和Two类：</span><br><span class="line"></span><br><span class="line">//文件：test.dart中</span><br><span class="line">import &#x27;my_lib.dart&#x27; show One， Two;</span><br><span class="line"></span><br><span class="line">void main() &#123;</span><br><span class="line">  var one = One();</span><br><span class="line">  var two = Two();</span><br><span class="line">  //compile error</span><br><span class="line">  var three = Three();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也可以使用hide排除Three，和上面是等价的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//文件：test.dart中</span><br><span class="line">import &#x27;my_lib.dart&#x27; hide Three;</span><br><span class="line"></span><br><span class="line">void main() &#123;</span><br><span class="line">  var one = One();</span><br><span class="line">  var two = Two();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="十二-异步"><a href="#十二-异步" class="headerlink" title="十二.异步"></a>十二.异步</h1><h3 id="开发中的耗时操作："><a href="#开发中的耗时操作：" class="headerlink" title="开发中的耗时操作："></a>开发中的耗时操作：</h3><p>在开发中，我们经常会遇到一些耗时的操作需要完成，比如网络请求、文件读取等等；如果我们的主线程一直在等待这些耗时的操作完成，那么就会进行阻塞，无法响应其它事件。<br>处理耗的操作有两种方式:</p>
<ul>
<li>处理方式一： 多线程，比如Java、C++，我们普遍的做法是开启一个新的线程（Thread），在新的线程中完成这些异步的操作，再通过线程间通信的方式，将拿到的数据传递给主线程。</li>
<li>处理方式二： 单线程+事件循环，比如JavaScript、Dart都是基于单线程加事件循环来完成耗时操作的处理。<br>Dart是一个单线程编程语言。在Dart的世界里没有多线程之说，当然也没有了所谓的主线程和子线程之分。如果任何代码阻塞线程执行都会导致程序卡死。</li>
</ul>
<h3 id="阻塞式调用和非阻塞式调用"><a href="#阻塞式调用和非阻塞式调用" class="headerlink" title="阻塞式调用和非阻塞式调用"></a>阻塞式调用和非阻塞式调用</h3><ul>
<li>阻塞式调用： 调用结果返回之前，当前线程会被挂起，调用线程只有在得到调用结果之后才会继续执行。</li>
<li>非阻塞式调用： 调用执行之后，当前线程不会停止执行，只需要过一段时间来检查一下有没有结果返回即可。</li>
</ul>
<h3 id="单线程模型"><a href="#单线程模型" class="headerlink" title="单线程模型"></a>单线程模型</h3><p>在Java中使用多线程来处理并发任务，适量并合适地使用多线程，能够极大地提高资源的利用率和程序运行效率，但是缺点也比较明显，比如过度开启线程会带来额外的资源和性能消耗或多线程共享内存容易出现死锁等。<br>因此又出现了基于事件的异步模型。简单说就是在某个单线程中存在一个事件循环和一个事件队列，事件循环不断的从事件队列中取出事件来执行，这里的事件就好比是一段代码，每当遇到耗时的事件时，事件循环不会停下来等待结果，<br>它会跳过耗时事件，继续执行其后的事件。当不耗时的事件都完成了，再来查看耗时事件的结果。因此，耗时事件不会阻塞整个事件循环，这让它后面的事件也会有机会得到执行。</p>
<p>Dart是一种单线程语言，因此Dart程序没有主线程和子线程之分，Dart是通过消息循环(Event Looper)和事件队列(Event queue)来进行异步操作的.Dart在一条执行线上，同时且只能执行一个任务（事件），其他任务都必须在后面排队等待被执行。也就是说，在一条执行线上，为了不阻碍代码的执行<br>，每遇到的耗时任务都会被挂起放入任务队列，待执行结束后再按放入顺序依次执行队列上的任务，从而达到异步效果。</p>
<p>Dart事件循环机制是由一个 消息循环(Event looper) 和两个消息队列：事件队列(Event queue) 和 微任务队列(MicroTask queue) 构成。</p>
<p><img src="/images/3834a09a65d265a0c57fe6ed7c58c258.webp" alt="image.png"><br>从上图可知，Dart事件循环机制由一个消息循环(event looper)和两个消息队列构成，其中，两个消息队列是指事件队列(event queue)和微任务队列(Microtask queue)。该机制运行原理为：</p>
<ul>
<li>首先，Dart程序从main函数开始运行，待main函数执行完毕后，event looper开始工作。</li>
<li>然后，event looper优先遍历执行Microtask队列所有事件，直到Microtask队列为空。</li>
<li>接着，event looper才遍历执行Event队列中的所有事件，直到Event队列为空。</li>
<li>最后，视情况退出循环。</li>
</ul>
<blockquote>
<p>注意: Dart中使用阻塞式调用也会造成程序卡死.</p>
</blockquote>
<h3 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h3><p>Dart 为 Event Queue 的任务建立提供了一层封装，叫作 Future。从名字上也很容易理解，它表示一个在未来时间才会完成的任务。Future 是一个延后计算的对象，即它的返回值当前并不一定可用，<br>在未来某个时刻它完成计算后便会返回可用的值。比如一个网络请求。通常使用 Future.then 来处理计算完成的场合，用 Future.catchError 来处理发生异常的场合。<br>Future是用于自定义Event queue事件。通过创建Future类实例来向Event queue添加事件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">new Future(() &#123;</span><br><span class="line">  // 事件任务</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h5 id="then"><a href="#then" class="headerlink" title="then"></a>then</h5><p>创建完成Future对象后，可以通过then方法接收Future的结果。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import &quot;dart:io&quot;;</span><br><span class="line">main(List&lt;String&gt; args) &#123;</span><br><span class="line">     print(&quot;main() start&quot;);</span><br><span class="line">     //使用变量接收getNetworkData返回的future</span><br><span class="line">     var future = getNetworkData();</span><br><span class="line">     //通过then方法接收Future的结果。</span><br><span class="line">     future.then((value) &#123;</span><br><span class="line">       print(value);</span><br><span class="line">     &#125;);</span><br><span class="line">     print(&quot;main() end&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   Future&lt;String&gt; getNetworkData() &#123;</span><br><span class="line">     return Future&lt;String&gt;(() &#123;</span><br><span class="line">       sleep(Duration(seconds: 3));</span><br><span class="line">       return &quot;network data&quot;;</span><br><span class="line">     &#125;);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>执行结果:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">main() start</span><br><span class="line">main() end</span><br><span class="line">network data</span><br></pre></td></tr></table></figure>
<p>Future的链式调用，可以在then中继续返回值，会在下一个链式的then调用回调函数中拿到返回的结果。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">import &quot;dart:io&quot;;</span><br><span class="line">main(List&lt;String&gt; args) &#123;</span><br><span class="line">  print(&quot;main() start&quot;);</span><br><span class="line">  getNetworkData().then((value1) &#123;</span><br><span class="line">    //得到第一次异步操作的回调，并且执行第二次异步操作</span><br><span class="line">    print(value1);</span><br><span class="line">    return &quot;network data2&quot;;</span><br><span class="line">  &#125;).then((value2) &#123;</span><br><span class="line">    //得到第二次异步操作的回调，并且执行第三次异步操作</span><br><span class="line">    print(value2);</span><br><span class="line">    return &quot;network data3&quot;;</span><br><span class="line">  &#125;).then((value3) &#123;</span><br><span class="line">    //得到第三次异步操作的回调，</span><br><span class="line">    print(value3);</span><br><span class="line">  &#125;);</span><br><span class="line">  print(&quot;main() end&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Future&lt;String&gt; getNetworkData() &#123;</span><br><span class="line">  return Future&lt;String&gt;(() &#123;</span><br><span class="line">    sleep(Duration(seconds: 3));</span><br><span class="line">    return &quot;network data&quot;;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">main() start</span><br><span class="line">main() end</span><br><span class="line">network data</span><br><span class="line">network data2</span><br><span class="line">network data3</span><br></pre></td></tr></table></figure>


<h5 id="catchError"><a href="#catchError" class="headerlink" title="catchError"></a>catchError</h5><p>如果Future内的函数执行发生异常，可以通过Future.catchError来处理异常：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import &quot;dart:io&quot;;</span><br><span class="line"></span><br><span class="line">main(List&lt;String&gt; args) &#123;</span><br><span class="line">  print(&quot;main() start&quot;);</span><br><span class="line">  var future = getNetworkData();</span><br><span class="line">  future.then((value) &#123;</span><br><span class="line">    print(value);</span><br><span class="line">  &#125;).catchError((error) &#123; // 捕获出现异常时的情况</span><br><span class="line">    print(error);</span><br><span class="line">  &#125;);</span><br><span class="line">  print(&quot;main() end&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="async-和-await-关键字"><a href="#async-和-await-关键字" class="headerlink" title="async 和 await 关键字"></a>async 和 await 关键字</h3><p>async 和 await 关键字用于支持 Dart 语言的异步特性。async用来修饰方法，需要写在方法括号的后面， 它的调用者并不会等待它执行完毕。而 await 关键字必须存在于 async 方法内，被标为await的语句一般为耗时操作，<br>它后面的语句会等待 await 语句执行完毕。当耗时操作完成时，await后面的代码便会得到执行(异步)。这对关键字的存在意义就是以同步的编程风格，实现异步的执行。await表达式可以使用多次。<br>有了这两个关键字，我们可以更简洁的编写异步代码，而不需要调用Future相关的API。<br>将 async 关键字作为方法声明的后缀时，具有如下意义:</p>
<ul>
<li>被修饰的方法会将一个 Future 对象作为返回值</li>
<li>该方法会同步执行其中的方法的代码直到第一个 await 关键字，然后它暂停该方法其他部分的执行；</li>
<li>一旦由 await 关键字引用的 Future 任务执行完成，await的下一行代码将立即执行。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 导入io库，调用sleep函数</span><br><span class="line">import &#x27;dart:io&#x27;;</span><br><span class="line">void main()&#123;</span><br><span class="line">  print(&quot;main() start&quot;);</span><br><span class="line">  getData();</span><br><span class="line">  print(&quot;main() end&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 定义一个函数用于包装</span><br><span class="line">getData() async &#123;</span><br><span class="line">  var r = await getNetworkData();</span><br><span class="line">  print(r);</span><br><span class="line">&#125;</span><br><span class="line">// 模拟耗时操作，调用sleep函数睡眠2秒</span><br><span class="line">getNetworkData() async&#123;</span><br><span class="line">  await sleep(const Duration(seconds:2));</span><br><span class="line">  return &quot;network data&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">main() start</span><br><span class="line">main() end</span><br><span class="line">network data</span><br></pre></td></tr></table></figure>
<blockquote>
<p>需要注意，async 不是并行执行，它是遵循Dart 事件循环规则来执行的，它仅仅是一个语法糖，简化Future API的使用。</p>
</blockquote>
<h3 id="轻量异步任务"><a href="#轻量异步任务" class="headerlink" title="轻量异步任务"></a>轻量异步任务</h3><p> 对于一些轻量异步任务，比如一个小的网络请求，本身的计算量不大，只是我们不知道它的确切完成时间。这种情况我们用 async 和 await 来简单创建一个异步任务即可。<br>这个异步任务并没有创建新线程，只是通过语言机制达到了异步执行而已。一个简单的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;String&gt;( () async &#123; </span><br><span class="line">    await Future.delayed(Duration(seconds: 5)); //故意等待5秒(只模拟未知时间，并没有多大计算量)</span><br><span class="line">    return &quot;一个假设的计算结果&quot;;</span><br><span class="line">&#125;).then((value) &#123;</span><br><span class="line">    print(&quot;$&#123;DateTime.now()&#125; 返回 :$value&quot;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">print(&quot;$&#123;DateTime.now()&#125; 这里没有等待&quot;);</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">这里没有等待</span><br><span class="line">返回 :一个假设的计算结果</span><br></pre></td></tr></table></figure>
<p>从输出我们看到一个异步执行机制， 异步方法后面的语句立即得到执行，5秒后，再输出模拟计算的结果。这里的延时5秒实际并没有占用多少CPU资源，所以它属于轻量计算。<br>在实际测试中，轻量的异步计算并不会导致UI卡顿。到底多少计算量会导致UI卡顿？一般情况下，如果真实的CPU计算耗时超过10毫秒，就有卡顿风险了。那时就需要创建线程了。</p>
<h3 id="Isolate"><a href="#Isolate" class="headerlink" title="Isolate"></a>Isolate</h3><p>大多数计算机中，甚至在移动平台上，都在使用多核CPU。 为了有效利用多核性能，开发者一般使用共享内存数据来保证多线程的正确执行。<br>然而多线程共享数据通常会导致很多潜在的问题，并导致代码运行出错。<br>Dart作为一种新语言，为了缓解上述问题，提出了Isolate(隔离区)的概念，即Dart没有线程的概念，只有Isolate，所有的Dart代码都是在Isolate中运行，<br>它就像是机器上的一个小空间，具有自己的私有内存堆和一个运行着Event Looper的单个线程。<br>它与线程最大的区别就是不能共享内存，因此也不存在锁竞争问题，两个Isolate完全是两条独立的执行线，且每个Isolate都有自己的事件循环，它们之间使用 Port 和 Message 来发送消息通信，所以它的资源开销低于线程。<br>Isolate 可执行于不同CPU核心来提高性能。<br>默认情况下，Dart程序只有一个Isolate(未自己创建的情况下)，而这个Isolate就是Main Isolate。也就是说，一个Dart程序是从Main Isolate的main函数开始的，而在main函数结束后<br>，Main isolate线程开始一个一个处理事件循环模型队列中的每一事件(Event)。</p>
<h5 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h5><p>使用场景<br>在 Dart 中 async 和 Future 无法解决所有耗时的工作。Dart 虽然支持 异步执行，但其实如果是通过 async 的话，只是把工作丟到同一个 event loop 中， 让他暂时不会卡住目前的工作 ， 等到真的轮到它执行的时候 ，<br>如果它真的很耗时，那 main isolate 还是会 freeze(冻结) 住的 (为什么会冻结？ 主线程负责 UI的渲染 工作 但是 如果 密集型计算 很耗时 假如 这个计算 占用 1s的时间 你的UI就会卡住1s) 。<br>Dart 主要的 task 都是在 main isolate 中完成的，isolate 像是个 single thread 的 process。如果真的想要让某些工作能夠同时执行，不要卡住 main isolate 的话，就得要自己产生新的 isolate 來执行。</p>
<h5 id="创建Isolate"><a href="#创建Isolate" class="headerlink" title="创建Isolate"></a>创建Isolate</h5><p>需要导入 isolate</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &#x27;dart:isolate&#x27;;</span><br></pre></td></tr></table></figure>

<p>创建Isolate是比较简单的，可以使用 Isolate.spawn() 或 Flutter的 compute() 函数创建单独的隔离区来进行消耗性能的计算。<br>新创建的隔离区拥有自己的事件循环和内存，即使原始隔离区是该新隔离区的父级，也不允许其访问。<br>Isolate.spawn 必须传入一个有且仅有一个参数的函数，不可以不传。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import &#x27;dart:isolate&#x27;;</span><br><span class="line"></span><br><span class="line">void main()  &#123;</span><br><span class="line">  Isolate.spawn(isolate， &quot;true&quot;);</span><br><span class="line">  Isolate.spawn(isolate， &quot;false&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void isolate(String data) &#123;</span><br><span class="line">  print(&quot;isolate $&#123;data&#125;&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>当我们调用 Isolate.spawn 的时候，它将会返回一个对 isolate 的引用的 Future。我们可以通过这个 isolate 来控制创建出的 Isolate，例如 pause、resume、kill 等等。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">import &#x27;dart:io&#x27;;</span><br><span class="line">import &#x27;dart:isolate&#x27;;</span><br><span class="line">import &#x27;lib/rf_timetool.dart&#x27;;</span><br><span class="line"></span><br><span class="line">main(List&lt;String&gt; args) &#123;</span><br><span class="line">  print(&#x27;main start $&#123;DateTime.now()&#125;&#x27;);</span><br><span class="line"></span><br><span class="line">  //开辟另一个Isolate执行耗时操作</span><br><span class="line">  Isolate.spawn(caculate， 100).then((value) &#123;</span><br><span class="line">    print(&#x27;value = $value&#x27;);</span><br><span class="line">    print(&#x27;$&#123;getDateStringNow()&#125;&#x27;);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  print(&#x27;main end $&#123;DateTime.now()&#125;&#x27;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">caculate(int count) &#123;</span><br><span class="line">  sleep(Duration(seconds: 3));</span><br><span class="line">  // print(&#x27;$&#123;getDateStringNow()&#125;&#x27;);</span><br><span class="line">  var total = 0;</span><br><span class="line">  for (var i = 0; i &lt;= count; i++) &#123;</span><br><span class="line">    total += i;</span><br><span class="line">  &#125;</span><br><span class="line">  print(total);</span><br><span class="line">  return total;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Isolate通信机制"><a href="#Isolate通信机制" class="headerlink" title="Isolate通信机制"></a>Isolate通信机制</h5><p>但是在真实开发中，我们不会只是简单的开启一个新的Isolate，而不关心它的运行结果：</p>
<ul>
<li>我们需要新的Isolate进行计算，并且将计算结果告知Main Isolate（也就是默认开启的Isolate）。</li>
<li>Isolate 通过发送管道（SendPort）实现消息通信机制。</li>
<li>我们可以在启动并发Isolate时将Main Isolate的发送管道作为参数传递给它。</li>
<li>并发在执行完毕时，可以利用这个管道给Main Isolate发送消息。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">import &#x27;dart:io&#x27;;</span><br><span class="line">import &#x27;dart:isolate&#x27;;</span><br><span class="line"></span><br><span class="line">main(List&lt;String&gt; args) async &#123;</span><br><span class="line">  print(&#x27;main start $&#123;DateTime.now()&#125;&#x27;);</span><br><span class="line"></span><br><span class="line">  //1. 创建管道</span><br><span class="line">  ReceivePort port = ReceivePort();</span><br><span class="line"></span><br><span class="line">  //2.创建Isolata</span><br><span class="line">  Isolate isolate = await Isolate.spawn(foo， port.sendPort);</span><br><span class="line"></span><br><span class="line">  //3.监听管道</span><br><span class="line">  port.listen((message) &#123;</span><br><span class="line">    print(&#x27;$message ， $&#123;DateTime.now()&#125;&#x27;);</span><br><span class="line">    //关闭监听;</span><br><span class="line">    port.close();</span><br><span class="line">    // 销毁被监听的Isolate</span><br><span class="line">    isolate.kill();</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  print(&#x27;main end $&#123;DateTime.now()&#125;&#x27;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(SendPort senport) &#123;</span><br><span class="line">  sleep(Duration(seconds: 3));</span><br><span class="line">  int total = 0;</span><br><span class="line">  for (var i = 0; i &lt; 100000000; i++) &#123;</span><br><span class="line">    total += i;</span><br><span class="line">  &#125;</span><br><span class="line">  return senport.send(&#x27;total = $&#123;total&#125;&#x27;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>双向通信:</strong></p>
<ul>
<li>事实上双向通信的代码会比较麻烦。</li>
<li>Flutter提供了支持并发计算的compute函数，它内部封装了Isolate的创建和双向通信。</li>
<li>利用它我们可以充分利用多核心CPU，并且使用起来也非常简单。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">main(List&lt;String&gt; args) async &#123;</span><br><span class="line">  int result = await compute(powerNum， 5);</span><br><span class="line">  print(result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int powerNum(int num) &#123;</span><br><span class="line">  return num * num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>注意：上面的代码不是dart的API，而是Flutter的API，所以只有在Flutter项目中才能运行。</p>
<h5 id="Future和isolate选择"><a href="#Future和isolate选择" class="headerlink" title="Future和isolate选择"></a>Future和isolate选择</h5><p>Isolate 实际上是比较重的，每当我们创建出来一个新的 Isolate 至少需要 2mb 左右的空间甚至更多，取决于我们具体 isolate 的用途。那么应该在什么时候使用Future，什么时候使用Isolate呢？<br>其实这个问题，更值得去注意，因为这是和实际的开发直接相关，有时候确实需要知道什么时候应该是 Future ，什么时候应该使用 isolate .<br>有的人说使用 isolate 比较重，一般不建议采用，其实不能这样一概而论。 isolate 也是有使用场景的，有些人会疑惑网络请求应该算耗时吧，平时一般使用 Future 就够了，</p>
<p>最简单的判断方法是根据某些任务的平均时间来选择：</p>
<ul>
<li>方法执行在几毫秒或十几毫秒左右的，应使用Future。</li>
<li>如果一个任务需要几百毫秒或之上的，则建议创建单独的Isolate。</li>
</ul>
<p>换句话说，建议尽可能多地使用 Future （直接或间接通过异步方法），因为一旦 EventLoop 有空闲期，这些 Future 的代码就会运行。</p>
<ul>
<li>如果一段代码不会被中断，那么就直接使用Future就行。</li>
<li>如果代码段可以独立运行而不会影响应用程序的流畅性，建议使用 Future。</li>
<li>如果繁重的处理可能要花一些时间才能完成，而且会影响应用程序的流畅性，建议使用 isolate。</li>
</ul>
<p>下面列出一些使用 isolate 的具体场景:</p>
<ul>
<li>JSON大数据解析: 解码大JSON数据。</li>
<li>加解密: 加解密过程比较耗时</li>
<li>图片处理: 比如裁剪图片比较耗时</li>
<li>从网络中加载大图</li>
</ul>
<p>参考资料:<br><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903989843066894#heading-3">Dart语法篇之函数的使用(四)</a><br><a target="_blank" rel="noopener" href="https://juejin.im/post/5eb27d63f265da7bc35390b6#heading-27">Flutter Dart 语言基础详解</a><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/lxlx1798/p/11126564.html">【dart学习】– Dart之异步编程</a><br><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903950257225735#heading-43">Dart语法</a></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://lxlfpeng.github.io">peng</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://lxlfpeng.github.io/2019/06/28/Dart%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/">https://lxlfpeng.github.io/2019/06/28/Dart%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://lxlfpeng.github.io" target="_blank">鹏哥的Blog</a>！</span></div></div><div class="tag_share"><div class="post-share"><div class="social-share" data-image="/images/about_avatar.webp" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2019/07/01/Android%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9ADataBinding/" title="Android数据绑定DataBinding"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Android数据绑定DataBinding</div></div><div class="info-2"><div class="info-item-1">一.DataBinding简介MVVM架构的核心就是数据驱动，数据驱动的意思就是，数据更新的时候，自动刷新UI。采用MVVM架构会节省大量的更新UI的代码，并且数据更新后主动出发UI更新这种方式，更难出错，鲁棒性更强。且不需要关注数据变化的时机，是需要关注数据变化的结果即可。 1.开启DataBinding功能 使用最新版的AndroidStudio，至少AS3.0以上。 在项目module下的build.gradle的android闭包下，配置 databinding{enabled&#x3D;true}。 对于布局的xml文件，将原有的正常布局，外面用包裹作为跟节点。节点下存放用于xml布局的一些变量，工具类之类的。   打开布局文件，选中根布局的 ViewGroup，按住 Alt + 回车键，点击 “Convert to data binding layout”，就可以生成 DataBinding 需要的布局规则  2.DataBinding简单使用(1.)声明一个数据对象12package com.peng.databindingdemo.modeldata class...</div></div></div></a><a class="pagination-related" href="/2019/06/21/Flutter%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E5%8F%8A%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AE/" title="Flutter环境搭建及项目配置"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Flutter环境搭建及项目配置</div></div><div class="info-2"><div class="info-item-1">一. 下载安装Flutter。1.1 下载安装包Flutter SDK 1.2 下载完成后进行解压: 1.3 配置环境变量。控制面板-&gt;系统和安全-&gt;系统-&gt;高级系统设置-&gt;环境变量-&gt;path-&gt;编辑-&gt;新建 1.4 安装flutter依赖并检查。cmd命令: 1flutter doctor  1.5 查看flutter版本。1flutter doctor -v 二. Android Studio安装配置。2.1 Android studio安装dart和flutter插件。  2.2 重启Android studio创建flutter工程。 三. VsCode配置。1. vscode添加flutter支持。 2. 创建一个flutter的项目。 3.使用模拟器调试。 四. 创建或者运行项目卡住问题创建项目一直卡在Creating Flutter Project没反应。运行项目一直卡在: 1Running Gradle task &#x27;assembleDebug&#x27;...  ...</div></div></div></a></nav><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="giscus-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/images/about_avatar.webp" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">peng</div><div class="author-info-description">过往不恋 未来不迎 当下不负</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">127</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">59</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">24</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/lxlfpeng"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/lxlfpeng" target="_blank" title="Github"><i class="fab fa-github" style="color: #4a7dbe;"></i></a><a class="social-icon" href="mailto:565289282@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎来到我的博客!</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80-Dart-%E7%AE%80%E8%BF%B0"><span class="toc-number">1.</span> <span class="toc-text">一.Dart 简述</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C-%E5%8F%98%E9%87%8F%E3%80%82"><span class="toc-number">2.</span> <span class="toc-text">二.变量。</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%8F%98%E9%87%8F%E7%9A%84%E5%A3%B0%E6%98%8E%E3%80%82"><span class="toc-number">2.0.1.</span> <span class="toc-text">1.变量的声明。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%98%BE%E5%BC%8F%E6%8C%87%E5%AE%9A%E7%B1%BB%E5%9E%8B%E6%9D%A5%E5%AE%9A%E4%B9%89%E5%8F%98%E9%87%8F"><span class="toc-number">2.0.2.</span> <span class="toc-text">2. 显式指定类型来定义变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E9%9A%90%E5%BC%8F%E6%8E%A8%E5%AF%BC%E5%8F%98%E9%87%8F"><span class="toc-number">2.0.3.</span> <span class="toc-text">3. 隐式推导变量.</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%8A%A8%E6%80%81%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.0.4.</span> <span class="toc-text">4 动态数据类型.</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#dynamic"><span class="toc-number">2.0.4.0.1.</span> <span class="toc-text">dynamic:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#object"><span class="toc-number">2.0.4.0.2.</span> <span class="toc-text">object:</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89-%E5%B8%B8%E9%87%8F%E3%80%82"><span class="toc-number">3.</span> <span class="toc-text">三.常量。</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Final-%E4%BF%AE%E9%A5%B0%E7%AC%A6%E5%AE%9A%E4%B9%89%E5%B8%B8%E9%87%8F"><span class="toc-number">3.0.1.</span> <span class="toc-text">1.Final 修饰符定义常量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-const%E4%BF%AE%E9%A5%B0%E7%AC%A6%E5%AE%9A%E4%B9%89%E5%B8%B8%E9%87%8F"><span class="toc-number">3.0.2.</span> <span class="toc-text">2.const修饰符定义常量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-final-%E5%92%8C-const-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">3.0.3.</span> <span class="toc-text">3. final 和 const 的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%8F%98%E9%87%8F%E7%9A%84%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99%EF%BC%9A"><span class="toc-number">3.0.4.</span> <span class="toc-text">4.变量的命名规则：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9B-%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E3%80%82"><span class="toc-number">4.</span> <span class="toc-text">四.常用数据类型。</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%95%B0%E5%80%BC%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.0.1.</span> <span class="toc-text">1.数值类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.0.2.</span> <span class="toc-text">2.字符串类型</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Dart%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8%E5%8D%95%E5%BC%95%E5%8F%B7%E6%88%96%E5%8F%8C%E5%BC%95%E5%8F%B7%E6%9D%A5%E5%88%9B%E5%BB%BA%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">4.0.2.0.1.</span> <span class="toc-text">Dart可以使用单引号或双引号来创建字符串</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Dart%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8%E4%B8%89%E5%BC%95%E5%8F%B7%E6%9D%A5%E5%88%9B%E5%BB%BA%E5%8C%85%E5%90%AB%E5%A4%9A%E8%A1%8C%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">4.0.2.0.2.</span> <span class="toc-text">Dart可以使用三引号来创建包含多行的字符串</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Dart%E6%94%AF%E6%8C%81%E4%BD%BF%E7%94%A8%E2%80%9D-%E2%80%9D%E6%93%8D%E4%BD%9C%E7%AC%A6%E6%8B%BC%E6%8E%A5%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">4.0.2.0.3.</span> <span class="toc-text">Dart支持使用”+”操作符拼接字符串</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Dart%E6%8F%90%E4%BE%9B%E4%BA%86%E6%8F%92%E5%80%BC%E8%A1%A8%E8%BE%BE%E5%BC%8F%E2%80%9D-%E2%80%9D%EF%BC%8C%E4%B9%9F%E5%8F%AF%E4%BB%A5%E7%94%A8%E4%BA%8E%E6%8B%BC%E6%8E%A5%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">4.0.2.0.4.</span> <span class="toc-text">Dart提供了插值表达式”${}”，也可以用于拼接字符串</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%8Ekotlin%E7%B1%BB%E4%BC%BC%EF%BC%8CDart%E4%BD%BF%E7%94%A8%E2%80%9D-%E2%80%9D%E6%9D%A5%E6%AF%94%E8%BE%83%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%86%85%E5%AE%B9"><span class="toc-number">4.0.2.0.5.</span> <span class="toc-text">与kotlin类似，Dart使用”&#x3D;&#x3D;”来比较字符串的内容</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C%E5%8A%9F%E8%83%BD"><span class="toc-number">4.0.2.0.6.</span> <span class="toc-text">其他字符串操作功能</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%B8%83%E5%B0%94%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.0.3.</span> <span class="toc-text">4.布尔类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%88%97%E8%A1%A8"><span class="toc-number">4.0.4.</span> <span class="toc-text">5.列表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E6%98%A0%E5%B0%84"><span class="toc-number">4.0.5.</span> <span class="toc-text">6.映射</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E5%AD%97%E9%9D%A2%E9%87%8F%E5%88%9B%E5%BB%BAMap"><span class="toc-number">4.0.5.0.1.</span> <span class="toc-text">通过字面量创建Map</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8Map%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1"><span class="toc-number">4.0.5.0.2.</span> <span class="toc-text">使用Map类的构造函数创建对象</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96Map%E7%9A%84%E9%95%BF%E5%BA%A6"><span class="toc-number">4.0.5.0.3.</span> <span class="toc-text">获取Map的长度</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9F%A5%E6%89%BEMap"><span class="toc-number">4.0.5.0.4.</span> <span class="toc-text">查找Map</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9B-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E3%80%82"><span class="toc-number">5.</span> <span class="toc-text">四.流程控制。</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-if%E5%92%8Celse"><span class="toc-number">5.0.1.</span> <span class="toc-text">1.if和else</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%BE%AA%E7%8E%AF-for%EF%BC%8Cwhile-%E5%92%8C-do-while"><span class="toc-number">5.0.2.</span> <span class="toc-text">2.循环 for，while 和 do-while</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-switch-case"><span class="toc-number">5.0.3.</span> <span class="toc-text">3.switch case</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-break-continue"><span class="toc-number">5.0.4.</span> <span class="toc-text">4.break continue</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%94-%E5%87%BD%E6%95%B0%E3%80%82"><span class="toc-number">6.</span> <span class="toc-text">五.函数。</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%96%B9%E6%B3%95%E5%AE%9A%E4%B9%89"><span class="toc-number">6.0.1.</span> <span class="toc-text">1.方法定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%91%BD%E5%90%8D%E5%8F%82%E6%95%B0"><span class="toc-number">6.0.2.</span> <span class="toc-text">2.命名参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E4%BD%8D%E7%BD%AE%E5%8F%82%E6%95%B0"><span class="toc-number">6.0.3.</span> <span class="toc-text">3.位置参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0"><span class="toc-number">6.0.4.</span> <span class="toc-text">4.匿名函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%B1%80%E9%83%A8%E5%87%BD%E6%95%B0"><span class="toc-number">6.0.5.</span> <span class="toc-text">5.局部函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E9%A1%B6%E5%B1%82%E5%87%BD%E6%95%B0%E5%92%8C%E9%9D%99%E6%80%81%E5%87%BD%E6%95%B0"><span class="toc-number">6.0.6.</span> <span class="toc-text">6.顶层函数和静态函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%87%BD%E6%95%B0%E4%BD%9C%E4%B8%BA%E5%8F%82%E6%95%B0"><span class="toc-number">6.0.7.</span> <span class="toc-text">4.函数作为参数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AD-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-number">7.</span> <span class="toc-text">六. 异常处理</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%83-%E7%B1%BB"><span class="toc-number">8.</span> <span class="toc-text">七.类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">8.0.1.</span> <span class="toc-text">类的定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E5%BC%95%E5%85%A5"><span class="toc-number">8.0.2.</span> <span class="toc-text">类的引入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">8.0.3.</span> <span class="toc-text">构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%91%BD%E5%90%8D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">8.0.4.</span> <span class="toc-text">命名构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8"><span class="toc-number">8.0.5.</span> <span class="toc-text">初始化列表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E4%B8%AD%E7%9A%84getter%E5%92%8Csetter%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-number">8.0.6.</span> <span class="toc-text">类中的getter和setter修饰符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%8F%98%E9%87%8F%E7%9A%84%E5%8F%AF%E8%A7%81%E6%80%A7"><span class="toc-number">8.0.7.</span> <span class="toc-text">类变量的可见性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E4%B8%AD%E7%9A%84%E9%9D%99%E6%80%81%E6%88%90%E5%91%98-%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95"><span class="toc-number">8.0.8.</span> <span class="toc-text">类中的静态成员 静态方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F"><span class="toc-number">8.0.8.0.1.</span> <span class="toc-text">静态变量</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95"><span class="toc-number">8.0.8.0.2.</span> <span class="toc-text">静态方法</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AB-%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3"><span class="toc-number">9.</span> <span class="toc-text">八.抽象类和接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="toc-number">9.0.1.</span> <span class="toc-text">抽象类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9A%90%E5%BC%8F%E7%9A%84%E6%8E%A5%E5%8F%A3"><span class="toc-number">9.0.2.</span> <span class="toc-text">隐式的接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Mixin%E6%B7%B7%E5%85%A5"><span class="toc-number">9.0.3.</span> <span class="toc-text">Mixin混入</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AB-%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF"><span class="toc-number">10.</span> <span class="toc-text">八.类的继承</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#extends-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">10.0.1.</span> <span class="toc-text">extends 关键字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E5%86%99%E6%88%90%E5%91%98"><span class="toc-number">10.0.2.</span> <span class="toc-text">重写成员</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E5%86%99%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">10.0.3.</span> <span class="toc-text">重写操作符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#noSuchMethod"><span class="toc-number">10.0.4.</span> <span class="toc-text">noSuchMethod()</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B9%9D-%E6%9E%9A%E4%B8%BE"><span class="toc-number">11.</span> <span class="toc-text">九. 枚举</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%9E%9A%E4%B8%BE"><span class="toc-number">11.0.1.</span> <span class="toc-text">使用枚举</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81-%E6%B3%9B%E5%9E%8B"><span class="toc-number">12.</span> <span class="toc-text">十. 泛型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95"><span class="toc-number">12.0.1.</span> <span class="toc-text">泛型方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E7%B1%BB"><span class="toc-number">12.0.2.</span> <span class="toc-text">泛型类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E6%8E%A5%E5%8F%A3"><span class="toc-number">12.0.3.</span> <span class="toc-text">泛型接口</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81%E4%B8%80-%E4%BD%BF%E7%94%A8%E7%B1%BB%E5%BA%93"><span class="toc-number">13.</span> <span class="toc-text">十一.使用类库</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%BC%E5%85%A5%E7%B1%BB%E5%BA%93"><span class="toc-number">13.0.1.</span> <span class="toc-text">导入类库</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E7%B1%BB%E5%90%8D%E5%86%B2%E7%AA%81"><span class="toc-number">13.0.2.</span> <span class="toc-text">解决类名冲突</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%BC%E5%85%A5%E9%83%A8%E5%88%86%E7%B1%BB"><span class="toc-number">13.0.3.</span> <span class="toc-text">导入部分类</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81%E4%BA%8C-%E5%BC%82%E6%AD%A5"><span class="toc-number">14.</span> <span class="toc-text">十二.异步</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E8%80%97%E6%97%B6%E6%93%8D%E4%BD%9C%EF%BC%9A"><span class="toc-number">14.0.1.</span> <span class="toc-text">开发中的耗时操作：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%BB%E5%A1%9E%E5%BC%8F%E8%B0%83%E7%94%A8%E5%92%8C%E9%9D%9E%E9%98%BB%E5%A1%9E%E5%BC%8F%E8%B0%83%E7%94%A8"><span class="toc-number">14.0.2.</span> <span class="toc-text">阻塞式调用和非阻塞式调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="toc-number">14.0.3.</span> <span class="toc-text">单线程模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Future"><span class="toc-number">14.0.4.</span> <span class="toc-text">Future</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#then"><span class="toc-number">14.0.4.0.1.</span> <span class="toc-text">then</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#catchError"><span class="toc-number">14.0.4.0.2.</span> <span class="toc-text">catchError</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#async-%E5%92%8C-await-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">14.0.5.</span> <span class="toc-text">async 和 await 关键字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%BB%E9%87%8F%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1"><span class="toc-number">14.0.6.</span> <span class="toc-text">轻量异步任务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Isolate"><span class="toc-number">14.0.7.</span> <span class="toc-text">Isolate</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">14.0.7.0.1.</span> <span class="toc-text">使用场景</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%9B%E5%BB%BAIsolate"><span class="toc-number">14.0.7.0.2.</span> <span class="toc-text">创建Isolate</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Isolate%E9%80%9A%E4%BF%A1%E6%9C%BA%E5%88%B6"><span class="toc-number">14.0.7.0.3.</span> <span class="toc-text">Isolate通信机制</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Future%E5%92%8Cisolate%E9%80%89%E6%8B%A9"><span class="toc-number">14.0.7.0.4.</span> <span class="toc-text">Future和isolate选择</span></a></li></ol></li></ol></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer" style="background: linear-gradient(20deg, #0062be, #925696, #cc426e, #fb0347);"><div id="footer-wrap"><div class="copyright">&copy;2015 - 2025 By peng</div><div class="footer_custom_text"> <a target="_blank" rel="nofollow noopener"><span>千里之行</span></a> <i class="iconfont icon-love"></i> <a target="_blank" rel="nofollow noopener"><span>始于足下</span></a> </div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.isShuoshuo
  const option = null

  const getGiscusTheme = theme => theme === 'dark' ? 'dark' : 'light'

  const createScriptElement = config => {
    const ele = document.createElement('script')
    Object.entries(config).forEach(([key, value]) => {
      ele.setAttribute(key, value)
    })
    return ele
  }

  const loadGiscus = (el = document, key) => {
    const mappingConfig = isShuoshuo
      ? { 'data-mapping': 'specific', 'data-term': key }
      : { 'data-mapping': (option && option['data-mapping']) || 'pathname' }

    const giscusConfig = {
      src: 'https://giscus.app/client.js',
      'data-repo': 'lxlfpeng/blog_comments',
      'data-repo-id': 'R_kgDONYoexA',
      'data-category-id': 'DIC_kwDONYoexM4Ck4JQ',
      'data-theme': getGiscusTheme(document.documentElement.getAttribute('data-theme')),
      'data-reactions-enabled': '1',
      crossorigin: 'anonymous',
      async: true,
      ...option,
      ...mappingConfig
    }

    const scriptElement = createScriptElement(giscusConfig)

    el.querySelector('#giscus-wrap').appendChild(scriptElement)

    if (isShuoshuo) {
      window.shuoshuoComment.destroyGiscus = () => {
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }
  }

  const changeGiscusTheme = theme => {
    const iframe = document.querySelector('#giscus-wrap iframe')
    if (iframe) {
      const message = {
        giscus: {
          setConfig: {
            theme: getGiscusTheme(theme)
          }
        }
      }
      iframe.contentWindow.postMessage(message, 'https://giscus.app')
    }
  }

  btf.addGlobalFn('themeChange', changeGiscusTheme, 'giscus')

  if (isShuoshuo) {
    'Giscus' === 'Giscus'
      ? window.shuoshuoComment = { loadComment: loadGiscus }
      : window.loadOtherComment = loadGiscus
    return
  }

  if ('Giscus' === 'Giscus' || !false) {
    if (false) btf.loadComment(document.getElementById('giscus-wrap'), loadGiscus)
    else loadGiscus()
  } else {
    window.loadOtherComment = loadGiscus
  }
})()</script></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="false"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>