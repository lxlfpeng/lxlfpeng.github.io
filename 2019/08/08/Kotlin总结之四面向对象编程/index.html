<!DOCTYPE html><html lang="zh-CN" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Kotlin总结之四面向对象编程 | 鹏哥的Blog</title><meta name="author" content="peng"><meta name="copyright" content="peng"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#0d0d0d"><meta name="description" content="一.Kotlin类的创建1.类的声明Kotlin 类可以包含：构造函数和初始化代码块、函数、属性、内部类、对象声明。Kotlin 中使用关键字 class 声明类，后面紧跟类名： 1234&#x2F;&#x2F; 类名为 Appleclass Apple&#123;   &#x2F;&#x2F; 大括号内是类体构成&#125; 当类没有结构体的时候，大括号可以省略。如: 1class Apple    类的修饰符 描述    abstr">
<meta property="og:type" content="article">
<meta property="og:title" content="Kotlin总结之四面向对象编程">
<meta property="og:url" content="https://lxlfpeng.github.io/2019/08/08/Kotlin%E6%80%BB%E7%BB%93%E4%B9%8B%E5%9B%9B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/index.html">
<meta property="og:site_name" content="鹏哥的Blog">
<meta property="og:description" content="一.Kotlin类的创建1.类的声明Kotlin 类可以包含：构造函数和初始化代码块、函数、属性、内部类、对象声明。Kotlin 中使用关键字 class 声明类，后面紧跟类名： 1234&#x2F;&#x2F; 类名为 Appleclass Apple&#123;   &#x2F;&#x2F; 大括号内是类体构成&#125; 当类没有结构体的时候，大括号可以省略。如: 1class Apple    类的修饰符 描述    abstr">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://lxlfpeng.github.io/images/about_avatar.webp">
<meta property="article:published_time" content="2019-08-07T16:00:00.000Z">
<meta property="article:modified_time" content="2025-04-12T15:02:01.844Z">
<meta property="article:author" content="peng">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://lxlfpeng.github.io/images/about_avatar.webp"><link rel="shortcut icon" href="/images/favicon.webp"><link rel="canonical" href="https://lxlfpeng.github.io/2019/08/08/Kotlin%E6%80%BB%E7%BB%93%E4%B9%8B%E5%9B%9B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Kotlin总结之四面向对象编程',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  isShuoshuo: false
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/images/about_avatar.webp" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">127</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">59</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">24</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/categories"><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background: linear-gradient(20deg, #0062be, #925696, #cc426e, #fb0347);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src="/images/nav_logo.webp" alt="Logo"><span class="site-name">鹏哥的Blog</span></a><a class="nav-page-title" href="/"><span class="site-name">Kotlin总结之四面向对象编程</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/categories"><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Kotlin总结之四面向对象编程</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2019-08-07T16:00:00.000Z" title="发表于 2019-08-08 00:00:00">2019-08-08</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Kotlin%E8%AF%AD%E8%A8%80/">Kotlin语言</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">4.3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>15分钟</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="一-Kotlin类的创建"><a href="#一-Kotlin类的创建" class="headerlink" title="一.Kotlin类的创建"></a>一.Kotlin类的创建</h1><h3 id="1-类的声明"><a href="#1-类的声明" class="headerlink" title="1.类的声明"></a>1.类的声明</h3><p>Kotlin 类可以包含：构造函数和初始化代码块、函数、属性、内部类、对象声明。<br>Kotlin 中使用关键字 class 声明类，后面紧跟类名：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 类名为 Apple</span><br><span class="line">class Apple&#123;  </span><br><span class="line"> // 大括号内是类体构成</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当类没有结构体的时候，大括号可以省略。如:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class Apple</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>类的修饰符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>abstract</td>
<td>抽象类</td>
</tr>
<tr>
<td>final</td>
<td>类不可继承，默认属性</td>
</tr>
<tr>
<td>enum</td>
<td>枚举类</td>
</tr>
<tr>
<td>open</td>
<td>类可继承，类默认是final的</td>
</tr>
<tr>
<td>annotation</td>
<td>注解类</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>访问权限修饰符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>private</td>
<td>仅在同一个文件中可见</td>
</tr>
<tr>
<td>protected</td>
<td>同一个文件中或子类可见</td>
</tr>
<tr>
<td>public</td>
<td>所有调用的地方都可见</td>
</tr>
<tr>
<td>internal</td>
<td>同一个模块中可见</td>
</tr>
</tbody></table>
<h3 id="2-类的构造函数"><a href="#2-类的构造函数" class="headerlink" title="2. 类的构造函数"></a>2. 类的构造函数</h3><p>在kotlin中有两种类型的构造函数：</p>
<ul>
<li>主构造函数(主构造器)。</li>
<li>次级构造函数(次级构造器)。<blockquote>
<p>在Kotlin类中只有一个主构造函数(主构造器)，而辅助构造函数（次级构造器）可以是一个或者多个。</p>
</blockquote>
</li>
</ul>
<h5 id="1-主构造函数"><a href="#1-主构造函数" class="headerlink" title="(1.)主构造函数"></a>(1.)主构造函数</h5><p>主构造函数是类头的一部分：它跟在类名（和可选的类型参数）后。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class 类名 construction(参数1，参数2….)&#123;  &#125;</span><br></pre></td></tr></table></figure>
<p>如果主构造函数没有任何注解或者可见性修饰符，可以省略这个 constructor 关键字，否则不能省略。<br>不能省略:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class Person private constructor(name:String)&#123;</span><br><span class="line"> val mName: String = name</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以省略:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class Person(name: String) &#123;</span><br><span class="line"> val mName: String = name</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果不需要将构造函数中参数同时作为类属性,也可以写成如下形式(constructor表示构造函数,里面执行初始化的处理):</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Person&#123;</span><br><span class="line">    constructor(name:String)&#123;</span><br><span class="line">    ....</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于主构造函数没有函数体。如果需要在主构造函数中编写代码该怎么做？初始化的代码可以放 到以 init 关键字作为前缀的初始化块（initializer blocks）中,可以在这里编写要在主构造函数中完成的业务，init{…}中能使用构造函数中的参数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Person(username: String, age: Int)&#123;</span><br><span class="line">	private val username: String</span><br><span class="line">	private var age: Int</span><br><span class="line">	init&#123;</span><br><span class="line">		this.username = username</span><br><span class="line">		this.age = age</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，主构造的参数可以在初始化块中使用。它们也可以在 类体内声明的属性初始化器中使用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class Person(name: String) &#123;</span><br><span class="line">    val name= name+&quot;...&quot;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>事实上，声明属性以及从主构造函数初始化属性，Kotlin 有简洁的语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class Person(var name: String, var age: Int) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与普通属性一样，主构造函数中声明的属性可以是 可变的（var）或只读的（val）。</p>
<h5 id="2-次构造函数"><a href="#2-次构造函数" class="headerlink" title="(2.)次构造函数"></a>(2.)次构造函数</h5><p>类也可以声明前缀有 constructor的次构造函数，可以声明多个次构造函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">    constructor() &#123;</span><br><span class="line">        ...        </span><br><span class="line">    &#125;</span><br><span class="line">   constructor(name: String) &#123;</span><br><span class="line">        ...        </span><br><span class="line">    &#125;</span><br><span class="line">  constructor(name: String,age:Int) &#123;</span><br><span class="line">        ...      </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>kotlin声明了主构造器<br>如果类有一个主构造函数，每个次构造函数需要委托给主构造函数， 可以直接委托或者通过别的次构造函数间接委托。委托到同一个类的另一个构造函数 用 this 关键字即可：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Person (name : String?,age : Int) &#123;</span><br><span class="line">    var name : String?</span><br><span class="line">    var age : Int</span><br><span class="line">    init &#123;</span><br><span class="line">        println(&quot;执行初始化块&quot;)</span><br><span class="line">        this.name = name</span><br><span class="line">        this.age = age</span><br><span class="line">    &#125;</span><br><span class="line">    constructor() : this(null,0) &#123;//直接委托调用主构造器</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    constructor(name : String) : this() &#123;//间接委托调用主构造器</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>kotlin没声明主构造器<br>kotlin没声明主构造器，重载构造器不需要调用当前类的其他构造器，调用构造器时也会执行初始化块。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">    var name : String?</span><br><span class="line">    var age : Int</span><br><span class="line">    init &#123;</span><br><span class="line">        println(&quot;执行初始化块&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    //在各自的构造器中对属性进行赋值</span><br><span class="line">    constructor() &#123;</span><br><span class="line">        this.name = null</span><br><span class="line">        this.age = 0</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    constructor(name : String) &#123;</span><br><span class="line">        this.name = name</span><br><span class="line">        this.age = 0</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    constructor(name : String, age : Int) &#123;</span><br><span class="line">        this.name = name</span><br><span class="line">        this.age = age</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">````</span><br><span class="line">如果一个非抽象类没有声明任何（主或次）构造函数，它会有一个生成的 不带参数的主构造函数。构造函数的可见性是 public。如果你不希望你的类 有一个公有构造函数，你需要声明一个带有非默认可见性的空的主构造函数(此时这个类不能够实例化)：</span><br></pre></td></tr></table></figure>
class Person private constructor () {</li>
</ol>
<p>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 当只写了主构造函数，没有次构造函数，就会覆盖了默认的空造函数，此时创建对象只能通过你写的主构造函数来调用。</span><br><span class="line">- 当只写了次构造函数，不写主构造函数，创建对象必须通过次构造函数调用，若不写空的参数构造函数，则调用空的构造函数会报错。</span><br><span class="line">- 当写了既写了主构造，又写了次构造函数，可以直接调用主构造函数或者调用次构造函数创建对象。次构造函数最终都是调用主构造函数来创建对象的。</span><br><span class="line"></span><br><span class="line">&gt;注意：在 JVM 上，如果主构造函数的所有的参数都有默认值，编译器会生成 一个额外的无参构造函数，它将使用默认值。</span><br><span class="line"></span><br><span class="line"># 二.Kotlin类的继承</span><br><span class="line">在 Kotlin 中所有类都有一个共同的超类``Any``，没有申明超类的类是默认继承超类Any：</span><br></pre></td></tr></table></figure>
<p>class Person &#x2F;&#x2F; 从 Any 隐式继承</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; Any不是 java.lang.Object；尤其是，它除了 equals()、hashCode()和toString()外没有其他属性或者方法。</span><br><span class="line"></span><br><span class="line">在Kotlin中，所有类在默认情况下都是无法被继承的，简而言之，就是说Kotlin中，所有类在默认情况下都是final的，但如何才能被继承，Kotlin给我们提供了一个``关键字open``，只有被open修饰的类才可以被继承（关键字open的作用与final相反），否则编译器会报错。</span><br></pre></td></tr></table></figure>
<p>open class Parent(p: Int)&#x2F;&#x2F;申明该类是open修饰的,该类可以继承<br>class Child(p: Int) : Parent(p)&#x2F;&#x2F;继承open类</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">方法重写:</span><br></pre></td></tr></table></figure>
<p>&#x2F;&#x2F;父类<br>open class Parent{<br>    open fun method(){}<br>    fun unOpen(){  &#x2F;&#x2F;没有open显示指定，这个函数不能被重写覆盖<br>        println(“unOpen”)<br>    }<br>}</p>
<p>&#x2F;&#x2F;子类<br>class Child: Parent() {<br>    &#x2F;&#x2F;&#x2F;重写覆盖的方法这里必须使用override关键字来修饰<br>    override fun method() {<br>        super.method()<br>    }<br>   override fun unOpen(){  &#x2F;&#x2F;Child的子类不可再被重写覆盖<br>      super.open()<br>   }<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;覆盖属性和覆盖方法类似。</span><br><span class="line"></span><br><span class="line"># 三.Kotlin抽象类</span><br><span class="line">和Java一样，在kotlin中，抽象类用关键字abstract修饰，抽象类的成员可以在本类中提供实现，也可以不实现而交给子类去实现，不实现的成员必须用关键字abstract声明：</span><br></pre></td></tr></table></figure>
<p>abstract class AbsBase{<br>    abstract fun  method()<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;在kotlin中，被继承的类需要用关键字open声明，表明该类可以被继承，但是抽象类或者抽象函数是不用 open 标注的。但是如果子类要实现抽象类的非抽象函数，需要在抽象类中将其声明为open。</span><br><span class="line"></span><br><span class="line">抽象类有如下的特点:</span><br><span class="line">- 抽象类就是为继承设计的，因此即使不用open关键字修饰，抽象类也是可以被继承的。</span><br><span class="line">- 使用abstract关键字修饰的抽象函数也可以不加open。</span><br><span class="line">- 抽象类中的非抽象方法如果不用open修饰的话，不能被子类覆盖。</span><br></pre></td></tr></table></figure>
<p>abstract class AbsBase{<br>    abstract fun  method()   &#x2F;&#x2F; 如果子类要实现需声明为抽象<br>    open fun method1(){&#x2F;&#x2F;非抽象方法如果要类子类实现，需要声明为open<br>        println(“输出”)<br>    }<br>}</p>
<p>class Child : AbsBase() {<br>    override fun method() {<br>      &#x2F;&#x2F;抽象类的实现<br>    }<br>    override fun method1() {<br>        super.method1()<br>        println(“子类实现”)<br>    }<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># 四.Kotlin接口</span><br><span class="line">### 1.接口的定义</span><br><span class="line">Kotlin接口用interface作为关键字，基本上和Java的接口类似，但是kotlin的接口不仅可以有抽象方法，也可以有已实现的方法。</span><br></pre></td></tr></table></figure>
<p>interface Animal {<br>    val kind: String<br>    val color: String</p>
<pre><code>fun doing()

fun eat() &#123;
    println(&quot;吃骨头&quot;)
&#125;
</code></pre>
<p>}</p>
<p>class Dog : Animal {</p>
<pre><code>override val kind = &quot;小黑狗&quot;
override val color = &quot;黑色的&quot;

override fun doing() &#123;
    println(&quot;正在玩&quot;)
&#125;
</code></pre>
<p>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 2.接口和抽象类区别</span><br><span class="line">-  抽象类可以为属性设置值和getter、setter，而接口不可以。</span><br><span class="line">-  抽象类和接口中都可以有默认的实现方法，但接口中的方法不能有状态，即涉及到属性的值需要到实现类中设置。</span><br><span class="line">-  子类只能继承一个父类，但可以实现多个接口。</span><br><span class="line"></span><br><span class="line">### 3.解决实现多个接口导致的覆盖冲突</span><br><span class="line">Kotlin中可以实现多个接口,可能会出现继承了同一个方法的多个实现。``调用应该使用super&lt;类名&gt;.同名方法的形式调用``，举个例子：</span><br></pre></td></tr></table></figure>
<p>interface A {<br>    fun foo() {<br>        println(“A”)<br>    }<br>    fun bar()<br>}</p>
<p>interface B {<br>    fun foo() {<br>        println(“B”)<br>    }<br>    fun bar() {<br>        println(“bar”)<br>    }<br>}</p>
<p>class C : A {<br>    override fun bar() {<br>        println(“C.bar”)<br>    }<br>}</p>
<p>class D : A, B {<br>    override fun foo() {<br>        super<A>.foo()<br>        super<B>.foo()<br>        println(“D.foo”)<br>    }</p>
<pre><code>override fun bar() &#123;
    super&lt;B&gt;.bar()
&#125;
</code></pre>
<p>}</p>
<p>fun main(args: Array<String>) {<br>    var d &#x3D; D()<br>    d.foo()<br>    d.bar()<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># 五.Kotlin的嵌套类</span><br><span class="line">只要将一个类放在另一个类中定义，这个类就变成了嵌套类，相当于Java中static修饰的静态内部类。</span><br></pre></td></tr></table></figure>
<p>class Outer {                  &#x2F;&#x2F; 外部类<br>    private val value: Int &#x3D; 1</p>
<pre><code>class Nested &#123;             // 嵌套类
    var inValue = 2
    fun nestedMethod() &#123;
        // println(value)       //嵌套类无法直接访问外部类属性
        println(Outer().value) //但可以通过外部类的对象访问，因为有private修饰符，普通类通过对象也无法访问
    &#125;
&#125;

fun outerMethod() &#123;
    // println(inValue)         //外部类无法直接访问嵌套类的属性
    // method()                 //外部类无法直接访问嵌套类的方法
    println(Nested().inValue) //外部类无法通过嵌套类的对象访问private属性，但是可以访问public
&#125;
</code></pre>
<p>}</p>
<p>fun main() {<br>    val demo &#x3D; Outer.Nested().inValue &#x2F;&#x2F; 调用格式：外部类.嵌套类.嵌套类方法&#x2F;属性<br>    println(demo)    &#x2F;&#x2F; &#x3D;&#x3D; 2<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># 六.Kotlin的内部类</span><br><span class="line">内部类是一种特殊的嵌套类，被嵌套到里面的类使用inner关键字修饰，内部类可以拥有对外部类的引用。但是外部类没有内部类的引用。所以内部类可以访问外部类成员属性和成员函数。</span><br><span class="line">内部类的特点:</span><br><span class="line">- 内部类成员可以直接访问外部类的私有数据，因为内部类相当于外部类的成员之一。</span><br><span class="line">- 外部类不能访问内部类的成员，如需访问，需要通过创建内部类对象，通过对象访问内部类成员。</span><br></pre></td></tr></table></figure>
<p>class Outer {<br>    private val value1: Int &#x3D; 1<br>    var value2 &#x3D; “成员属性”</p>
<pre><code>//嵌套内部类
inner class Inner &#123;
    fun innerFun() = value1  // 访问外部类成员
    fun innerTest() &#123;
        val outer = this@Outer //获取外部类的成员变量
        println(&quot;内部类可以引用外部类的成员，bar：$&#123;innerFun()&#125;&quot;)
        println(&quot;内部类可以引用外部类的成员，例如：$&#123;outer.value2&#125;&quot;)
    &#125;
&#125;
</code></pre>
<p>}</p>
<p>fun main(args: Array<String>) {<br>    val demo &#x3D; Outer().Inner().innerFun()<br>    println(demo) &#x2F;&#x2F;   1<br>    Outer().Inner().innerTest()<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">为了消除歧义，要访问来自外部作用域的 this，我们使用this@label，其中 @label是一个 代指 this 来源的标签。</span><br><span class="line"></span><br><span class="line"># 七.Kotlin的匿名内部类</span><br><span class="line">名内部类主要是针对那些获取抽象类或者接口对象而来的。最常见的匿名内部类点击事件：</span><br></pre></td></tr></table></figure>
<p>interface OnClickListener {<br>    fun onClick()<br>}</p>
<p>class View {<br>    fun setClickListener(clickListener: OnClickListener) {</p>
<pre><code>&#125;
</code></pre>
<p>}</p>
<p>fun main(args: Array<String>) {<br>    val view &#x3D; View()<br>    view.setClickListener(object : OnClickListener {<br>        override fun onClick() {</p>
<pre><code>    &#125;
&#125;)
</code></pre>
<p>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># 八.Kotlin的伴生对象 Companion Objects</span><br><span class="line">与Java不同的是，在kotlin中，类是没有显式的定义static方法和static成员变量的。大多数情况下，推荐顶层函数。但是顶层函数不能访问类的private成员，因此需要通过伴生对象的形式间接提供的。</span><br><span class="line">Kotlin语言中使用&quot;companion object&quot;修饰静态方法，可以使用类名.方法名的形式调用，如下：</span><br></pre></td></tr></table></figure>
<p>class Util {<br>    companion object {<br>        fun getCurrentVersion(): String {<br>            return BuildConfig.VERSION_NAME<br>        }<br>    }<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">调用：</span><br></pre></td></tr></table></figure>
<p>var version_name2 &#x3D; Util .getCurrentVersion()</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">伴生对象的特点:</span><br><span class="line">- 每个类最多定义一个伴生对象；</span><br><span class="line">- 伴生对象相当于外部类的对象，可以直接通过外部类名访问伴生对象的成员；</span><br><span class="line">- 由于kotlin取消了static关键字，伴生对象是为了弥补kotlin没有static关键字修饰的静态成员的不足；</span><br><span class="line">- 虽然伴生对象是为其所在对象模拟静态成员，但是伴生对象成员依然属于伴生对象本身的成员，而不属于其外部类的成员。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 九.Kotlin的数据类</span><br><span class="line">在类的声明前添加data关键字，即可将一个类定义成数据类。</span><br></pre></td></tr></table></figure>
<p>data class &lt;类名&gt; &lt;(主构造函数参数列表)&gt; [:继承类和实现接口] [(&#x2F;<em>类体</em>&#x2F;)]</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">主构造函数的参数列表必须使用val或var声明为类属性，而且要求 **至少有一个**，否则无法通过编译。</span><br></pre></td></tr></table></figure>
<p>data class User(val id:Int, val name:String)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">数据类的特点:</span><br><span class="line">- 自动声明与构造函数入参同名的属性字段。</span><br><span class="line">- 自动实现每个属性字段的存取器方法set/get。</span><br><span class="line">- 自动提供equals方法用于比较两个数据对象是否相等。</span><br><span class="line">- 自动提供copy方法允许完整复制某个数据对象。</span><br><span class="line">- 自动提供toString方法。</span><br><span class="line"></span><br><span class="line"># 十.Kotlin的密封类</span><br><span class="line">### 1.密封类的定义</span><br><span class="line">就像用enum类型一样，经常需要在代码中声明一些有限集合，如: 网络请求可能为成功或失败需要先定义一个enum类型 网络请求状态NetStatus，再定义Loading、Success、Error这些网络请求状态。</span><br><span class="line">枚举就是为了控制住你所有要的情况是正确的，而不是用硬编码方式写成字符串“Loading”，“Success”，“Error”。 同样的，密封类（sealed）的目的与enum类似，一个类之所以设计成sealed，就是为了限制类的继承结构，将一个值限制在有限集中的类型中，而不能有任何其他的类型。</span><br><span class="line">密封类用来表示受限的类继承结构（规定了有限个类型，不可以存在其他类型）。是一种同时拥有枚举类 enum 和 普通类 class 特性的类。可以保证我们写出更安全的代码。</span><br><span class="line">密封类与枚举类的区别:</span><br><span class="line">**相同点 ( 类型限制 ) **: 从类型种类角度对比 , 类与枚举类类似 , 枚举类的值的集合是受限制的 , 不能随意扩展 ;</span><br><span class="line">**不同点 ( 对象个数限制 ) **: 从每个类型对象个数对比 , 枚举类的每个类型只能存在一个实例 (每一个枚举值代表一个类的实例), 而密封类的每个类型可以创建无数个实例 ;</span><br><span class="line"></span><br><span class="line">所以可以将密封类看做是枚举的拓展，基于枚举，高于枚举。枚举类型的每个值只允许有一个实例，同时枚举也无法为每个类型添加额外信息，例如，您无法为枚举中的 &quot;Error&quot; 添加相关的 Exception 类型数据。</span><br><span class="line">而且不能控制对象的构建时机，当枚举类构建时 NetStatus 中的各种子类也必须构建好。 虽然也可以使用一个抽象类然后让一些类继承它，这样就可以随意扩展，但这会失去枚举所带来的有限集合的优势。</span><br><span class="line">也可以说成，密封类是包含了一组受限的类集合，因为里面的类都是继承自这个密封类的。但是其和其他继承类（open）的区别在，密封类可以不被此文件外被继承，有效保护代码。</span><br><span class="line">所以说密封类 则同时包含了前面两者的优势 —— 抽象类表示的灵活性和枚举里集合的受限性。</span><br><span class="line">### 2.密封类的使用场景</span><br><span class="line">- 禁止外部继承，对于一些只划分固定类型的数据，保证安全（作用类似于枚举）。</span><br><span class="line">- when遍历密封类的子类时，不用加else语句。(主要解决了when结构需要添加一个默认的else分支的问题)</span><br><span class="line">例如：新建一个 Result.kt</span><br></pre></td></tr></table></figure>
<p>interface NetworkStatus<br>class Loading : NetworkStatus()<br>class Successed : NetworkStatus()</p>
<p>fun getResultMsg(result: NetworkStatus) &#x3D; when(result) {<br>    is Loading -&gt; {}<br>    is Successed -&gt; {}<br>    else -&gt; throw IllegalArgumentException()<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">这里定义了一个 NetworkStatus 接口，然后定义了两个类去实现 NetworkStatus 接口。然后再写一个 getResultMsg() 方法。实际上 Result 的执行结果只能是 Loading 或 Successed，所以里边的 else 永远无法走到，但我们不得不写上，只是为了满足 Kotlin 编译器的语法检查而已。</span><br><span class="line"></span><br><span class="line">密封类就可以帮我们解决这个问题：</span><br></pre></td></tr></table></figure>
<p>sealed class NetworkStatus<br>class Loading : NetworkStatus()<br>class Successed : NetworkStatus()</p>
<p>fun getResultMsg(result: NetworkStatus) &#x3D; when(result) {<br>    is Loading -&gt; {}<br>    is Successed -&gt; {}<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">如果添加了一个新的分支，编译器就会发现有的地方发生了改变，编译器就会提醒处理。</span><br><span class="line">例如:</span><br></pre></td></tr></table></figure>
<p>sealed class NetworkStatus<br>class Loading : NetworkStatus()<br>class Successed : NetworkStatus()<br>class Error(val code: Int, val message: String) : NetworkStatus()</p>
<p>fun getResultMsg(result: NetworkStatus) &#x3D; when(result) {<br>    is Loading -&gt; {}<br>    is Successed -&gt; {}<br>    is Error-&gt;{} &#x2F;&#x2F;强制要求你将每一个子类所对应的条件全部处理,如果不进行处理编译器就会进行报错提醒<br>}</p>
<pre><code>

参考自：
[kotlin官方文档](https://www.kotlincn.net/docs/reference/constructing-collections.html)









</code></pre>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://lxlfpeng.github.io">peng</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://lxlfpeng.github.io/2019/08/08/Kotlin%E6%80%BB%E7%BB%93%E4%B9%8B%E5%9B%9B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/">https://lxlfpeng.github.io/2019/08/08/Kotlin%E6%80%BB%E7%BB%93%E4%B9%8B%E5%9B%9B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://lxlfpeng.github.io" target="_blank">鹏哥的Blog</a>！</span></div></div><div class="tag_share"><div class="post-share"><div class="social-share" data-image="/images/about_avatar.webp" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2019/08/12/%E7%BD%91%E7%BB%9C%E6%8A%93%E5%8C%85%E5%8E%9F%E7%90%86%E5%8F%8AFiddler%E7%9A%84%E4%BD%BF%E7%94%A8/" title="网络抓包原理及Fiddler的使用"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">网络抓包原理及Fiddler的使用</div></div><div class="info-2"><div class="info-item-1"> 一. 什么是抓包?在应用的开发调试中，查看软件实际运行时HTTP&#x2F;HTTPS通信的请求数据和返回数据，从而分析问题的过程就叫做抓包。通常我们说的抓包主要是分为两种：  使用Wireshark抓取传输层的TCP&#x2F;UDP通信包。 使用Fiddler或者Charles抓取应用层的HTTP&#x2F;HTTPS通信包。   在大部分场景下，我们只是需要抓取应用层的HTTP/HTTPS数据包也就是第二种方式。  二....</div></div></div></a><a class="pagination-related" href="/2019/08/05/Apk%E6%9E%84%E5%BB%BA%E6%80%BB%E7%BB%93%E4%B9%8B%E4%BA%8C%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7(Ant%E3%80%81Maven%E3%80%81Gradle)/" title="Apk构建总结之二构建工具(Ant、Maven、Gradle)"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Apk构建总结之二构建工具(Ant、Maven、Gradle)</div></div><div class="info-2"><div class="info-item-1">一. 构建工具1.什么是构建工具？在进行编程操作的时候，我们经常会遇到很多与编程无关的项目管理工作。如下载依赖、编译源码、单元测试、项目部署等操作。一般的，小型项目我们可以手动实现这些操作，然而大型项目这些工作则相对复杂。所以我们需要用到构建工具。构建工具是帮助我们实现一系列项目管理、测试和部署操作的工具。构建工具可以把源代码生成可执行应用程序的过程自动化的程序（例如Android app生成apk）。构建工具包括编译、连接跟把代码打包成可用的或可执行的形式。 总的来说构建的自动化是编写或使一大部分任务自动执行的一个动作，而这些任务则是软件开发者的日常，像是：  下载依赖。 将源代码编译成二进制代码。 打包生成的二进制代码。 进行单元测试。 部署到生产系统。  2.为什么要使用构建工具？比如我们要写一个Java程序，一般的步骤也就是编译，测试，打包。这个构建的过程，如果文件比较少，我们可以手动使用java, javac,...</div></div></div></a></nav><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="giscus-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/images/about_avatar.webp" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">peng</div><div class="author-info-description">过往不恋 未来不迎 当下不负</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">127</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">59</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">24</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/lxlfpeng"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/lxlfpeng" target="_blank" title="Github"><i class="fab fa-github" style="color: #4a7dbe;"></i></a><a class="social-icon" href="mailto:565289282@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎来到我的博客!</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80-Kotlin%E7%B1%BB%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="toc-number">1.</span> <span class="toc-text">一.Kotlin类的创建</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%B1%BB%E7%9A%84%E5%A3%B0%E6%98%8E"><span class="toc-number">1.0.1.</span> <span class="toc-text">1.类的声明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">1.0.2.</span> <span class="toc-text">2. 类的构造函数</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E4%B8%BB%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">1.0.2.0.1.</span> <span class="toc-text">(1.)主构造函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E6%AC%A1%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">1.0.2.0.2.</span> <span class="toc-text">(2.)次构造函数</span></a></li></ol></li></ol></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer" style="background: linear-gradient(20deg, #0062be, #925696, #cc426e, #fb0347);"><div id="footer-wrap"><div class="copyright">&copy;2015 - 2025 By peng</div><div class="footer_custom_text"> <a target="_blank" rel="nofollow noopener"><span>千里之行</span></a> <i class="iconfont icon-love"></i> <a target="_blank" rel="nofollow noopener"><span>始于足下</span></a> </div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.isShuoshuo
  const option = null

  const getGiscusTheme = theme => theme === 'dark' ? 'dark' : 'light'

  const createScriptElement = config => {
    const ele = document.createElement('script')
    Object.entries(config).forEach(([key, value]) => {
      ele.setAttribute(key, value)
    })
    return ele
  }

  const loadGiscus = (el = document, key) => {
    const mappingConfig = isShuoshuo
      ? { 'data-mapping': 'specific', 'data-term': key }
      : { 'data-mapping': (option && option['data-mapping']) || 'pathname' }

    const giscusConfig = {
      src: 'https://giscus.app/client.js',
      'data-repo': 'lxlfpeng/blog_comments',
      'data-repo-id': 'R_kgDONYoexA',
      'data-category-id': 'DIC_kwDONYoexM4Ck4JQ',
      'data-theme': getGiscusTheme(document.documentElement.getAttribute('data-theme')),
      'data-reactions-enabled': '1',
      crossorigin: 'anonymous',
      async: true,
      ...option,
      ...mappingConfig
    }

    const scriptElement = createScriptElement(giscusConfig)

    el.querySelector('#giscus-wrap').appendChild(scriptElement)

    if (isShuoshuo) {
      window.shuoshuoComment.destroyGiscus = () => {
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }
  }

  const changeGiscusTheme = theme => {
    const iframe = document.querySelector('#giscus-wrap iframe')
    if (iframe) {
      const message = {
        giscus: {
          setConfig: {
            theme: getGiscusTheme(theme)
          }
        }
      }
      iframe.contentWindow.postMessage(message, 'https://giscus.app')
    }
  }

  btf.addGlobalFn('themeChange', changeGiscusTheme, 'giscus')

  if (isShuoshuo) {
    'Giscus' === 'Giscus'
      ? window.shuoshuoComment = { loadComment: loadGiscus }
      : window.loadOtherComment = loadGiscus
    return
  }

  if ('Giscus' === 'Giscus' || !false) {
    if (false) btf.loadComment(document.getElementById('giscus-wrap'), loadGiscus)
    else loadGiscus()
  } else {
    window.loadOtherComment = loadGiscus
  }
})()</script></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="false"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>