<!DOCTYPE html><html lang="zh-CN" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Kotlin总结之三函数及函数式编程 | 鹏哥的Blog</title><meta name="author" content="peng"><meta name="copyright" content="peng"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#0d0d0d"><meta name="description" content="一.Kotlin中的函数函数是执行特定任务的一段代码，程序通过将一段代码定义成函数，并为该函数指定一个函数名，就可以在需要的时候多次调用这段代码，代码复用的重要手段就是通过函数实现的。 1.函数声明定义格式为： 123权限修饰符 fun 函数名(参数名 ：类型,...) : 返回值&#123;  &#x2F;&#x2F;函数执行体&#125; 函数从参数角度，可以分为有参函数以及无参函数；从返回值角度，可以分为有返回">
<meta property="og:type" content="article">
<meta property="og:title" content="Kotlin总结之三函数及函数式编程">
<meta property="og:url" content="https://lxlfpeng.github.io/2019/07/26/Kotlin%E6%80%BB%E7%BB%93%E4%B9%8B%E4%B8%89%E5%87%BD%E6%95%B0%E5%8F%8A%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/index.html">
<meta property="og:site_name" content="鹏哥的Blog">
<meta property="og:description" content="一.Kotlin中的函数函数是执行特定任务的一段代码，程序通过将一段代码定义成函数，并为该函数指定一个函数名，就可以在需要的时候多次调用这段代码，代码复用的重要手段就是通过函数实现的。 1.函数声明定义格式为： 123权限修饰符 fun 函数名(参数名 ：类型,...) : 返回值&#123;  &#x2F;&#x2F;函数执行体&#125; 函数从参数角度，可以分为有参函数以及无参函数；从返回值角度，可以分为有返回">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://lxlfpeng.github.io/images/about_avatar.webp">
<meta property="article:published_time" content="2019-07-25T16:00:00.000Z">
<meta property="article:modified_time" content="2025-04-12T15:02:01.844Z">
<meta property="article:author" content="peng">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://lxlfpeng.github.io/images/about_avatar.webp"><link rel="shortcut icon" href="/images/favicon.webp"><link rel="canonical" href="https://lxlfpeng.github.io/2019/07/26/Kotlin%E6%80%BB%E7%BB%93%E4%B9%8B%E4%B8%89%E5%87%BD%E6%95%B0%E5%8F%8A%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Kotlin总结之三函数及函数式编程',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  isShuoshuo: false
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/images/about_avatar.webp" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">127</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">59</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">24</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/categories"><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background: linear-gradient(20deg, #0062be, #925696, #cc426e, #fb0347);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src="/images/nav_logo.webp" alt="Logo"><span class="site-name">鹏哥的Blog</span></a><a class="nav-page-title" href="/"><span class="site-name">Kotlin总结之三函数及函数式编程</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/categories"><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Kotlin总结之三函数及函数式编程</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2019-07-25T16:00:00.000Z" title="发表于 2019-07-26 00:00:00">2019-07-26</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Kotlin%E8%AF%AD%E8%A8%80/">Kotlin语言</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">10.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>38分钟</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="一-Kotlin中的函数"><a href="#一-Kotlin中的函数" class="headerlink" title="一.Kotlin中的函数"></a>一.Kotlin中的函数</h1><p>函数是执行特定任务的一段代码，程序通过将一段代码定义成函数，并为该函数指定一个函数名，就可以在需要的时候多次调用这段代码，代码复用的重要手段就是通过函数实现的。</p>
<h3 id="1-函数声明"><a href="#1-函数声明" class="headerlink" title="1.函数声明"></a>1.函数声明</h3><p>定义格式为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">权限修饰符 fun 函数名(参数名 ：类型,...) : 返回值&#123;</span><br><span class="line">  //函数执行体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数从参数角度，可以分为<code>有参函数以及无参函数</code>；从返回值角度，可以分为有<code>返回值的函数以及没有返回值的函数</code>。那么函数一共就有4种类型，<code>无参无返回值、无参有返回值、有参无返回值、有参有返回值</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">//无参无返回值</span><br><span class="line">fun test() &#123;</span><br><span class="line">    println(&quot;test&quot;)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">//无参有返回值</span><br><span class="line">fun test(): String &#123;</span><br><span class="line">    return&quot;test&quot;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">//有参无返回值</span><br><span class="line">fun test(content: String) &#123;</span><br><span class="line">   println(content)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">//有参有返回值</span><br><span class="line">fun test(content: String): String &#123;</span><br><span class="line">    retur ncontent</span><br><span class="line">&#125;</span><br><span class="line">当然，没有返回值的函数，也可以明确指定返回值类型为Unit。</span><br><span class="line">//无参无返回值</span><br><span class="line">fun test():Unit&#123;</span><br><span class="line">    println(&quot;outerFun&quot;)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">//有参无返回值</span><br><span class="line">fun test(content: String) :Unit &#123;</span><br><span class="line">    println(content)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>上面的例子中没有可见性修饰符，那是因为Kotlin中<code>默认为public可见性修饰符</code>。</li>
<li>()圆括号必须存在，即使是没有参数的情况下。</li>
<li>{}大括号必须存在，即使是没有函数体的时候，不过在Kotlin中有一个特例就是，函数具备返回值的时候，如果只用一个表达式就可以完成这个函数，则可以使用单表达式函数（可以不加{}）。</li>
<li>在函数没有返回值时可以省略Unit。</li>
</ul>
<h3 id="2-单表达式函数"><a href="#2-单表达式函数" class="headerlink" title="2.单表达式函数"></a>2.单表达式函数</h3><p>函数只是返回单个表达式，可以省略花括号并在等号后指定函数体即可。这种方式被称为单表达式函数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fun main(args: Array&lt;String&gt;) &#123;</span><br><span class="line">    println(area(2.0, 3.0))</span><br><span class="line">&#125;</span><br><span class="line">fun setValue(x: Int, y: Int) = x + y</span><br></pre></td></tr></table></figure>

<h3 id="3-顶层函数"><a href="#3-顶层函数" class="headerlink" title="3.顶层函数"></a>3.顶层函数</h3><p>不同于Java中函数只能定义在每个类里面，kotlin可以在文件任意位置处定义函数，这种函数称为<code>顶层函数</code>。</p>
<blockquote>
<p> Java作为一门面对对象的语言，Java中，所有的代码都是依托于类而存在，函数作为类的方法，属性作为类的属性。但实际上项目中总有一些函数不属于任何一个类，最终产生了一些类不包含任何状态或者实例函数，仅仅是作为一堆静态函数的容器。在JDK中，最明显的例子应该就是Collections了，还有你的项目中是不是有很多以Util作为后缀的类？<br>在Kotlin中，根本不需要去创建这些无意义的类，你可以把这些函数直接放到代码文件的顶层，不用从属于任何类。因此可以再任何类中调用。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 文件名 join.kt</span><br><span class="line">package strings //包名</span><br><span class="line">fun joinToString() : String &#123;...&#125;</span><br><span class="line"></span><br><span class="line">// kotlin调用</span><br><span class="line">import strings.JoinKt;//导入该顶层函数</span><br><span class="line">fun main(args: Array&lt;String&gt;)&#123;</span><br><span class="line">    joinToString()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Java调用</span><br><span class="line">import strings.JoinKt;</span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        JoinKt.joinToSting()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译完成后顶层函数会成为文件类下的<code>静态函数</code>，比如在文件名是join.kt下定义的joinToString函数可以通过JoinKt.joinToSting调用，其中JoinKt是编译后的类名。</p>
<ul>
<li>在Kotlin中，顶层函数属于包内成员，包内可以直接使用，包外只需要import该顶层函数，即可使用。</li>
<li>在Java中，类还是必须要存在的，所以编译器将JoinKt.kt文件里的代码放在了一个JoinKt的类中，然后把定义的Kotlin的函数作为静态方法放在其中，所以在Java中是先通过mport导入这个类，然后通过<code>类名.方法名</code>来调用。</li>
</ul>
<p>如果觉得Kotlin自动生成的这个类名不好，那你可以通过@file:JvmName注解来自定义类名:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@file:JvmName(&quot;StrUtil&quot;)//自定义生成顶层函数的类名</span><br><span class="line">package strings</span><br><span class="line"></span><br><span class="line">fun joinToString() : String &#123;...&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-顶层属性"><a href="#4-顶层属性" class="headerlink" title="4.顶层属性"></a>4.顶层属性</h3><p>和函数一样，属性也可以放到文件的顶层，不依附于类。从Java的角度来看就是静态属性，而且由于没有了类的存在，这种属性用到的<code>机会也不多</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//kotlin文件名为ApiConfigKt</span><br><span class="line">package config</span><br><span class="line"></span><br><span class="line">var count = 0</span><br><span class="line">val REQUEST_URL = &quot;http://localhost:8080/&quot;</span><br><span class="line">const val BASE_URL = &quot;http://www.xxx.com/&quot;</span><br></pre></td></tr></table></figure>
<p>在kotlin中使用:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import config.count</span><br><span class="line"></span><br><span class="line">fun main(args: Array&lt;String&gt;)&#123;</span><br><span class="line">    //使用var变量</span><br><span class="line">    count++</span><br><span class="line">    //使用val常量</span><br><span class="line">    config.REQUEST_URL</span><br><span class="line">    //使用const val常量</span><br><span class="line">    config.BASE_URL</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在Java中使用:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import config.ApiConfigKt;</span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //使用var变量</span><br><span class="line">        ApiConfigKt.setCount(12);</span><br><span class="line">        System.out.println(ApiConfigKt.getCount());</span><br><span class="line">        //使用val常量</span><br><span class="line">        System.out.println(ApiConfigKt.getREQUEST_URL());</span><br><span class="line">        //使用const val常量</span><br><span class="line">        System.out.println(ApiConfigKt.BASE_URL);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要注意的是顶层函数和其他任意属性一样，默认是通过访问器暴露给Java使用的（也就是通过getter和setter方法）。为了方便使用，如果你想要把一个常量以public static final 的属性暴露给Java，可以用const 来修饰属性：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const val TAG = &quot;tag&quot;</span><br><span class="line">这样就等同与Java的：</span><br><span class="line">public static final String TAG = &quot;tag&quot;</span><br></pre></td></tr></table></figure>
<p>Kotlin中通过使用顶层函数和顶层属性帮助我们消除了Java中常见的静态工具类，使我们的代码更加整洁。</p>
<h1 id="二-Kotlin中的函数参数"><a href="#二-Kotlin中的函数参数" class="headerlink" title="二.Kotlin中的函数参数"></a>二.Kotlin中的函数参数</h1><h3 id="1-函数的默认参数"><a href="#1-函数的默认参数" class="headerlink" title="1.函数的默认参数"></a>1.函数的默认参数</h3><p>对于默认参数，即使指一个函数中的参数具有默认值，这样在使用该函数的时候，可以省略一部分参数，可以减少函数的重载。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 默认参数的函数使用</span><br><span class="line">test()</span><br><span class="line">test(1, 10f)</span><br><span class="line">test(1, 10f, true)</span><br><span class="line">fun test(numA: Int = 1, numB: Float = 2f, numC: Boolean = false) &#123;</span><br><span class="line">      println(&quot;numA  =  $numA \t numB = $numB \t numC = $numC&quot;)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-函数的具名参数"><a href="#2-函数的具名参数" class="headerlink" title="2.函数的具名参数"></a>2.函数的具名参数</h3><p>所为具名参数，是在传递参数的时候，指定参数的具体名称。这样做的好处就是可以不必按照参数的顺序去传值 ，调用函数时，在函数参数中给参数赋值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">test(numA = 1, numB = 10f, numC = true)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在kotlin中调用java方法是不能使用具名参数语法，因为jva字节码并不总是会保留参数名信息，如果一个默认参数位于其他无默认值的参数前面，那么默认值只能通过在调用函数时使用具名参数的方式来使用。</p>
</blockquote>
<h3 id="3-函数可变长度的参数"><a href="#3-函数可变长度的参数" class="headerlink" title="3.函数可变长度的参数"></a>3.函数可变长度的参数</h3><p>java中使用String…arg来表示长度不确定的参数，kotlin使用vararg关键字修饰变量，表示该类型参数的数量可变。通常因该把它放在参数列表的最后方。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">add(&quot;xixi&quot;, &quot;haha&quot;, &quot;heihei&quot;)</span><br><span class="line"></span><br><span class="line">fun add(vararg arag: String) &#123;</span><br><span class="line">  for (x in arag) &#123;</span><br><span class="line">    Log.d(&quot;Tag&quot;, x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="三-一等公民函数"><a href="#三-一等公民函数" class="headerlink" title="三.一等公民函数"></a>三.一等公民函数</h1><h3 id="1-什么是一等公民函数"><a href="#1-什么是一等公民函数" class="headerlink" title="1.什么是一等公民函数"></a>1.什么是一等公民函数</h3><p>在程序世界里，有且不仅有这么几种权力：<code>创建，赋值，传递</code>。在JAVA中这些权力，<code>object 都具备，function 都不具备</code>。object 可以通过参数传递到另一个对象里，从而两个对象可以互相通信。函数却不行，<code>两个函数想要通信，必须以对象为介质</code>。<br>以 Java 举个例子：函数a，想要调用函数b。虽然a并不关心函数b是从哪儿来的，只要函数b可以完成这个特定的功能即可。但是在 Java 的世界里函数必须要依附在一个对象上，所以函数a必须依附在对象A上，函数b必须依附在对象B上，函数a必须通过一个对象才能找到函数b，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class A &#123;</span><br><span class="line">	public void a(Object o) &#123;</span><br><span class="line">		System.out.println(&quot;a is invoked&quot;);</span><br><span class="line">		o.getClass().getMethod(&quot;b&quot;).invoke(o);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class B &#123;</span><br><span class="line">	public void b() &#123;</span><br><span class="line">		System.out.println(&quot;b is invoked&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>函数b可以这样传递给函数a：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new A().a(new B());</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a is invoked</span><br><span class="line">b is invoked</span><br></pre></td></tr></table></figure>
<blockquote>
<p>通过这个简单的例子，可以看出，非一等公民的函数生存条件有多么的恶劣，通讯的阻力有多大。 在函数是一等公民的世界里，函数a可以不再依附于对象A而单独存在，函数a可以直接与函数b交流，不再需要通过对象才能找到函数b。</p>
</blockquote>
<p>函数是<code>&quot;一等公民&quot;</code>特点指的就是函数与变量、对象类型一样，处于平等地位。一等公民函数有三个主要的特点。</p>
<ul>
<li>函数可以赋值给一个变量。</li>
<li>函数可以作为参数传入另一个函数。</li>
<li>函数可以作为别的函数的返回值。</li>
</ul>
<h3 id="2-一等公民函数可以赋值给一个变量"><a href="#2-一等公民函数可以赋值给一个变量" class="headerlink" title="2.一等公民函数可以赋值给一个变量"></a>2.一等公民函数可以赋值给一个变量</h3><p>既然函数可以赋值给一个变量，那么这个变量的类型就是函数类型。Kotlin 中每一个函数都有一个类型，称为 “函数类型”，函数类型是一种数据类型，它与 Int、Boolean等数据类型 在使用场景上没有区别。“::” 可以取出函数的地址引用。<br>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 计算一个矩形面积  (Double, Double) -&gt; Double</span><br><span class="line">fun rectangleArea(width: Double, height: Double): Double &#123;</span><br><span class="line">    return width * height</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun main(args: Array&lt;String&gt;) &#123;</span><br><span class="line">   //通过::取出rectangleArea函数的地址 将函数rectangleArea赋值给一个变量areaFunction，此时areaFunction变量的类型为(Double, Double) -&gt; Double</span><br><span class="line">   val areaFunction: (Double, Double) -&gt; Double = ::rectangleArea</span><br><span class="line">   val area = areaFunction(50.0, 40.0) //靠变量来调用函数</span><br><span class="line">   println(area)                       // 2000.0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一些相对简单的函数类型：</p>
<ul>
<li>() -&gt; Unit:无参、无返回值的函数类型(Unit 返回类型不可省略)。</li>
<li>(T) -&gt; Unit:接收T类型参数、无返回值的函数类型。</li>
<li>(T,A) -&gt; Unit:接收T类型和A类型参数、无返回值的函数类型(多个参数同理)。</li>
<li>(T) -&gt; R:接收T类型参数，并且返回R类型值的函数类型。</li>
<li>(T,A) -&gt; R:接收T类型和A类型参数、并且返回R类型值的函数类型(多个参数同理)。</li>
</ul>
<h3 id="3-一等公民函数可以作为参数传递"><a href="#3-一等公民函数可以作为参数传递" class="headerlink" title="3.一等公民函数可以作为参数传递"></a>3.一等公民函数可以作为参数传递</h3><p>函数可以作为参数进行传递，如果函数可以作为参数进行传递，那么就可以将不同函数进行组合，提高代码的复用，代码会更简洁，这部分就可以引出高阶函数，类似f(g(x))的形式。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// 计算一个矩形面积  (Double, Double) -&gt; Double</span><br><span class="line">fun rectangleArea(width: Double, height: Double): Double &#123;</span><br><span class="line">    return width * height</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//计算一个三角形面积</span><br><span class="line">fun triangleArea(bottom: Double, height: Double): Double &#123;</span><br><span class="line">    return (bottom * height) / 2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//获取面积</span><br><span class="line">fun getAreaByFun(funName: (Double, Double) -&gt; Double, a: Double, b: Double): Double &#123;</span><br><span class="line">    return funName(a, b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun main(args: Array&lt;String&gt;) &#123;</span><br><span class="line">    //参数为函数,传入不同的函数类型</span><br><span class="line">    var triangleArea: Double = getAreaByFun(::triangleArea, 10.0, 15.0)</span><br><span class="line">    print(triangleArea)</span><br><span class="line">    var rectangleArea = getAreaByFun(::rectangleArea, 10.0, 15.0)</span><br><span class="line">    print(rectangleArea)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-一等公民函数可以作为别的函数的返回值"><a href="#4-一等公民函数可以作为别的函数的返回值" class="headerlink" title="4.一等公民函数可以作为别的函数的返回值"></a>4.一等公民函数可以作为别的函数的返回值</h3><p>函数可以作为返回值，那么函数内应该可以定义函数，并且函数可以返回函数内定义的函数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//获取面积，返回值是一个函数的类型</span><br><span class="line">fun getArea(type: String): (Double, Double) -&gt; Double &#123;</span><br><span class="line">    val resultFunction: (Double, Double) -&gt; Double</span><br><span class="line">    if (type == &quot;rectangle&quot;) &#123;</span><br><span class="line">        resultFunction = ::rectangleArea</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        resultFunction = ::triangleArea</span><br><span class="line">    &#125;</span><br><span class="line">    return resultFunction</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun main(args: Array&lt;String&gt;) &#123;</span><br><span class="line">    //调用函数</span><br><span class="line">    val rectangleAreaFun: (Double, Double) -&gt; Double = getArea(&quot;rectangle&quot;)</span><br><span class="line">    println(&quot;底 10 高 15，计算三角形面积：$&#123;rectangleAreaFun(10.0, 15.0)&#125;&quot;)</span><br><span class="line">    //调用函数</span><br><span class="line">    val triangleAreaFun: (Double, Double) -&gt; Double = getArea(&quot;triangle&quot;)</span><br><span class="line">    println(&quot;底 10 高 15，计算长方形面积：$&#123;triangleAreaFun(10.0, 15.0)&#125;&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="四-函数式编程"><a href="#四-函数式编程" class="headerlink" title="四.函数式编程"></a>四.函数式编程</h1><p>函数是“一等公民”是函数式编程的核心概念。</p>
<ul>
<li>使用表达式，不用语句：函数式编程关心输入和输出，即参数和返回值。在程序中使用表达式可以有返回值，而语句没有。例如控制结构中的 if 和 when 结构都属于表达式。</li>
<li>高阶函数：函数式编程支持高阶函数，所谓的高阶函数就是一个函数可以作为另一个函数的参数或返回值。</li>
<li>无副作用：是指函数执行过程会返回同一个结果，不会修改外部变量，这就是“纯函数”，同样的输入参数一定会有同样的输出结果。<blockquote>
<p>Kotlin 语言支持函数式编程，提供了函数类型、高阶函数 和 Lambda 表达式。</p>
</blockquote>
</li>
</ul>
<h1 id="五-Kotlin中的匿名函数"><a href="#五-Kotlin中的匿名函数" class="headerlink" title="五.Kotlin中的匿名函数"></a>五.Kotlin中的匿名函数</h1><p>匿名函数就是没有名字的函数对象(注意匿名函数不是函数，而是函数类型的对象)，大多数情况下定义的函数都是具名函数(有名字的函数)。匿名函数就是只定义参数列表、返回值类型和函数体，把一个匿名函数赋给一个没有定义函数体的函数对象。<br>那这种没有匿名函数我们怎么调用呢？答案是无法直接调用。 匿名函数可以赋值给一个变量，或者当作实参直接传递给一个函数类型的形参。<br>具名函数如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fun sum(arg1 : Int,arg2 : Int): Int&#123;</span><br><span class="line">  return arg1 + arg2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数的名字就叫sum。<br>那匿名函数定义:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fun(arg1 : Int, arg2 : Int) : Int&#123;</span><br><span class="line">    return arg1 + arg2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样写还不行，因为不知道怎么去调用，所以我们需要付给一个引用，用来保存它，然后在需要使用的时候调用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">val sum = fun(arg1 : Int, arg2 : Int) : Int&#123;</span><br><span class="line">    return arg1 + arg2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="六-Kotlin中的lambda表达式"><a href="#六-Kotlin中的lambda表达式" class="headerlink" title="六.Kotlin中的lambda表达式"></a>六.Kotlin中的lambda表达式</h1><h3 id="1-定义"><a href="#1-定义" class="headerlink" title="1.定义"></a>1.定义</h3><p>Lambda 表达式的本质其实就是匿名函数。而函数其实就是功能（function），匿名函数，就是匿名的功能代码了。Lambda表达式才是与高阶函数的绝配，平时我们给高阶函数中的函数类型参数传递值时，一般都会选择传入Lambda表达式，因为它足够简洁与强大。<br>创建一个函数类型的对象（函数字面量）有三种方式：</p>
<ul>
<li>函数引用，::函数名，表示函数引用，会拿到一个 函数的对象 ；注意不是函数本身。</li>
<li>匿名函数，没有名字的函数类型的对象。</li>
<li>lambda是匿名函数的表现形式也就同上。</li>
</ul>
<p>通常这样写匿名函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">val addFun = fun(x: Int, y: Int): Int &#123;</span><br><span class="line">    return x + y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用lambda表达式可以简化：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//lambda表达式</span><br><span class="line">val addLambda = &#123; x: Int, y: Int -&gt; x * y &#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-lambda表达式语法"><a href="#2-lambda表达式语法" class="headerlink" title="2.lambda表达式语法"></a>2.lambda表达式语法</h3><ul>
<li>总是被大括号扩着</li>
<li>其参数（如果存在）在-&gt;之前声明（参数类型可以省略）</li>
<li>函数体（如果存在）在-&gt;后面<br><img src="/images/c052b33a825ab971d91dc7e21d4f9d7f.webp"></li>
</ul>
<ol>
<li>无参数的情况<br><code>val/var 变量名 = &#123; 操作代码 &#125;</code><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val sum = &#123; &#125;</span><br></pre></td></tr></table></figure></li>
<li>有参数的情况<br><code>val/var 变量名：(参数类型，参数类型，...)-&gt;返回值类型 = (参数1，参数2，...-&gt;操作参数的代码)</code><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val sum:(Int,Int)-&gt;Int = &#123;a,b-&gt;a+b&#125;</span><br></pre></td></tr></table></figure>
可等价于(此种写法：即表达式的返回值类型会根据操作代码自推导出来)<br><code>val/var 变量名 = &#123;参数1：类型，参数2：类型...-&gt;操作代码&#125;</code><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val sum=&#123;a:Int,b:Int -&gt;a+b&#125;</span><br></pre></td></tr></table></figure>
3.lambda表达式作为函数中的参数的时候<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fun sum(a:Int,参数名：(参数1：类型，参数2：类型...)-&gt;表达式返回类型)&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="3-lambda表达式简化语法"><a href="#3-lambda表达式简化语法" class="headerlink" title="3.lambda表达式简化语法"></a>3.lambda表达式简化语法</h3><ol>
<li>当 lambda 表达式只接受一个参数时，该参数可以省略，使用时用 it 来表示该参数:<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">add(&quot;xxx&quot;, &#123; s -&gt; s + &quot;xxx&quot; &#125;)</span><br><span class="line">//等同于</span><br><span class="line">add(&quot;xxx&quot;, &#123; it + &quot;xxx&quot; &#125;)</span><br></pre></td></tr></table></figure></li>
<li>当函数最后一个参数为函数时，该函数可以写在 () 外，并用 {} 包裹<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">add(&quot;xxx&quot;, &#123; s -&gt; s + &quot;xxx&quot; &#125;)</span><br><span class="line">//等同于</span><br><span class="line">add(&quot;xxx&quot;) &#123; s -&gt; s + &quot;xxx&quot; &#125;</span><br><span class="line">//等同于</span><br><span class="line">foo(&quot;xxx&quot;) &#123; it + &quot;xxx&quot; &#125;</span><br></pre></td></tr></table></figure></li>
<li>当函数只有一个参数，且该参数为函数时，可以直接省去 ()<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">foo(&#123; s -&gt; s + &quot;xxx&quot; &#125;) </span><br><span class="line">//等同于</span><br><span class="line">foo &#123; s -&gt; s + &quot;xxx&quot; &#125;</span><br></pre></td></tr></table></figure></li>
<li>当参数在函数体中没有引用时，可以将其设为 _，若此时只有一个参数（且该参数没有被引用），则可以直接省略该参数；若有两个或以上的参数，就算全部都没有被引用，也不可以省略<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">foo(&#123; s -&gt; print(&quot;xxx&quot;) &#125;)</span><br><span class="line">//等同于</span><br><span class="line">foo(&#123; _ -&gt; print(&quot;xxx&quot;) &#125;)</span><br><span class="line">//等同于</span><br><span class="line">foo(&#123; print(&quot;xxx&quot;) &#125;)</span><br><span class="line">//等同于</span><br><span class="line">foo &#123; print(&quot;xxx&quot;) &#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="4-lambda表达式的返回值"><a href="#4-lambda表达式的返回值" class="headerlink" title="4.lambda表达式的返回值"></a>4.lambda表达式的返回值</h3><p>lambda表达式返回值总是返回函数体内部最后一行表达式的值。 lambda表达式语法缺少指定函数的返回类型的能力，因此Lambda表达式不能指定返回值类型，当需要显式指定返回类型时，可以使用匿名函数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fun(x: Int, y: Int): Int &#123;</span><br><span class="line">    return x + y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-在android使用Lambda的例子"><a href="#5-在android使用Lambda的例子" class="headerlink" title="5.在android使用Lambda的例子"></a>5.在android使用Lambda的例子</h3><p>Java8 开始支持 Lambda 表达式 Java 在使用 单 抽象方法的接口时，允许使用 lambda 表达式 在 Kotlin 中就不支持这么写了，因为没有必要（可以直接传函数对象）但在 Kotlin 和 Java 做交互的时候可以这么写。 首先来通过一个例子直观感受一下lambda表达式。Android开发中经常会给一个Button设置OnClickListener。<br>比如我们需要让按钮点击后消失，平时我们可能是这样写的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//传统Java式写法</span><br><span class="line">mButton.setOnClickListener(new View.OnClickListener() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void onClick(View view) &#123;</span><br><span class="line">            view.setVisibility(View.GONE);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
<p>而在Kotlin中，使用函数式语法，我们可以这样写：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//Kotlin函数式写法</span><br><span class="line">mButton.setOnClickListener &#123; </span><br><span class="line">    it.visibility = View.GONE</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>直观来讲，似乎跟我们平时的写法差别有点大，比如，函数调用的小括号不见了，匿名内部类直接被一个函数体取代了，View参数不见了，分号也消失了，还有那个it是什么……其实，就像数学公式推导一样，精简的写法也是通过一步一步简化来的。下面就让我们来看一下代码的“推导过程”：</p>
<ol>
<li><p>首先，代码段1转换为Kotlin代码，并替换为函数式写法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mButton.setOnClickListener(&#123; view: View -&gt;</span><br><span class="line">    view.visibility = View.GONE</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>这段代码非常清晰，花括号包裹的是一段lambda表达式，可以把它作为实参传递给函数，这一步把匿名内部类省略掉了；另外也干掉了分号，因为在Kotlin中行末尾的分号可以省略；最后还省略了set方法，在Kotlin中，会默认把对属性的直接访问转换成get&#x2F;set方法调用。</p>
</li>
<li><p>然后，根据Kotlin的语法约定，如果lambda表达式是函数调用的最后一个实参，就可以把它挪到小括号外面：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mButton.setOnClickListener() &#123; view: View -&gt;</span><br><span class="line">    view.visibility = View.GONE</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>当lambda是函数的唯一实参，就可以去掉空的小括号对：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mButton.setOnClickListener &#123; view: View -&gt;</span><br><span class="line">    view.visibility = View.GONE</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>如果lambda的参数的类型可以被编译器推导出来，就可以省略它：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mButton.setOnClickListener &#123; view -&gt;</span><br><span class="line">    view.visibility = View.GONE</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>最后，如果这个lambda只有一个参数，并且这个参数的类型可以被推断出来（也就是同时满足3和4），那么这个参数也可以省略掉。代码中引用这个参数的地方可以通过编译器自动生成的名称it来替代：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mButton.setOnClickListener &#123;</span><br><span class="line">    it.visibility = View.GONE</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>经过上述5个步骤，就得到了最简洁、最清晰的代码段。</p>
</li>
</ol>
<h1 id="七-Kotlin中的闭包"><a href="#七-Kotlin中的闭包" class="headerlink" title="七.Kotlin中的闭包"></a>七.Kotlin中的闭包</h1><h3 id="1-闭包的定义"><a href="#1-闭包的定义" class="headerlink" title="1.闭包的定义"></a>1.闭包的定义</h3><p>程序的变量分为全局变量和局部变量，全局变量，顾名思义，其作用域是当前文件甚至文件外的所有地方；而局部变量，我们只能再其有限的作用域里获取。 那么，如何在外部调用局部变量呢？答案就是——闭包，与此给闭包下个定义：<br>闭包就是能够读取其他函数内部变量的函数。即是函数中包含函数，这里的函数我们可以包含（Lambda表达式，匿名函数，局部函数，对象表达式）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fun test1()&#123;</span><br><span class="line">     fun test2()&#123;</span><br><span class="line">      </span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-闭包使用"><a href="#2-闭包使用" class="headerlink" title="2.闭包使用"></a>2.闭包使用</h3><p>我们来看一个闭包的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">fun returnFun(): () -&gt; Int &#123;</span><br><span class="line">    var count = 0</span><br><span class="line">    return &#123; count++ &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun main() &#123;</span><br><span class="line">    val function = returnFun()</span><br><span class="line">    val function2 = returnFun()</span><br><span class="line">    println(function()) // 0</span><br><span class="line">    println(function()) // 1</span><br><span class="line">    println(function()) // 2</span><br><span class="line"></span><br><span class="line">    println(function2()) // 0</span><br><span class="line">    println(function2()) // 1</span><br><span class="line">    println(function2()) // 2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>returnFun返回了一个函数，这个函数没有入参，返回值是Int。我们可以用变量接收它，还可以调用它。function和function2分别是创建的两个函数实例。 每调用一次function()，count都会加一，说明count 被function持有了而且可以被修改。而function2和function的count是独立的，不是共享的。<br>通过 jadx 反编译可以看到：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public final class ClosureKt &#123;</span><br><span class="line">    @NotNull</span><br><span class="line">    public static final Function0&lt;Integer&gt; returnFun() &#123;</span><br><span class="line">        IntRef intRef = new IntRef();</span><br><span class="line">        intRef.element = 0;</span><br><span class="line">        return (Function0) new 1&lt;&gt;(intRef);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static final void main() &#123;</span><br><span class="line">        Function0 function = returnFun();</span><br><span class="line">        Function0 function2 = returnFun();</span><br><span class="line">        System.out.println(((Number) function.invoke()).intValue());</span><br><span class="line">        System.out.println(((Number) function.invoke()).intValue());</span><br><span class="line">        System.out.println(((Number) function2.invoke()).intValue());</span><br><span class="line">        System.out.println(((Number) function2.invoke()).intValue());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>被闭包引用的 int 局部变量，会被封装成 IntRef 这个类。这个 IntRef 里面保存着 int 变量，原函数和闭包都可以通过 intRef 来读写 int 变量。Kotlin 正是通过这种办法使得局部变量可修改。除了 IntRef，还有 LongRef，FloatRef 等，如果是非基础类型，就统一用 ObjectRef 即可。</p>
<h3 id="3-闭包捕获变量"><a href="#3-闭包捕获变量" class="headerlink" title="3.闭包捕获变量"></a>3.闭包捕获变量</h3><p>闭包可以访问函数体之外的变量，这个过程称为捕获变量。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">var value = 0// 全局变量</span><br><span class="line">fun main(args: Array&lt;String&gt;?) &#123;</span><br><span class="line">    // 局部变量</span><br><span class="line">    var localValue = 20</span><br><span class="line"></span><br><span class="line">    val result = &#123; a: Int -&gt;</span><br><span class="line">        value++</span><br><span class="line">        localValue++</span><br><span class="line">        val c = a + value + localValue</span><br><span class="line">        println(c)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    result(30)</span><br><span class="line"></span><br><span class="line">    println(&quot;value = $value&quot;)</span><br><span class="line">    println(&quot;localValue = $localValue&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out: 52</span><br><span class="line">System.out: value = 1</span><br><span class="line">System.out: localValue = 21</span><br></pre></td></tr></table></figure>
<p>闭包是捕获 value 和 localValue 变量的 Lambda 表达式。</p>
<p><strong>Java 与 Koltin 中 Lambda 捕获局部变量区别</strong><br>在函数不是“一等公民”的 Java 这里，匿名类其实就是代替闭包而存在的。只不过 Java 严格要求所有函数都需要在类里面，所以巧妙的把“声明一个函数”这样的行为变成了“声明一个接口”或“重写一个方法”。<br>匿名类也可以捕获当前环境的 final 局部变量。但和闭包不一样的是，匿名类无法修改捕获的局部变量（final 不可修改）。而匿名类能引用 final 的局部变量，是因为在编译阶段，会把该局部变量作为匿名类的构造参数传入。<br>因为匿名类修改的变量不是真正的局部变量，而是自己的构造参数，外部局部变量并没有被修改。所以 Java 编译器不允许匿名类引用非 final 变量。jdk7在 Lambda 体中只能读取局部变量，不能修改局部变量。<br>而 kotlin 中没有这个限制，可以读取和修改局部变量。如下面代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 声明了一个Java代码接口</span><br><span class="line">public interface Clickable &#123;</span><br><span class="line">    void onClick();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Java中的Lambda表达式局部变量捕获</span><br><span class="line">public class Closure &#123;</span><br><span class="line">    private void closure(Clickable clickable) &#123;</span><br><span class="line">        clickable.onClick();</span><br><span class="line">    &#125;</span><br><span class="line">    public void main(ArrayList&lt;String&gt; args) &#123;</span><br><span class="line">        int count = 0;</span><br><span class="line">        closure(() -&gt; &#123;</span><br><span class="line">            count += 1; // 编译错误，count需要使用final修饰</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样的Java代码是编译不过的，必须设置为 count 为 final 才能通过编译，但又不能对 count 进行修改，如果非要修改 count 只能把 count 声明为 Closure 的成员变量。<br>对比 Kotlin 代码实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Closure &#123;</span><br><span class="line"></span><br><span class="line">    private fun closure(clickable: Clickable) &#123;</span><br><span class="line">        clickable.onClick()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fun main(args: Array&lt;String&gt;) &#123;</span><br><span class="line">        var count: Int = 0</span><br><span class="line">        closure(Clickable &#123; count += 1 &#125;) // 编译正常</span><br><span class="line">        println(count)  // 2</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再来看一个闭包的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">fun returnFun(): () -&gt; Int &#123;</span><br><span class="line">    var count = 0</span><br><span class="line">    return &#123; count++ &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun main() &#123;</span><br><span class="line">    val function = returnFun()</span><br><span class="line">    val function2 = returnFun()</span><br><span class="line">    println(function()) // 0</span><br><span class="line">    println(function()) // 1</span><br><span class="line">    println(function()) // 2</span><br><span class="line"></span><br><span class="line">    println(function2()) // 0</span><br><span class="line">    println(function2()) // 1</span><br><span class="line">    println(function2()) // 2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每调用一次function()，count都会加一，说明count 被function持有了而且可以被修改。而function2和function的count是独立的，不是共享的。</p>
<h1 id="八-Kotlin中的扩展函数"><a href="#八-Kotlin中的扩展函数" class="headerlink" title="八.Kotlin中的扩展函数"></a>八.Kotlin中的扩展函数</h1><p>扩展函数数是指在一个类上增加一种新的行为，甚至我们没有这个类代码的访问权限。在Java中，通常会实现很多带有static方法的工具类，而Kotlin中扩展函数的一个优势是我们不需要在调用方法的时候把整个对象当作参数传入， 它表现得就像是属于这个类的一样，而且我们可以使用this关键字和调用所有public方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fun 被扩展类名.扩展函数名( 参数 )&#123;</span><br><span class="line">   //实现代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Java调用Kotlin扩展函数:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">扩展类名Kt.扩展函数名(参数);</span><br></pre></td></tr></table></figure>
<h1 id="九-Kotlin中的内联函数"><a href="#九-Kotlin中的内联函数" class="headerlink" title="九.Kotlin中的内联函数"></a>九.Kotlin中的内联函数</h1><h3 id="1-inline关键字"><a href="#1-inline关键字" class="headerlink" title="1.inline关键字"></a>1.inline关键字</h3><p>如果没有内联修饰符标记函数，在使用lambda会带来性能开销。举个接收函数类型的例子:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//callAction 接受一个函数类型(lambda)</span><br><span class="line">private fun callAction(action: () -&gt; Unit) &#123;</span><br><span class="line">    println(&quot;call Action before&quot;)</span><br><span class="line">    action()</span><br><span class="line">    println(&quot;call Action after&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun main(args: Array&lt;String&gt;) &#123;</span><br><span class="line">    callAction &#123;</span><br><span class="line">        println(&quot;call action&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>反编译为:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public final void main(@NotNull String[] args) &#123;</span><br><span class="line">      callAction((Function0)null.INSTANCE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> private final void callAction(Function0 action) &#123;</span><br><span class="line">      String var2 = &quot;call Action before&quot;;</span><br><span class="line">      boolean var3 = false;</span><br><span class="line">      System.out.println(var2);</span><br><span class="line">      action.invoke();</span><br><span class="line">      var2 = &quot;call Action after&quot;;</span><br><span class="line">      var3 = false;</span><br><span class="line">      System.out.println(var2);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>由此可见当调用<code>callAction(action: () -&gt; Unit)</code> 时，传递的lambda会被Function0所代替，而Function0是一个被定义为如下的接口:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface Function0&lt;out R&gt; : Function&lt;R&gt; &#123;</span><br><span class="line">    public operator fun invoke(): R</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在调用callAction时，编译器会额外生成一个Function0的实例传递给callAction，内部会调用 Function0 的 invoke() 方法。因此使用lambda会带来额外的性能开销。<br>可以通过内联函数消除lambda带来的运行时开销。被inline标记的函数就是内联函数，其原理就是：在编译时期，把调用这个函数的地方用这个函数的方法体进行替换。 在函数被使用的时候编译器并不会生成函数调用的代码，<br>而是使用函数实现的真实代码替换每一次的函数调用。还是拿 callAction(action: () -&gt; Unit) 方法举例，当给该函数添加inline修饰符后，编译后的调用代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public final void main(@NotNull String[] &#123;</span><br><span class="line">      ...省略无关紧要的代码</span><br><span class="line">      System.out.println(&quot;call Action before&quot;);</span><br><span class="line">      System.out.println(&quot;call action&quot;);</span><br><span class="line">      System.out.println(&quot;call Action after&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结下:</p>
<ul>
<li>被inline修饰的函数叫内联函数。</li>
<li>内联函数会在被调用的位置内联。内联函数的代码会被拷贝到使用它的位置，并把lambda替换到其中。</li>
</ul>
<blockquote>
<p>在kotlin中lambda 表达式会被正常地编译成匿名类。这表示每调用一次lambda 表达式，一个额外的类就会被创建。并且如果lambda 捕捉了某个变量，那么每次调用的时候都会创建一个新的对象。这会带来运行时的额外开销，导致使用lambda 比使用一个直接执行相同代码的函数效率更低。<br>如果使用 inline 修饰符标记一个函数，在函数被使用的时候编译器并不会生成函数调用的代码，而是使用函数实现的真实代码替换每一次的函数调用。</p>
</blockquote>
<h3 id="2-noinline关键字"><a href="#2-noinline关键字" class="headerlink" title="2.noinline关键字"></a>2.noinline关键字</h3><p>虽然内联非常好用，但是会出现这么一个问题，就是内联函数的参数(ps:参数是函数,比如上面的body函数)如果在内联函数的方法体内被其他非内联函数调用，就会报错。<br>例如:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">inline fun &lt;T&gt; mehtod(lock: Lock, body: () -&gt; T): T &#123;</span><br><span class="line">            lock.lock()</span><br><span class="line">            try &#123;</span><br><span class="line">                otherMehtod(body)//会报错</span><br><span class="line">                return body()</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                lock.unlock()</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    fun &lt;T&gt; otherMehtod(body: ()-&gt; T)&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>原因:因为method是内联函数，所以它的形参也是inline的，所以body就是inline的，但是在编译时期，body已经不是一个函数对象，而是一个具体的值，然而otherMehtod却要接收一个body的函数对象，所以就编译不通过。<br>解决方法:当然就是加noinline了，它的作用就已经非常明显了。就是让内联函数的形参函数不是内联的，保留原有的函数特征。<br>具体操作:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">fun main(args: Array&lt;String&gt;) &#123;</span><br><span class="line">    val lock = ReentrantLock()</span><br><span class="line">    mehtod(lock,&#123;&quot;body方法体&quot;&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inline fun &lt;T&gt; mehtod(lock: Lock, noinline body: () -&gt; T): T &#123;</span><br><span class="line">    lock.lock()</span><br><span class="line">    try &#123;</span><br><span class="line">        otherMehtod(body)</span><br><span class="line">        return body()</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        lock.unlock()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun &lt;T&gt; otherMehtod(body: ()-&gt; T)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样编译时期这个body函数就不会被内联了,反编译看下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">public static final void main(@NotNull String[] args) &#123;</span><br><span class="line">   Intrinsics.checkParameterIsNotNull(args, &quot;args&quot;);</span><br><span class="line">   ReentrantLock lock = new ReentrantLock();</span><br><span class="line">   //这里是生成了一个函数对象</span><br><span class="line">   Function0 body$iv = (Function0)null.INSTANCE;</span><br><span class="line">   ((Lock)lock).lock();</span><br><span class="line"></span><br><span class="line">   try &#123;</span><br><span class="line">      otherMehtod(body$iv);</span><br><span class="line">      Object var3 = body$iv.invoke();</span><br><span class="line">   &#125; finally &#123;</span><br><span class="line">      ((Lock)lock).unlock();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static final Object mehtod(@NotNull Lock lock, @NotNull Function0 body) &#123;</span><br><span class="line">   Intrinsics.checkParameterIsNotNull(lock, &quot;lock&quot;);</span><br><span class="line">   Intrinsics.checkParameterIsNotNull(body, &quot;body&quot;);</span><br><span class="line">   lock.lock();</span><br><span class="line"></span><br><span class="line">   Object var3;</span><br><span class="line">   try &#123;</span><br><span class="line">      otherMehtod(body);</span><br><span class="line">      var3 = body.invoke();</span><br><span class="line">   &#125; finally &#123;</span><br><span class="line">      InlineMarker.finallyStart(1);</span><br><span class="line">      lock.unlock();</span><br><span class="line">      InlineMarker.finallyEnd(1);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   return var3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static final void otherMehtod(@NotNull Function0 body) &#123;</span><br><span class="line">   Intrinsics.checkParameterIsNotNull(body, &quot;body&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-crossinline关键字"><a href="#3-crossinline关键字" class="headerlink" title="3.crossinline关键字"></a>3.crossinline关键字</h3><p>很少用到crossinline修饰符，crossinline 的作用是内联函数中让被标记为crossinline 的lambda表达式不允许非局部返回。 在kotlin中，return 只可以用在有名字的函数，或者匿名函数中，使得该函数执行完毕。<br>而针对lambda表达式，你不能直接使用return你可以使用return+label的形式，将这个lambda结束。但是若你的lambda应用在一个内联函数的时候，这时候你可以在lambda中使用return 可以这么理解，内联函数在编译的时候，<br>将相关的代码贴入你调用的地方。 lambda表达式就是一段代码而已，这时候你在lambda中的return，相当于在你调用的方法内return crossinline就是为了让其不能直接return。</p>
<h1 id="十-Kotin的lambda的简化回调函数"><a href="#十-Kotin的lambda的简化回调函数" class="headerlink" title="十.Kotin的lambda的简化回调函数"></a>十.Kotin的lambda的简化回调函数</h1><p>在Kotlin中对Java中的一些的接口的回调做了一些优化，可以使用一个lambda函数来代替。可以简化写一些不必要的嵌套回调方法。但是需要注意:<strong>在lambda表达式，只支持单抽象方法模型，也就是说设计的接口里面只有一个<br>抽象的方法，才符合lambda表达式的规则，多个回调方法不支持。</strong></p>
<ol>
<li>用Java代码实现一个接口的回调:<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mView.setEventListener(new ExamPlanHomeEventListener()&#123;</span><br><span class="line">   public void onSuccess(Data data)&#123;</span><br><span class="line">     //todo</span><br><span class="line">   &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
<li>在Kotlin中的实现一个接口的回调，不使用lambda表达式(<code>这种方式非常适用于kotlin中对于一个接口中含有多个回调方法</code>):<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mView.setEventListener(object: ExamPlanHomeEventListener&#123;</span><br><span class="line">  public void onSuccess(Data data)&#123;</span><br><span class="line">    //todo</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
3.如果在Kotlin中的对于<strong>接口只有一个回调的方法</strong>，可以使用lambda函数简化:<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mView.setEventListener(&#123;</span><br><span class="line">   data: Data -&gt;</span><br><span class="line">   //todo</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">//或者可以直接省略Data，借助kotlin的智能类型推导</span><br><span class="line"></span><br><span class="line">mView.setEventListener(&#123;</span><br><span class="line">   data -&gt;</span><br><span class="line">   //todo</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li>如果以上代码中的<strong>data参数没有使用</strong>到的话，可以直接把data去掉:<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mView.setEventListener(&#123;</span><br><span class="line">  //todo</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li>以上代码还可以做个调整，由于setEventListener函数<strong>最后一个参数是一个函数</strong>的话，可以直接把括号的实现提到圆括号外面:<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mView.setEventListener()&#123;</span><br><span class="line">   //todo</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>由于setEventListener这个函数<strong>只有一个参数</strong>，可以直接省略圆括号:<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mView.setEventListener&#123;</span><br><span class="line">  //todo</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="十一-Kotlin中的作用域函数"><a href="#十一-Kotlin中的作用域函数" class="headerlink" title="十一.Kotlin中的作用域函数"></a>十一.Kotlin中的作用域函数</h1><h3 id="1-let函数"><a href="#1-let函数" class="headerlink" title="1.let函数"></a>1.let函数</h3><p>当需要定义一个变量在一个特定的作用域时，可以考虑使用 let 函数。更多的是用于避免 Null 判断。在 let 函数内部，用 it 指代调用 let 函数的对象，并且最后返回最后的计算值。</p>
<ol>
<li><p>let函数的使用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//一般结构</span><br><span class="line">object.let&#123;</span><br><span class="line">    //用 it 指代 object 对象</span><br><span class="line">    //todo() 是 object对象的共有属性或方法</span><br><span class="line">    //it.todo() 的返回值作为 let 函数的返回值返回</span><br><span class="line">    it.todo()</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//另一种用途 判断object为null的操作</span><br><span class="line">object?.let&#123;</span><br><span class="line">  //表示object不为null的条件下，才会去执行let函数体</span><br><span class="line">it.todo()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>let函数底层的inline扩展函数+lambda结构</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@kotlin.internal.InlineOnly</span><br><span class="line">public inline fun &lt;T, R&gt; T.let(block: (T) -&gt; R): R = block(this)</span><br></pre></td></tr></table></figure>
<p>从源码let函数的结构来看它是只有一个lambda函数块block作为参数的函数，调用T类型对象的let函数，则该对象为函数的参数。在函数块内可以通过 it 指代该对象。返回值为函数块的最后一行或指定return表达式。</p>
</li>
<li><p>let函数适用的场景:</p>
</li>
</ol>
<ul>
<li>最常用的场景就是使用let函数处理需要针对一个可null的对象统一做判空处理。</li>
<li>然后就是需要去明确一个变量所处特定的作用域范围内可以使用。<br>let函数使用前后的对比:<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//没有使用let函数的代码是这样的，看起来不够优雅</span><br><span class="line">mTextView?.text = &quot;TextView&quot;</span><br><span class="line">mTextView?.setTextColor(ContextCompat.getColor(this, R.color.colorAccent))</span><br><span class="line">mTextView?.textSize = 10f</span><br><span class="line"></span><br><span class="line">//使用let函数后的代码是这样的</span><br><span class="line">mTextView?.let &#123;</span><br><span class="line">    it.text = &quot;TextView&quot;</span><br><span class="line">    it.setTextColor(ContextCompat.getColor(this, R.color.colorAccent))</span><br><span class="line">    it.textSize = 10f</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-with函数"><a href="#2-with函数" class="headerlink" title="2.with函数"></a>2.with函数</h3><p>with 和 let 类似，with 最后也包含一段函数块，也是将最后的计算的结果返回。但是 with 不是以拓展的形式存在的。其将某个对象作为函数的参数，并且以 this 指代。</p>
<ol>
<li>with函数使用<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">with(object)&#123;</span><br><span class="line">     // todo() 是 object 对象的共有属性或方法</span><br><span class="line">    // todo() 的返回值作为 with 函数的返回值返回</span><br><span class="line">   todo()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>with函数底层的inline扩展函数+lambda结构<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@kotlin.internal.InlineOnly</span><br><span class="line">public inline fun &lt;T, R&gt; with(receiver: T, block: T.() -&gt; R): R = receiver.block()</span><br></pre></td></tr></table></figure>
with函数不是以扩展的形式存在的。它是将某对象作为函数的参数，在函数块内可以通过 this 指代该对象。返回值为函数块的最后一行或指定return表达式。with函数是接收了两个参数，分别为T类型的对象receiver和一个lambda函数块，所以with函数最原始样子如下:<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">val result = with(user, &#123;</span><br><span class="line">  println(&quot;my name is $name, I am $age years old, my phone number is $phoneNum&quot;)</span><br><span class="line">  1000</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
由于with函数最后一个参数是一个函数，可以把函数提到圆括号的外部，所以最终with函数的调用形式如下:</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">val result = with(user) &#123;</span><br><span class="line"> println(&quot;my name is $name, I am $age years old, my phone number is $phoneNum&quot;)</span><br><span class="line"> 1000 //返回值</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>with函数的适用的场景<br>适用于调用同一个类的多个方法时，可以省去类名重复，直接调用类的方法即可，经常用于Android中RecyclerView中onBinderViewHolder中，数据model的属性映射到UI上。<br>没有使用kotlin中的实现：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void onBindViewHolder(ViewHolder holder, int position) &#123;</span><br><span class="line"></span><br><span class="line">   ArticleSnippet item = getItem(position);</span><br><span class="line">      if (item == null) &#123;</span><br><span class="line">          return;</span><br><span class="line">      &#125;</span><br><span class="line">      holder.tvTitle.setText(item.titleEn);</span><br><span class="line">      holder.tvSummary.setText(item.summary);</span><br><span class="line">      String gradeInfo = &quot;难度：&quot; + item.gradeInfo;</span><br><span class="line">      String wordCount = &quot;单词数：&quot; + item.length;</span><br><span class="line">      String reviewNum = &quot;读后感：&quot; + item.numReviews;</span><br><span class="line">      String extraInfo = gradeInfo + &quot; | &quot; + wordCount + &quot; | &quot; + reviewNum;</span><br><span class="line">      holder.tvExtraInfo.setText(extraInfo);</span><br><span class="line">      ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
kotlin的实现：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">override fun onBindViewHolder(holder: ViewHolder, position: Int)&#123;</span><br><span class="line">   val item = getItem(position)?: return</span><br><span class="line">   with(item)&#123;</span><br><span class="line">       holder.tvNewsTitle.text = StringUtils.trimToEmpty(titleEn)</span><br><span class="line">       holder.tvNewsSummary.text = StringUtils.trimToEmpty(summary)</span><br><span class="line">       holder.tvExtraInf.text = &quot;难度：$gradeInfo | 单词数：$length | 读后感: $numReviews&quot;</span><br><span class="line">       ...   </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="3-run函数"><a href="#3-run函数" class="headerlink" title="3.run函数"></a>3.run函数</h3><p>既有 let 函数那样又优雅的判空，又能有 with 函数省去同一个对象多次设置属性的便捷写法。非 run 函数莫属了。run 函数基本是 let 和 with 的结合体，对象调用 run 函数，接收一个 lambda 函数为参数，传入 this 并以闭包形式返回，返回值是最后的计算结果。</p>
<ol>
<li><p>run函数使用的一般结构</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">object.run&#123;</span><br><span class="line">    // todo() 是 object 对象的共有属性或方法</span><br><span class="line">    // todo() 的返回值作为 run 函数的返回值返回</span><br><span class="line">     todo() </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>run函数的inline+lambda结构</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@kotlin.internal.InlineOnly</span><br><span class="line">public inline fun &lt;T, R&gt; T.run(block: T.() -&gt; R): R = block()</span><br></pre></td></tr></table></figure>
<blockquote>
<p>run函数实际上可以说是let和with两个函数的结合体，run函数只接收一个lambda函数为参数，以闭包形式返回，返回值为最后一行的值或者指定的return的表达式。</p>
</blockquote>
</li>
<li><p>run函数的适用场景<br>适用于let，with函数任何场景。因为run函数是let，with两个函数结合体，准确来说它弥补了let函数在函数体内必须使用it参数替代对象，在run函数中可以像with函数一样可以省略，直接访问实例的公有属性和方法，另一方面它弥补了with函数传入对象判空问题，在run函数中可以像let函数一样做判空处理。<br>没有使用kotlin中的实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">override fun onBindViewHolder(holder: ViewHolder, position: Int)&#123;</span><br><span class="line">   val item = getItem(position)?: return</span><br><span class="line">   with(item)&#123;</span><br><span class="line">       holder.tvNewsTitle.text = StringUtils.trimToEmpty(titleEn)</span><br><span class="line">       holder.tvNewsSummary.text = StringUtils.trimToEmpty(summary)</span><br><span class="line">       holder.tvExtraInf = &quot;难度：$gradeInfo | 单词数：$length | 读后感: $numReviews&quot;</span><br><span class="line">       ...   </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用run函数后的优化：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">override fun onBindViewHolder(holder: ViewHolder, position: Int)&#123;</span><br><span class="line">  getItem(position)?.run&#123;</span><br><span class="line">       holder.tvNewsTitle.text = StringUtils.trimToEmpty(titleEn)</span><br><span class="line">       holder.tvNewsSummary.text = StringUtils.trimToEmpty(summary)</span><br><span class="line">       holder.tvExtraInf = &quot;难度：$gradeInfo | 单词数：$length | 读后感: $numReviews&quot;</span><br><span class="line">       ...   </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="4-apply函数"><a href="#4-apply函数" class="headerlink" title="4.apply函数"></a>4.apply函数</h3><p>apply 函数和 run 函数很像，但是 apply 最后返回的是调用对象自身。</p>
<ol>
<li>apply函数使用的一般结构<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">object.apply&#123;</span><br><span class="line">  // todo() 是 object 对象的共有属性或方法</span><br><span class="line">  todo() </span><br><span class="line">  &quot;test&quot; // 最后返回的是 object 对象，而不是 test</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>apply函数的inline+lambda结构<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@kotlin.internal.InlineOnly</span><br><span class="line">public inline fun &lt;T&gt; T.apply(block: T.() -&gt; Unit): T &#123; block(); return this &#125;</span><br></pre></td></tr></table></figure>
从结构上来看apply函数和run函数很像，唯一不同点就是它们各自返回的值不一样，run函数是以闭包形式返回最后一行代码的值，而apply函数的返回的是传入对象的本身。</li>
<li>apply函数的适用场景<br>整体作用功能和run函数很像，唯一不同点就是它返回的值是对象本身，而run函数是一个闭包形式返回，返回的是最后一行的值。正是基于这一点差异它的适用场景稍微与run函数有点不一样。apply一般用于一个对象实例初始化的时候，需要对对象中的属性进行赋值。或者动态inflate出一个XML的View的时候需要给View绑定数据也会用到，这种情景非常常见。特别是在我们开发中会有一些数据model向View model转化实例化的过程中需要用到。<br>apply函数使用前后的对比<br>没有使用apply函数的代码是这样的，看起来不够优雅<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mSheetDialogView = View.inflate(activity, R.layout.biz_exam_plan_layout_sheet_inner, null)</span><br><span class="line">        mSheetDialogView.course_comment_tv_label.paint.isFakeBoldText = true</span><br><span class="line">        mSheetDialogView.course_comment_tv_score.paint.isFakeBoldText = true</span><br><span class="line">        mSheetDialogView.course_comment_tv_cancel.paint.isFakeBoldText = true</span><br><span class="line">        mSheetDialogView.course_comment_tv_confirm.paint.isFakeBoldText = true</span><br><span class="line">        mSheetDialogView.course_comment_seek_bar.max = 10</span><br><span class="line">        mSheetDialogView.course_comment_seek_bar.progress = 0</span><br></pre></td></tr></table></figure>
使用apply函数后的代码是这样的</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mSheetDialogView = View.inflate(activity, R.layout.biz_exam_plan_layout_sheet_inner, null).apply&#123;</span><br><span class="line">   course_comment_tv_label.paint.isFakeBoldText = true</span><br><span class="line">   course_comment_tv_score.paint.isFakeBoldText = true</span><br><span class="line">   course_comment_tv_cancel.paint.isFakeBoldText = true</span><br><span class="line">   course_comment_tv_confirm.paint.isFakeBoldText = true</span><br><span class="line">   course_comment_seek_bar.max = 10</span><br><span class="line">   course_comment_seek_bar.progress = 0</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>多层级判空问题</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">if (mSectionMetaData == null || mSectionMetaData.questionnaire == null || mSectionMetaData.section == null) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    if (mSectionMetaData.questionnaire.userProject != null) &#123;</span><br><span class="line">        renderAnalysis();</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    if (mSectionMetaData.section != null &amp;&amp; !mSectionMetaData.section.sectionArticles.isEmpty()) &#123;</span><br><span class="line">        fetchQuestionData();</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>kotlin的apply函数优化</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mSectionMetaData?.apply&#123;</span><br><span class="line">           //mSectionMetaData不为空的时候操作mSectionMetaData</span><br><span class="line">       &#125;?.questionnaire?.apply&#123;</span><br><span class="line">           //questionnaire不为空的时候操作questionnaire</span><br><span class="line">       &#125;?.section?.apply&#123;</span><br><span class="line">           //section不为空的时候操作section</span><br><span class="line">       &#125;?.sectionArticle?.apply&#123;</span><br><span class="line">           //sectionArticle不为空的时候操作sectionArticle</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-also函数"><a href="#5-also函数" class="headerlink" title="5.also函数"></a>5.also函数</h3><p>also函数和 let 函数类似，唯一的区别就是 also 函数的返回值是调用对象本身。</p>
<ol>
<li><p>also函数使用的一般结构</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">object.also&#123;</span><br><span class="line">    // 用 it 指代 object 对象</span><br><span class="line">    // todo() 是 object 对象的共有属性或方法</span><br><span class="line">    it.todo() </span><br><span class="line">    &quot;test&quot; // 将返回 any 对象，而不是 test</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>also函数的inline+lambda结构</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@kotlin.internal.InlineOnly</span><br><span class="line">@SinceKotlin(&quot;1.1&quot;)</span><br><span class="line">public inline fun &lt;T&gt; T.also(block: (T) -&gt; Unit): T &#123; block(this); return this &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>also函数的结构实际上和let很像唯一的区别就是返回值的不一样，let是以闭包的形式返回，返回函数体内最后一行的值，如果最后一行为空就返回一个Unit类型的默认值。而also函数返回的则是传入对象的本身。</p>
</blockquote>
</li>
<li><p>also函数的适用场景<br>适用于let函数的任何场景，also函数和let很像，只是唯一的不同点就是let函数最后的返回值是最后一行的返回值而also函数的返回值是返回当前的这个对象。一般可用于多个扩展函数链式调用</p>
</li>
</ol>
<h3 id="6-let，with，run，apply，also函数区别"><a href="#6-let，with，run，apply，also函数区别" class="headerlink" title="6.let，with，run，apply，also函数区别"></a>6.let，with，run，apply，also函数区别</h3><p>通过以上几种函数的介绍，可以很方便优化kotlin中代码编写，整体看起来几个函数的作用很相似，但是各自又存在着不同。使用的场景有相同的地方比如run函数就是let和with的结合体。下面一张表格可以清晰对比出他们的不同之处。</p>
<table>
<thead>
<tr>
<th>函数名</th>
<th>函数体内使用的对象</th>
<th>返回值</th>
<th>是否是扩展函数</th>
<th>适用的场景</th>
</tr>
</thead>
<tbody><tr>
<td>let</td>
<td>it指代当前对象</td>
<td>闭包形式返回</td>
<td>是</td>
<td>适用于处理不为null的操作场景</td>
</tr>
<tr>
<td>with</td>
<td>this指代当前对象或者省略</td>
<td>闭包形式返回</td>
<td>否</td>
<td>适用于调用同一个类的多个方法时，可以省去类名重复，直接调用类的方法即可，经常用于Android中RecyclerView中onBinderViewHolder中，数据model的属性映射到UI上</td>
</tr>
<tr>
<td>run</td>
<td>this指代当前对象或者省略</td>
<td>闭包形式返回</td>
<td>是</td>
<td>适用于let，with函数任何场景。</td>
</tr>
<tr>
<td>apply</td>
<td>this指代当前对象或者省略</td>
<td>返回this</td>
<td>是</td>
<td>1、适用于run函数的任何场景，一般用于初始化一个对象实例的时候，操作对象属性，并最终返回这个对象。</td>
</tr>
</tbody></table>
<h3 id="7-Kotlin中的作用域函数选择"><a href="#7-Kotlin中的作用域函数选择" class="headerlink" title="7.Kotlin中的作用域函数选择"></a>7.Kotlin中的作用域函数选择</h3><p><img src="/images/991e7ee32a7e351f8fef03f47ac8fafd.webp"></p>
<p>参考自：<br><a target="_blank" rel="noopener" href="https://www.kotlincn.net/docs/reference/constructing-collections.html">kotlin官方文档</a></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://lxlfpeng.github.io">peng</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://lxlfpeng.github.io/2019/07/26/Kotlin%E6%80%BB%E7%BB%93%E4%B9%8B%E4%B8%89%E5%87%BD%E6%95%B0%E5%8F%8A%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/">https://lxlfpeng.github.io/2019/07/26/Kotlin%E6%80%BB%E7%BB%93%E4%B9%8B%E4%B8%89%E5%87%BD%E6%95%B0%E5%8F%8A%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://lxlfpeng.github.io" target="_blank">鹏哥的Blog</a>！</span></div></div><div class="tag_share"><div class="post-share"><div class="social-share" data-image="/images/about_avatar.webp" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2019/08/01/Apk%E6%9E%84%E5%BB%BA%E6%80%BB%E7%BB%93%E4%B9%8B%E4%B8%80%E6%89%93%E5%8C%85%E6%B5%81%E7%A8%8B%E5%8F%8A%E5%AE%89%E8%A3%85%E6%B5%81%E7%A8%8B/" title="Apk构建总结之一打包流程及安装流程"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Apk构建总结之一打包流程及安装流程</div></div><div class="info-2"><div class="info-item-1">一. 分析已经打好的apk要了解APK的打包流程,我们首先来了解下打包完成以后APK包里面包含哪些东西。.apk文件其实就是一个压缩文件，把文件的后缀改成.zip就可以用解压软件解压了： 1. 将apk后缀改成rar包 2. 解压rar包 apk是一个压缩包，里面有lib，META-INF，classes.dex，res，resources.arsc文件夹和文件。下面看看它们各自的作用。  assets资源。 lib不是每个apk都有的，主要看项目,文件夹里面存放的是so动态链接库，so动态链接库不需要做处理。 META-INF是签名文件夹，里面有三个文件。 res:除图片和 res&#x2F;raw 文件夹下的文件外，其余的 xml 文件都被 aapt 编译成二进制的 xml 文件,里面还会分animator,anim,color,drawable,layout,menu和raw这几个文件夹。 AndroidManifest.xml:经过 aapt 编译后的二进制的 xml 文件,它位于整个项目的根目录，描述了package中暴露的组件（activities,...</div></div></div></a><a class="pagination-related" href="/2019/07/24/Java%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B%E5%8F%8AJvm%E8%AF%A6%E8%A7%A3/" title="Java编译过程及Jvm详解"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Java编译过程及Jvm详解</div></div><div class="info-2"><div class="info-item-1">一.Jvm简介1.JVM是什么?JVM是Java Virtual Machine(Java虚拟机)的缩写，也就是指的JVM虚拟机，是一种用于计算设备的规范，它是一个虚构出来的计算机，是通过在实际的计算机上仿真模拟各种计算机功能来实现的。众所周知，java语言是跨平台的，而JVM是java跨平台的关键之所在，JVM上执行java字节码，执行时这些字节码可以解释成具体平台的机器码，因此java拥有“一次编译，处处运行”这一跨平台能力。 2.JRE、JDK和JVM的关系JRE(Java Runtime Environment， Java运行环境)是Java平台，所有的JAVA程序都要在JRE下才能够运行，包括JVM和Java核心类库和支持文件。JDK(Java Development Kit，Java开发工具包)是用来编译、调试Java程序的开发工具包，包括Java工具(javac&#x2F;java&#x2F;jdb等)和Java基础的类库(java API )。JVM(Java Virtual Machine，...</div></div></div></a></nav><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="giscus-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/images/about_avatar.webp" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">peng</div><div class="author-info-description">过往不恋 未来不迎 当下不负</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">127</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">59</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">24</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/lxlfpeng"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/lxlfpeng" target="_blank" title="Github"><i class="fab fa-github" style="color: #4a7dbe;"></i></a><a class="social-icon" href="mailto:565289282@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎来到我的博客!</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80-Kotlin%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0"><span class="toc-number">1.</span> <span class="toc-text">一.Kotlin中的函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E"><span class="toc-number">1.0.1.</span> <span class="toc-text">1.函数声明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%8D%95%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%87%BD%E6%95%B0"><span class="toc-number">1.0.2.</span> <span class="toc-text">2.单表达式函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E9%A1%B6%E5%B1%82%E5%87%BD%E6%95%B0"><span class="toc-number">1.0.3.</span> <span class="toc-text">3.顶层函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E9%A1%B6%E5%B1%82%E5%B1%9E%E6%80%A7"><span class="toc-number">1.0.4.</span> <span class="toc-text">4.顶层属性</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C-Kotlin%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0"><span class="toc-number">2.</span> <span class="toc-text">二.Kotlin中的函数参数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%87%BD%E6%95%B0%E7%9A%84%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0"><span class="toc-number">2.0.1.</span> <span class="toc-text">1.函数的默认参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%87%BD%E6%95%B0%E7%9A%84%E5%85%B7%E5%90%8D%E5%8F%82%E6%95%B0"><span class="toc-number">2.0.2.</span> <span class="toc-text">2.函数的具名参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%87%BD%E6%95%B0%E5%8F%AF%E5%8F%98%E9%95%BF%E5%BA%A6%E7%9A%84%E5%8F%82%E6%95%B0"><span class="toc-number">2.0.3.</span> <span class="toc-text">3.函数可变长度的参数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89-%E4%B8%80%E7%AD%89%E5%85%AC%E6%B0%91%E5%87%BD%E6%95%B0"><span class="toc-number">3.</span> <span class="toc-text">三.一等公民函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%80%E7%AD%89%E5%85%AC%E6%B0%91%E5%87%BD%E6%95%B0"><span class="toc-number">3.0.1.</span> <span class="toc-text">1.什么是一等公民函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%B8%80%E7%AD%89%E5%85%AC%E6%B0%91%E5%87%BD%E6%95%B0%E5%8F%AF%E4%BB%A5%E8%B5%8B%E5%80%BC%E7%BB%99%E4%B8%80%E4%B8%AA%E5%8F%98%E9%87%8F"><span class="toc-number">3.0.2.</span> <span class="toc-text">2.一等公民函数可以赋值给一个变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E4%B8%80%E7%AD%89%E5%85%AC%E6%B0%91%E5%87%BD%E6%95%B0%E5%8F%AF%E4%BB%A5%E4%BD%9C%E4%B8%BA%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92"><span class="toc-number">3.0.3.</span> <span class="toc-text">3.一等公民函数可以作为参数传递</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E4%B8%80%E7%AD%89%E5%85%AC%E6%B0%91%E5%87%BD%E6%95%B0%E5%8F%AF%E4%BB%A5%E4%BD%9C%E4%B8%BA%E5%88%AB%E7%9A%84%E5%87%BD%E6%95%B0%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">3.0.4.</span> <span class="toc-text">4.一等公民函数可以作为别的函数的返回值</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9B-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B"><span class="toc-number">4.</span> <span class="toc-text">四.函数式编程</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%94-Kotlin%E4%B8%AD%E7%9A%84%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0"><span class="toc-number">5.</span> <span class="toc-text">五.Kotlin中的匿名函数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AD-Kotlin%E4%B8%AD%E7%9A%84lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">6.</span> <span class="toc-text">六.Kotlin中的lambda表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%AE%9A%E4%B9%89"><span class="toc-number">6.0.1.</span> <span class="toc-text">1.定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AF%AD%E6%B3%95"><span class="toc-number">6.0.2.</span> <span class="toc-text">2.lambda表达式语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%AE%80%E5%8C%96%E8%AF%AD%E6%B3%95"><span class="toc-number">6.0.3.</span> <span class="toc-text">3.lambda表达式简化语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">6.0.4.</span> <span class="toc-text">4.lambda表达式的返回值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%9C%A8android%E4%BD%BF%E7%94%A8Lambda%E7%9A%84%E4%BE%8B%E5%AD%90"><span class="toc-number">6.0.5.</span> <span class="toc-text">5.在android使用Lambda的例子</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%83-Kotlin%E4%B8%AD%E7%9A%84%E9%97%AD%E5%8C%85"><span class="toc-number">7.</span> <span class="toc-text">七.Kotlin中的闭包</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E9%97%AD%E5%8C%85%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">7.0.1.</span> <span class="toc-text">1.闭包的定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E9%97%AD%E5%8C%85%E4%BD%BF%E7%94%A8"><span class="toc-number">7.0.2.</span> <span class="toc-text">2.闭包使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E9%97%AD%E5%8C%85%E6%8D%95%E8%8E%B7%E5%8F%98%E9%87%8F"><span class="toc-number">7.0.3.</span> <span class="toc-text">3.闭包捕获变量</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AB-Kotlin%E4%B8%AD%E7%9A%84%E6%89%A9%E5%B1%95%E5%87%BD%E6%95%B0"><span class="toc-number">8.</span> <span class="toc-text">八.Kotlin中的扩展函数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B9%9D-Kotlin%E4%B8%AD%E7%9A%84%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0"><span class="toc-number">9.</span> <span class="toc-text">九.Kotlin中的内联函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-inline%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">9.0.1.</span> <span class="toc-text">1.inline关键字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-noinline%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">9.0.2.</span> <span class="toc-text">2.noinline关键字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-crossinline%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">9.0.3.</span> <span class="toc-text">3.crossinline关键字</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81-Kotin%E7%9A%84lambda%E7%9A%84%E7%AE%80%E5%8C%96%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0"><span class="toc-number">10.</span> <span class="toc-text">十.Kotin的lambda的简化回调函数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81%E4%B8%80-Kotlin%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%87%BD%E6%95%B0"><span class="toc-number">11.</span> <span class="toc-text">十一.Kotlin中的作用域函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-let%E5%87%BD%E6%95%B0"><span class="toc-number">11.0.1.</span> <span class="toc-text">1.let函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-with%E5%87%BD%E6%95%B0"><span class="toc-number">11.0.2.</span> <span class="toc-text">2.with函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-run%E5%87%BD%E6%95%B0"><span class="toc-number">11.0.3.</span> <span class="toc-text">3.run函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-apply%E5%87%BD%E6%95%B0"><span class="toc-number">11.0.4.</span> <span class="toc-text">4.apply函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-also%E5%87%BD%E6%95%B0"><span class="toc-number">11.0.5.</span> <span class="toc-text">5.also函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-let%EF%BC%8Cwith%EF%BC%8Crun%EF%BC%8Capply%EF%BC%8Calso%E5%87%BD%E6%95%B0%E5%8C%BA%E5%88%AB"><span class="toc-number">11.0.6.</span> <span class="toc-text">6.let，with，run，apply，also函数区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-Kotlin%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%87%BD%E6%95%B0%E9%80%89%E6%8B%A9"><span class="toc-number">11.0.7.</span> <span class="toc-text">7.Kotlin中的作用域函数选择</span></a></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer" style="background: linear-gradient(20deg, #0062be, #925696, #cc426e, #fb0347);"><div id="footer-wrap"><div class="copyright">&copy;2015 - 2025 By peng</div><div class="footer_custom_text"> <a target="_blank" rel="nofollow noopener"><span>千里之行</span></a> <i class="iconfont icon-love"></i> <a target="_blank" rel="nofollow noopener"><span>始于足下</span></a> </div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.isShuoshuo
  const option = null

  const getGiscusTheme = theme => theme === 'dark' ? 'dark' : 'light'

  const createScriptElement = config => {
    const ele = document.createElement('script')
    Object.entries(config).forEach(([key, value]) => {
      ele.setAttribute(key, value)
    })
    return ele
  }

  const loadGiscus = (el = document, key) => {
    const mappingConfig = isShuoshuo
      ? { 'data-mapping': 'specific', 'data-term': key }
      : { 'data-mapping': (option && option['data-mapping']) || 'pathname' }

    const giscusConfig = {
      src: 'https://giscus.app/client.js',
      'data-repo': 'lxlfpeng/blog_comments',
      'data-repo-id': 'R_kgDONYoexA',
      'data-category-id': 'DIC_kwDONYoexM4Ck4JQ',
      'data-theme': getGiscusTheme(document.documentElement.getAttribute('data-theme')),
      'data-reactions-enabled': '1',
      crossorigin: 'anonymous',
      async: true,
      ...option,
      ...mappingConfig
    }

    const scriptElement = createScriptElement(giscusConfig)

    el.querySelector('#giscus-wrap').appendChild(scriptElement)

    if (isShuoshuo) {
      window.shuoshuoComment.destroyGiscus = () => {
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }
  }

  const changeGiscusTheme = theme => {
    const iframe = document.querySelector('#giscus-wrap iframe')
    if (iframe) {
      const message = {
        giscus: {
          setConfig: {
            theme: getGiscusTheme(theme)
          }
        }
      }
      iframe.contentWindow.postMessage(message, 'https://giscus.app')
    }
  }

  btf.addGlobalFn('themeChange', changeGiscusTheme, 'giscus')

  if (isShuoshuo) {
    'Giscus' === 'Giscus'
      ? window.shuoshuoComment = { loadComment: loadGiscus }
      : window.loadOtherComment = loadGiscus
    return
  }

  if ('Giscus' === 'Giscus' || !false) {
    if (false) btf.loadComment(document.getElementById('giscus-wrap'), loadGiscus)
    else loadGiscus()
  } else {
    window.loadOtherComment = loadGiscus
  }
})()</script></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="false"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>