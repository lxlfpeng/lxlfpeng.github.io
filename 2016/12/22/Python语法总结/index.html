<!DOCTYPE html><html lang="zh-CN" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Python语法总结 | 鹏哥的Blog</title><meta name="author" content="peng"><meta name="copyright" content="peng"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#0d0d0d"><meta name="description" content="一.python的基本数据类型。Python常见的数据类型:Number（数字）、String（字符串）、List（列表）、Tuple（元组）、Set（集合）、Dictionary（字典）。  type(xx)              #获取类型,返回值就是数据类型 isinstance(xx, yy )   #判断是否属于某一种类型,属于返回true,不属于返回false  1.Number（">
<meta property="og:type" content="article">
<meta property="og:title" content="Python语法总结">
<meta property="og:url" content="https://lxlfpeng.github.io/2016/12/22/Python%E8%AF%AD%E6%B3%95%E6%80%BB%E7%BB%93/index.html">
<meta property="og:site_name" content="鹏哥的Blog">
<meta property="og:description" content="一.python的基本数据类型。Python常见的数据类型:Number（数字）、String（字符串）、List（列表）、Tuple（元组）、Set（集合）、Dictionary（字典）。  type(xx)              #获取类型,返回值就是数据类型 isinstance(xx, yy )   #判断是否属于某一种类型,属于返回true,不属于返回false  1.Number（">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://lxlfpeng.github.io/images/b84e6e02bfdc6e8abdd155bfb6a23c61.webp">
<meta property="article:published_time" content="2016-12-21T16:00:00.000Z">
<meta property="article:modified_time" content="2025-04-12T15:02:01.844Z">
<meta property="article:author" content="peng">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://lxlfpeng.github.io/images/b84e6e02bfdc6e8abdd155bfb6a23c61.webp"><link rel="shortcut icon" href="/images/favicon.webp"><link rel="canonical" href="https://lxlfpeng.github.io/2016/12/22/Python%E8%AF%AD%E6%B3%95%E6%80%BB%E7%BB%93/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Python语法总结',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  isShuoshuo: false
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/images/about_avatar.webp" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">127</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">59</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">24</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/categories"><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/images/b84e6e02bfdc6e8abdd155bfb6a23c61.webp);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src="/images/nav_logo.webp" alt="Logo"><span class="site-name">鹏哥的Blog</span></a><a class="nav-page-title" href="/"><span class="site-name">Python语法总结</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/categories"><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Python语法总结</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2016-12-21T16:00:00.000Z" title="发表于 2016-12-22 00:00:00">2016-12-22</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Python%E5%BC%80%E5%8F%91/">Python开发</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">9.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>36分钟</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="一-python的基本数据类型。"><a href="#一-python的基本数据类型。" class="headerlink" title="一.python的基本数据类型。"></a>一.python的基本数据类型。</h1><p>Python常见的数据类型:Number（数字）、String（字符串）、List（列表）、Tuple（元组）、Set（集合）、Dictionary（字典）。</p>
<ul>
<li>type(xx)              #获取类型,返回值就是数据类型</li>
<li>isinstance(xx, yy )   #判断是否属于某一种类型,属于返回true,不属于返回false</li>
</ul>
<h3 id="1-Number（数字）"><a href="#1-Number（数字）" class="headerlink" title="1.Number（数字）"></a>1.Number（数字）</h3><p>Python3 支持** int、float、bool、complex（复数）**。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a, b, c, d = 20, 5.5, True, 4 + 3j#定义多个变量</span><br><span class="line">&gt;&gt;&gt; print(type(a), type(b), type(c), type(d))#输出变量的类型</span><br><span class="line">&lt;class &#x27;int&#x27;&gt; &lt;class &#x27;float&#x27;&gt; &lt;class &#x27;bool&#x27;&gt; &lt;class &#x27;complex&#x27;&gt;</span><br></pre></td></tr></table></figure>

<h3 id="1-String（字符串）"><a href="#1-String（字符串）" class="headerlink" title="1.String（字符串）"></a>1.String（字符串）</h3><p>Python中的字符串用单引号 ‘ 或双引号 “ 括起来，同时使用反斜杠 \ 转义特殊字符。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a=&quot;hello&quot;</span><br><span class="line">&gt;&gt;&gt; b=&#x27;hi&#x27;</span><br><span class="line">&gt;&gt;&gt; print(type(a),type(b))</span><br><span class="line"></span><br><span class="line">&lt;class &#x27;str&#x27;&gt; &lt;class &#x27;str&#x27;&gt;</span><br></pre></td></tr></table></figure>

<h5 id="1-字符串切片"><a href="#1-字符串切片" class="headerlink" title="(1)字符串切片"></a>(1)字符串切片</h5><ul>
<li>str[:] 提取从开头（默认位置0）到结尾（默认位置-1）的整个字符串</li>
<li>str[start:] 从start 提取到结尾</li>
<li>str[:end] 从开头提取到end 负数</li>
<li>str[start:end] 从start 提取到end 负数</li>
<li>str[start:end:step] 从start 提取到end - 1，每step 个字符提取一个</li>
</ul>
<h5 id="2-字符串连接"><a href="#2-字符串连接" class="headerlink" title="(2)字符串连接"></a>(2)字符串连接</h5><ul>
<li>+：字符串连接<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a=&quot;hello&quot;</span><br><span class="line">&gt;&gt;&gt; b=&#x27;python&#x27;</span><br><span class="line">&gt;&gt;&gt; print(a+b)</span><br><span class="line"></span><br><span class="line">hellopython</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="3-字符串大小写转换"><a href="#3-字符串大小写转换" class="headerlink" title="(3)字符串大小写转换"></a>(3)字符串大小写转换</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; str = &quot;Python&quot;</span><br><span class="line"> </span><br><span class="line">&gt;&gt;&gt; str.upper()                #转大写</span><br><span class="line">&#x27;PYTHON&#x27;</span><br><span class="line"> </span><br><span class="line">&gt;&gt;&gt; str.lower()                #转小写 </span><br><span class="line">&#x27;python&#x27;</span><br><span class="line"> </span><br><span class="line">&gt;&gt;&gt; str.capitalize()           #字符串首为大写，其余小写</span><br><span class="line">&#x27;Python&#x27;</span><br><span class="line"> </span><br><span class="line">&gt;&gt;&gt; str.swapcase()             #大小写对换 </span><br><span class="line">&#x27;pYTHON&#x27;</span><br><span class="line"> </span><br><span class="line">&gt;&gt;&gt; str.title()                #以分隔符为标记，首字符为大写，其余为小写</span><br><span class="line">&#x27;Python&#x27;</span><br></pre></td></tr></table></figure>



<h5 id="4-字符串条件判断"><a href="#4-字符串条件判断" class="headerlink" title="(4)字符串条件判断"></a>(4)字符串条件判断</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; str = &#x27;01234&#x27;</span><br><span class="line"> </span><br><span class="line">&gt;&gt;&gt; str.isalnum()                #是否全是字母和数字，并至少有一个字符</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; str.isdigit()                #是否全是数字，并至少有一个字符</span><br><span class="line">True      </span><br><span class="line"> </span><br><span class="line">&gt;&gt;&gt; str = &#x27;string&#x27;</span><br><span class="line"> </span><br><span class="line">&gt;&gt;&gt; str.isalnum()                  #是否全是字母和数字，并至少有一个字符</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; str.isalpha()                  #是否全是字母，并至少有一个字符 </span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; str.islower()                  #是否全是小写，当全是小写和数字一起时候，也判断为True</span><br><span class="line">True</span><br><span class="line"> </span><br><span class="line">&gt;&gt;&gt; str = &quot;01234abcd&quot;</span><br><span class="line"> </span><br><span class="line">&gt;&gt;&gt; str.islower()                  #是否全是小写，当全是小写和数字一起时候，也判断为True</span><br><span class="line">True</span><br><span class="line"> </span><br><span class="line">&gt;&gt;&gt; str.isalnum()                  #是否全是字母和数字，并至少有一个字符</span><br><span class="line">True</span><br><span class="line"> </span><br><span class="line">&gt;&gt;&gt; str = &#x27; &#x27;</span><br><span class="line">&gt;&gt;&gt; str.isspace()                  #是否全是空白字符，并至少有一个字符</span><br><span class="line">True</span><br><span class="line"> </span><br><span class="line">&gt;&gt;&gt; str = &#x27;ABC&#x27;</span><br><span class="line"> </span><br><span class="line">&gt;&gt;&gt; str.isupper()                  #是否全是大写，当全是大写和数字一起时候，也判断为True</span><br><span class="line">True</span><br><span class="line"> </span><br><span class="line">&gt;&gt;&gt; str = &#x27;Aaa Bbb&#x27;</span><br><span class="line"> </span><br><span class="line">&gt;&gt;&gt; str.istitle()                  #所有单词字首都是大写，标题 </span><br><span class="line">True</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">&gt;&gt;&gt; str = &#x27;string learn&#x27;</span><br><span class="line"> </span><br><span class="line">&gt;&gt;&gt; str.startswith(&#x27;str&#x27;)          #判断字符串以&#x27;str&#x27;开头</span><br><span class="line">True</span><br><span class="line"> </span><br><span class="line">&gt;&gt;&gt; str.endswith(&#x27;arn&#x27;)            #判读字符串以&#x27;arn&#x27;结尾</span><br><span class="line">True</span><br></pre></td></tr></table></figure>
<h5 id="5-字符串搜索定位与替换"><a href="#5-字符串搜索定位与替换" class="headerlink" title="(5)字符串搜索定位与替换"></a>(5)字符串搜索定位与替换</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; str=&#x27;string lEARn&#x27;</span><br><span class="line"> </span><br><span class="line">&gt;&gt;&gt; str.find(&#x27;z&#x27;)              #查找字符串，没有则返回-1，有则返回查到到第一个匹配的索引</span><br><span class="line">-1</span><br><span class="line"> </span><br><span class="line">&gt;&gt;&gt; str.find(&#x27;n&#x27;)              #返回查到到第一个匹配的索引</span><br><span class="line">4</span><br><span class="line"> </span><br><span class="line">&gt;&gt;&gt; str.rfind(&#x27;n&#x27;)             #返回的索引是最后一次匹配的</span><br><span class="line">11</span><br><span class="line"> </span><br><span class="line">&gt;&gt;&gt; str.index(&#x27;a&#x27;)             #如果没有匹配则报错 </span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;input&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">ValueError: substring not found</span><br><span class="line">  </span><br><span class="line">&gt;&gt;&gt; str.index(&quot;n&quot;)            #同find类似,返回第一次匹配的索引值</span><br><span class="line">4</span><br><span class="line"> </span><br><span class="line">&gt;&gt;&gt; str.rindex(&quot;n&quot;)           #返回最后一次匹配的索引值</span><br><span class="line">11</span><br><span class="line"> </span><br><span class="line">&gt;&gt;&gt; str.count(&#x27;a&#x27;)            #字符串中匹配的次数</span><br><span class="line">0</span><br><span class="line"> </span><br><span class="line">&gt;&gt;&gt; str.replace(&#x27;EAR&#x27;,&#x27;ear&#x27;)  #匹配替换</span><br><span class="line">&#x27;string learn&#x27;</span><br><span class="line"> </span><br><span class="line">&gt;&gt;&gt; str.replace(&#x27;n&#x27;,&#x27;N&#x27;)</span><br><span class="line">&#x27;striNg lEARN&#x27;</span><br><span class="line"> </span><br><span class="line">&gt;&gt;&gt; str.replace(&#x27;n&#x27;,&#x27;N&#x27;,1)</span><br><span class="line">&#x27;striNg lEARn&#x27;</span><br><span class="line"> </span><br><span class="line">&gt;&gt;&gt; str.strip(&#x27;n&#x27;)          #删除字符串首尾匹配的字符，通常用于默认删除回车符 </span><br><span class="line">   </span><br><span class="line">&#x27;string lEAR&#x27; </span><br><span class="line">   </span><br><span class="line">&gt;&gt;&gt; str.lstrip(&#x27;n&#x27;)        #左匹配 </span><br><span class="line">   </span><br><span class="line">&#x27;string lEARn&#x27; </span><br><span class="line">   </span><br><span class="line">&gt;&gt;&gt; str.rstrip(&#x27;n&#x27;)        #右匹配 </span><br><span class="line">   </span><br><span class="line">&#x27;string lEAR&#x27; </span><br><span class="line"> </span><br><span class="line">&gt;&gt;&gt; str = &quot; tab&quot;</span><br><span class="line"> </span><br><span class="line">&gt;&gt;&gt; str.expandtabs()       #把制表符转为空格</span><br><span class="line">&#x27; tab&#x27;</span><br><span class="line"> </span><br><span class="line">&gt;&gt;&gt; str.expandtabs(2)      #指定空格数</span><br><span class="line">&#x27; tab&#x27;</span><br></pre></td></tr></table></figure>

<h5 id="6-字符串编码与解码"><a href="#6-字符串编码与解码" class="headerlink" title="(6)字符串编码与解码"></a>(6)字符串编码与解码</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; str = &quot;字符串学习&quot;</span><br><span class="line">&gt;&gt;&gt; str</span><br><span class="line">&#x27;\xe5\xad\x97\xe7\xac\xa6\xe4\xb8\xb2\xe5\xad\xa6\xe4\xb9\xa0&#x27;</span><br><span class="line"> </span><br><span class="line">&gt;&gt;&gt; str.decode(&#x27;utf-8&#x27;)                                               #解码过程，将utf-8解码为unicode</span><br><span class="line">u&#x27;\u5b57\u7b26\u4e32\u5b66\u4e60&#x27;</span><br><span class="line"> </span><br><span class="line">&gt;&gt;&gt; str.decode(&quot;utf-8&quot;).encode(&#x27;gbk&#x27;)                                 #编码过程，将unicode编码为gbk</span><br><span class="line">&#x27;\xd7\xd6\xb7\xfb\xb4\xae\xd1\xa7\xcf\xb0&#x27;</span><br><span class="line"> </span><br><span class="line">&gt;&gt;&gt; str.decode(&#x27;utf-8&#x27;).encode(&#x27;utf-8&#x27;)                               #将unicode编码为utf-8 </span><br><span class="line">&#x27;\xe5\xad\x97\xe7\xac\xa6\xe4\xb8\xb2\xe5\xad\xa6\xe4\xb9\xa0&#x27;</span><br></pre></td></tr></table></figure>

<h5 id="7-字符串分割变换"><a href="#7-字符串分割变换" class="headerlink" title="(7)字符串分割变换"></a>(7)字符串分割变换</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; str = &quot;Learn string&quot;</span><br><span class="line"> </span><br><span class="line">&gt;&gt;&gt; &#x27;-&#x27;.join(str) </span><br><span class="line">&#x27;L-e-a-r-n- -s-t-r-i-n-g&#x27;</span><br><span class="line"> </span><br><span class="line">&gt;&gt;&gt; li = [&#x27;Learn&#x27;,&#x27;string&#x27;]</span><br><span class="line"> </span><br><span class="line">&gt;&gt;&gt; &#x27;-&#x27;.join(li)</span><br><span class="line">&#x27;Learn-string&#x27;</span><br><span class="line"> </span><br><span class="line">&gt;&gt;&gt; str.split(&#x27;n&#x27;)</span><br><span class="line">[&#x27;Lear&#x27;, &#x27; stri&#x27;, &#x27;g&#x27;]</span><br><span class="line"> </span><br><span class="line">&gt;&gt;&gt; str.split(&#x27;n&#x27;,1)</span><br><span class="line">[&#x27;Lear&#x27;, &#x27; string&#x27;]</span><br><span class="line"> </span><br><span class="line">&gt;&gt;&gt; str.rsplit(&#x27;n&#x27;)</span><br><span class="line">[&#x27;Lear&#x27;, &#x27; stri&#x27;, &#x27;g&#x27;]</span><br><span class="line"> </span><br><span class="line">&gt;&gt;&gt; str.rsplit(&#x27;n&#x27;,1)</span><br><span class="line">[&#x27;Learn stri&#x27;, &#x27;g&#x27;]</span><br><span class="line"> </span><br><span class="line">&gt;&gt;&gt; str.splitlines()</span><br><span class="line">[&#x27;Learn string&#x27;]</span><br><span class="line"> </span><br><span class="line">&gt;&gt;&gt; str.partition(&#x27;n&#x27;)</span><br><span class="line">(&#x27;Lear&#x27;, &#x27;n&#x27;, &#x27; string&#x27;)</span><br><span class="line"> </span><br><span class="line">&gt;&gt;&gt; str.rpartition(&#x27;n&#x27;)</span><br><span class="line">(&#x27;Learn stri&#x27;, &#x27;n&#x27;, &#x27;g&#x27;)</span><br></pre></td></tr></table></figure>

<h3 id="3-List（列表）"><a href="#3-List（列表）" class="headerlink" title="3.List（列表）"></a>3.List（列表）</h3><p>列表List可以包含不同类型的数据对像，同时它是一个有序的集合”python 集合”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list = [ &#x27;abcd&#x27;, 66 , 6.66, &#x27;lisi&#x27;, 76.2 ]</span><br></pre></td></tr></table></figure>
<p>列表可以包含不同类型对像，也支持嵌套：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = [&#x27;a&#x27;,5867,[&#x27;cc&#x27;,4,],(1,2)]</span><br></pre></td></tr></table></figure>
<h5 id="1-列表增加新的元素"><a href="#1-列表增加新的元素" class="headerlink" title="(1)列表增加新的元素"></a>(1)列表增加新的元素</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">list.append()            #在list 末尾增加一个元素</span><br><span class="line"></span><br><span class="line">list.insert(n,&#x27;4&#x27;)       #在指定位置添加元素，如果指定的下标不存在，那么就是在末尾添加</span><br><span class="line"></span><br><span class="line">list1.extend(list2)      #合并两个list   list2中仍有元素</span><br></pre></td></tr></table></figure>

<h5 id="2-删除list-中的元素"><a href="#2-删除list-中的元素" class="headerlink" title="(2)删除list 中的元素"></a>(2)删除list 中的元素</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">list.pop()                  #删最后一个元素</span><br><span class="line"></span><br><span class="line">list.pop(n)                 #指定下标，删除指定的元素，如果删除一个不存在的元素会报错</span><br><span class="line"></span><br><span class="line">list.remove(xx)             #删除list 里面的一个元素，有多个相同的元素，删除第一个 </span><br><span class="line"></span><br><span class="line">print(list.pop())           #有返回值</span><br><span class="line"></span><br><span class="line">print(list.remove())        #无返回值</span><br><span class="line"></span><br><span class="line">list.clear()                #清空list</span><br><span class="line"></span><br><span class="line">del  list[n]                #删除指定下标对应的元素 </span><br><span class="line"></span><br><span class="line">del list                    #删除整个列表， list删除后无法访问</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="3-查看列表中的值"><a href="#3-查看列表中的值" class="headerlink" title="(3)查看列表中的值"></a>(3)查看列表中的值</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">print(list)                  #遍历列表输出</span><br><span class="line"></span><br><span class="line">print(list[n])               #使用下标索引来访问列表中的值，同样你也可以使用方括号的形式截取字符</span><br><span class="line"></span><br><span class="line">print(list.count(xx))        #查看某个元素在这个列表里的个数，如果改元素不存在，那么返回0</span><br><span class="line"></span><br><span class="line">print(list.index(xx))        #找到这个元素的角标，如果有多个，返回第一个，如果找一个不存在的元素会报错</span><br><span class="line"></span><br><span class="line">````</span><br><span class="line"></span><br><span class="line">##### (4)列表排序和反转</span><br></pre></td></tr></table></figure>
<p>list.reverse()              #将列表反转</p>
<p>list.sort()                 #排序，默认升序</p>
<p>list.sort(reverse&#x3D;True)     #降序排列</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;注：list 中有字符串，数字时不能排序，排序针对同类型</span><br><span class="line"></span><br><span class="line">##### (5)列表操作的函数</span><br></pre></td></tr></table></figure>
<p>len(list)                   #列表元素个数 </p>
<p>max(list)                   #返回列表元素最大值 </p>
<p>min(list)                   #返回列表元素最小值 </p>
<p>list(seq)                   #将元组转换为列表</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 4.Tuple（元组）</span><br><span class="line">元组（tuple）与列表类似，**不同之处在于元组的元素不能修改**。元组写在小括号 () 里，元素之间用逗号隔开，元组中的元素类型也可以不相同。定义元组后，如果想要访问其中的元素，也可像访问列表中的值一样使用索引访问。</span><br></pre></td></tr></table></figure>
<p>tuple &#x3D; (‘hi’, 666, 6.23, ‘python’, 760.2)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">特点:</span><br><span class="line">- 与字符串一样，元组的元素不能修改。</span><br><span class="line">- 元组也可以被索引和切片，方法和列表一样。</span><br><span class="line">- 元组也可以使用+操作符进行拼接。</span><br><span class="line"></span><br><span class="line">### 5.Set(集合)</span><br><span class="line">集合（set）是由一个或数个形态各异的大小整体组成的，构成集合的事物或对象称作元素或是成员。可以使用大括号 &#123; &#125; 或者 set() 函数创建集合。集合里面的元素不能重复(语法上面写了重复的数据也会自动去重)，且元素无序的可变的数据组织形式。</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<blockquote>
<blockquote>
<p>a &#x3D; {1,3,5,8,1,3,5,8}<br>print(a)</p>
</blockquote>
</blockquote>
</blockquote>
<p>{8, 1, 3, 5}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">##### (1)集合添加元素</span><br></pre></td></tr></table></figure>
<blockquote>
<blockquote>
<blockquote>
<p>set1 &#x3D; {1,3}<br>set1.add(2)<br>print(set1)</p>
</blockquote>
</blockquote>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">##### (2)删除集合元素</span><br></pre></td></tr></table></figure>
<p>set.pop()       #pop会从集合中随机删除一个元素<br>set.remove(x)   #删除x元素<br>set.discard(x)  #与remove（）用法相同，但是如果元素不存在，不会报错。<br>set.clear()     #删除所有元素</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">##### (3)集合运算</span><br></pre></td></tr></table></figure>
<p>set1.intersection(set2)     #取set1和set2的交集<br>set1.union(set2)            #取set1和set2的并集<br>set1.difference(set2)       #取set1和set2的差集</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&gt;注意：创建一个空集合必须用 set() 而不是 &#123; &#125;，因为 &#123; &#125; 是用来创建一个空字典。集合没有重复元素，且无序的数据类型,且不能通过索引来引用集合中的元素。</span><br><span class="line">&gt;</span><br><span class="line"></span><br><span class="line">### 6.Dictionary（字典）</span><br><span class="line">字典由多个键和其对应的值构成的键—值对组成，键和值中间以冒号：隔开，项之间用逗号隔开，整个字典是由大括号&#123;&#125;括起来的。这种结构类型通常也被称为映射，或者叫关联数组，也有叫哈希表的。</span><br></pre></td></tr></table></figure>
<p>d &#x3D; { “xx” : ‘666’ , ‘cat’ : ‘999’ , ‘lxf’ : ‘333’ }<br>#字典里面也可以嵌套字典<br>d1 &#x3D; {<br>    “k1”: 18,<br>    “k2”: True,<br>    “k3”: [‘Su’, {<br>        ‘kk1’: ‘vv1’,<br>        ‘kk2’: ‘vv2’,<br>        ‘kk3’: (11, 22),<br>    }<br>           ],<br>    1527: (11, 22, 33, 44)<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">Python字典内置函数：</span><br><span class="line">- cmp(dict1, dict2)：比较两个字典元素。</span><br><span class="line">- len(dict)：计算字典元素个数，即键的总数。</span><br><span class="line">- str(dict)：输出字典可打印的字符串表示。</span><br><span class="line">- type(variable)：返回输入的变量类型，如果变量是字典就返回字典类型。</span><br><span class="line">- dictionary.clear()：删除字典内所有元素</span><br><span class="line">- dictionary.copy()：返回一个字典的浅复制</span><br><span class="line">- dictionary.fromkeys()：创建一个新字典，以序列seq中元素做字典的键，val为字典所有键对应的初始值</span><br><span class="line">- dictionary.get(key, default=None)：返回指定键的值，如果值不在字典中返回default值</span><br><span class="line">- dictionary.has_key(key)：如果键在字典dict里返回true，否则返回false</span><br><span class="line">- dictionary.items()：以列表返回可遍历的(键, 值) 元组数组</span><br><span class="line">- dictionary.keys()：以列表返回一个字典所有的键</span><br><span class="line">- dictionary.setdefault(key, default=None)：和get()类似, 但如果键不已经存在于字典中，将会添加键并将值设为default</span><br><span class="line">- dictionary.update(dict2)：把字典dict2的键/值对更新到dict里</span><br><span class="line">- dictionary.values()：以列表返回字典中的所有值</span><br><span class="line"></span><br><span class="line"># 二.Python运算符。</span><br><span class="line">### 1.算术运算符</span><br><span class="line">运算符 |	描述  |	实例</span><br><span class="line">--|--|--</span><br><span class="line">+	| 加 - 两个对象相加	| a + b 输出结果 30</span><br><span class="line">-	| 减 - 得到负数或是一个数减去另一个数 |	a - b 输出结果 -10</span><br><span class="line">*	|乘 - 两个数相乘或是返回一个被重复若干次的字符串 |	a * b 输出结果 200</span><br><span class="line">/	|除 - x除以y |	b / a 输出结果 2</span><br><span class="line">%	|取模 - 返回除法的余数 |	b % a 输出结果 0</span><br><span class="line">**	|幂 - 返回x的y次幂|	a**b 为10的20次方， 输出结果 100000000000000000000</span><br><span class="line"></span><br><span class="line">### 2.比较运算符</span><br><span class="line">运算符 |	描述 |	实例</span><br><span class="line">--|--|--</span><br><span class="line">==|	等于 - 比较对象是否相等 |	(a == b) 返回 False。</span><br><span class="line">!= |	不等于 - 比较两个对象是否不相等	|(a != b) 返回 true.</span><br><span class="line">&lt;&gt;	| 不等于 - 比较两个对象是否不相等	|(a &lt;&gt; b) 返回 true。这个运算符类似 != 。</span><br><span class="line">&gt;	| 大于 - 返回x是否大于y	|(a &gt; b) 返回 False。</span><br><span class="line">&lt;	| 小于 - 返回x是否小于y。所有比较运算符返回1表示真，返回0表示假。这分别与特殊的变量True和False等价。	|(a &lt; b) 返回 true。</span><br><span class="line">&gt;=	| 大于等于	- 返回x是否大于等于y。	| (a &gt;= b) 返回 False。</span><br><span class="line">&lt;=	| 小于等于 -	返回x是否小于等于y。|	(a &lt;= b) 返回 true。</span><br><span class="line"></span><br><span class="line">### 3.赋值运算符</span><br><span class="line">运算符 |	描述  |	实例</span><br><span class="line">--|--|--</span><br><span class="line">= |	简单的赋值运算符|	c = a + b 将 a + b 的运算结果赋值为 c</span><br><span class="line">+= |	加法赋值运算符|	c += a 等效于 c = c + a</span><br><span class="line">-= |	减法赋值运算符|	c -= a 等效于 c = c - a</span><br><span class="line">*= |	乘法赋值运算符|	c *= a 等效于 c = c * a</span><br><span class="line">/= |	除法赋值运算符|	c /= a 等效于 c = c / a</span><br><span class="line">%= |	取模赋值运算符|	c %= a 等效于 c = c % a</span><br><span class="line">**= |	幂赋值运算符|	c **= a 等效于 c = c ** a</span><br><span class="line">//= |	取整除赋值运算符|	c //= a 等效于 c = c // a</span><br><span class="line"></span><br><span class="line">### 4.逻辑运算符</span><br><span class="line">运算符|	逻辑表达式|	描述|	实例</span><br><span class="line">--|--|--|--</span><br><span class="line">and|	x and y|	布尔&quot;与&quot; - 如果 x 为 False，x and y 返回 False，否则它返回 y 的计算值。|	(a and b) 返回 20。</span><br><span class="line">or|	x or y	|布尔&quot;或&quot;	- 如果 x 是非 0，它返回 x 的值，否则它返回 y 的计算值。	|(a or b) 返回 10。</span><br><span class="line">not|	not x|	布尔&quot;非&quot; - 如果 x 为 True，返回 False 。如果 x 为 False，它返回 True。|	not(a and b) 返回 False</span><br><span class="line"></span><br><span class="line"># 三.Python条件判断</span><br><span class="line">### 1.Python中的if语句</span><br></pre></td></tr></table></figure>
<p>if 判断条件:<br>    执行语句……</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 2.Python中的if..else语句</span><br></pre></td></tr></table></figure>
<p>if 判断条件:<br>    执行语句……<br>else:<br>    执行语句……</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 3.Python中的if..elif语句</span><br></pre></td></tr></table></figure>
<p>if 判断条件1:<br>    执行语句1……<br>elif 判断条件2:<br>    执行语句2……<br>elif 判断条件3:<br>    执行语句3……<br>else:<br>    执行语句4……</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;注:False，None，0，&quot;&quot;，()，[]，&#123;&#125;值在作为布尔表达式时，会被解释器看作假。其他都为真。</span><br><span class="line"></span><br><span class="line"># 四.Python循环结构</span><br><span class="line">### 1. while循环</span><br><span class="line">循环的作用就是让指定的代码重复的执行，while 循环最常用的应用场景就是让执行的代码按照指定的次数重复执行</span><br></pre></td></tr></table></figure>
<p>while 条件():<br>    条件满足时，做的事情<br>    ……</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 2. for循环</span><br><span class="line">for 循环的语法格式如下：</span><br></pre></td></tr></table></figure>
<p>for 迭代变量 in 字符串|列表|元组|字典|集合：<br>    代码块</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 3.循环中的一些中止指令</span><br><span class="line">- break语句:在语句块执行过程中终止循环，并且跳出整个循环。</span><br><span class="line">- continue语句:在语句块执行过程中终止当前循环，跳出该次循环，执行下一次循环。</span><br><span class="line">- pass语句:pass是空语句，是为了保持程序结构的完整性。</span><br><span class="line"></span><br><span class="line"># 五.Python函数</span><br><span class="line">函数最只要的目的就是封装一个功能。函数有两个优点:减少代码重复率。增强代码可阅读性。在调用函数的时候，如果传入的参数数量不对，会报TypeError的错误。如果传入的参数数量是对的，但参数类型不能被函数所接受，也会报TypeError的错误.</span><br><span class="line">### 1.Python定义函数</span><br><span class="line">在Python中，定义一个函数要使用def语句，依次写出函数名、括号、括号中的参数和冒号:，然后，在缩进块中编写函数体，函数的返回值用return语句返回。</span><br></pre></td></tr></table></figure>
<p>def test(x):<br>    if x &gt;&#x3D; 0:<br>        return x<br>    else:<br>        return -x</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 2.Python定义空函数</span><br><span class="line">如果想定义一个什么事也不做的空函数，作用是可以用来作为占位符，比如现在还没想好怎么写函数的代码，就可以先放一个pass，让代码能运行起来。</span><br></pre></td></tr></table></figure>
<p>def test():<br>    pass</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 3.Python参数</span><br><span class="line">函数的参数在调用时，如果没有设置默认参数那么是必传的，调用函数时不传会报错。如果一个函数设置了默认参数,那么在调用的时候就可以不传入该参数,也可以使用默认值调用该函数。</span><br></pre></td></tr></table></figure>
<p>def person(name, gender, age&#x3D;6, city&#x3D;’Beijing’):<br>    print(‘name:’, name)<br>    print(‘gender:’, gender)<br>    print(‘age:’, age)<br>    print(‘city:’, city)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;函数定义时必传参数在前，默认参数在后，否则Python的解释器会报错。</span><br><span class="line"></span><br><span class="line">### 4.Python函数返回值</span><br><span class="line">return语句：程序退出该函数，并返回到函数被调用的地方。return语句返回的值传递给调用程序</span><br><span class="line">Python函数的返回值有两种形式：</span><br><span class="line">##### (1)函数返回一个值</span><br></pre></td></tr></table></figure>
<p>def test(x,y):<br>    return x+y;</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">##### (2)函数返回多个值</span><br><span class="line">函数可以同时返回多个值，但其实就是一个元组。</span><br></pre></td></tr></table></figure>
<p>def test(x,y):<br>    return x,y;</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- 当函数执行到return的时候，就会马上终止函数执行。</span><br><span class="line">- 函数中可以出现多个return，但有且只有一个return会被执行。</span><br><span class="line">- return 后面可以不跟值，return 单独使用等价于return None。</span><br><span class="line"></span><br><span class="line"># 六.Python面向对象之类</span><br><span class="line">### 1.python定义类</span><br><span class="line">面向对象最重要的概念就是类（Class）和实例（Instance）</span><br></pre></td></tr></table></figure>
<p>class Preson(object):<br>    pass</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class后面紧接着是类名，类名通常是大写开头的单词。紧接着是(object)，表示该类是从哪个类继承下来的,通常，如果没有合适的继承类，就使用object类，这是所有类最终都会继承的类。</span><br><span class="line"></span><br><span class="line">### 2.python创建类的实例</span><br><span class="line">创建实例是通过类名+()实现的：</span><br></pre></td></tr></table></figure>
<p>xiaomin&#x3D; Preson()</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 3.python类init方法</span><br><span class="line">所有类都有一个名为 __init__() 的函数，它始终在启动类时执行。使用 __init__() 函数将值赋给对象属性，或者在创建对象时需要执行的其他操作。__init__函数第一个参数永远是实例变量self，表示创建的类实例本身。在创建实例的时候。就可以将属性绑定上去。</span><br></pre></td></tr></table></figure>
<p>class Preson(object):<br>    def <strong>init</strong>(self, name, age):<br>        self.name &#x3D; name<br>        self.age&#x3D; age<br>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;注:和普通的函数相比，在类中定义的函数只有一点不同，就是第一个参数永远是实例变量self，表示创建的类实例本身。并且，调用时，不用传递该参数。除此之外，类的方法和普通函数没有什么区别，所以，你仍然可以用默认参数、可变参数、关键字参数和命名关键字参数。</span><br><span class="line"></span><br><span class="line">### 4.python类的实例方法</span><br><span class="line">通常情况下，在类中定义的普通方法即为类的实例方法，实例方法第一个参数是 self（self 是一种约定习惯） 代表实例本身，当调用某个实例方法时，该实例的对象引用作为第一个参数 self 隐式的传递到方法中。</span><br><span class="line">一种方式调用:实例对象调用。</span><br></pre></td></tr></table></figure><br>class Person:<br>    age &#x3D; 30<br>    # 类构造方法也是实例方法<br>    def <strong>init</strong>(self):<br>        self.name &#x3D; “张三”<br>    # 实例方法<br>    def say(self):<br>        print(‘my name is’+self.name+”age is”+str(self.age))</p>
<h1 id="实例化"><a href="#实例化" class="headerlink" title="实例化"></a>实例化</h1><p>person &#x3D; Person()</p>
<h1 id="调用实例方法"><a href="#调用实例方法" class="headerlink" title="调用实例方法"></a>调用实例方法</h1><p>person.say()</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 5.python类的类方法</span><br><span class="line">类方法必须需要使用 @classmethod 装饰器申明。类的类方法也必须包含一个参数，通常约定为 cls ，cls 代表 类本身（注意不是实例本身，是有区别的），python 会自动将类本身传给 cls，所有这个参数也不需要我们传值，类方法不能获取构造函数定义的变量(类方法可以访问类变量，但不能访问实例变量)，Python中使用比较少。</span><br><span class="line">两种方式调用：类.方法名 和 实例对象调用。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>class Person:<br>    age &#x3D; 30<br>    # 类构造方法也是实例方法<br>    def <strong>init</strong>(self):<br>        self.name &#x3D; “张三”<br>    # 实例方法<br>    @classmethod<br>    def say(cls):<br>        print(‘my age is’+str(cls.age))</p>
<h1 id="实例化-1"><a href="#实例化-1" class="headerlink" title="实例化"></a>实例化</h1><p>person &#x3D; Person()</p>
<h1 id="调用实例方法-1"><a href="#调用实例方法-1" class="headerlink" title="调用实例方法"></a>调用实例方法</h1><p>person.say()</p>
<h1 id="类-方法名调用"><a href="#类-方法名调用" class="headerlink" title="类.方法名调用"></a>类.方法名调用</h1><p>Person.say()</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 6.python类的静态方法</span><br><span class="line">静态方法需要使用 @staticmethod 装饰器声明。类的静态方法和我们自定义的函数基本没什么区别，没有 self，且不能访问类属性。使用静态方法的好处是，不需要定义实例即可使用这个方法，Python中使用比较少，因为可以使用普通函数替代。</span><br><span class="line">有两种调用方式：类.方法名和实例对象调用 。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>class Person:<br>    age &#x3D; 30<br>    # 类构造方法也是实例方法<br>    def <strong>init</strong>(self):<br>        self.name &#x3D; “张三”<br>    # 实例方法<br>    @staticmethod<br>    def say():<br>        print(‘静态方法’)</p>
<h1 id="实例化-2"><a href="#实例化-2" class="headerlink" title="实例化"></a>实例化</h1><p>person &#x3D; Person()</p>
<h1 id="调用实例方法-2"><a href="#调用实例方法-2" class="headerlink" title="调用实例方法"></a>调用实例方法</h1><p>person.say()</p>
<h1 id="类-方法名调用-1"><a href="#类-方法名调用-1" class="headerlink" title="类.方法名调用"></a>类.方法名调用</h1><p>Person.say()</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 7.类属性访问限制</span><br><span class="line">在python中可以给一个类实例绑定很多属性，拿到类的实例以后还是可以自由地修改一个实例的name、age属性的值。如果有些属性不希望被外部访问，就需要对这些属性进行访问限制。Python中没有访问控制的关键字，例如private、protecte和public等。如果要让内部属性不被外部访问，可以把属性的名称前加上两个下划线__，在Python中，实例的变量名如果以__开头，就变成了一个私有变量（private），只有内部可以访问，外部不能访问。</span><br></pre></td></tr></table></figure>
<p>class Preson():<br>    __nikeName &#x3D; “钢蛋”<br>    def <strong>init</strong>(self, name, age):<br>        self.__name &#x3D; name<br>        self.__age &#x3D; age</p>
<pre><code>def say(self):
    print(&#39;%s: %s&#39; % (self.__name, self.__age))
def get_nick_name(self):
    return self.__nikeName
</code></pre>
<p>person&#x3D;Preson(“zhangsan”,30)<br>person.say()</p>
<p>print(person.nikeName)          #无法直接访问属性</p>
<p>print(person.get_nick_name())   #通过方法访问属性</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># 七.Python面向对象之继承</span><br><span class="line">在OOP程序设计中，当我们定义一个class的时候，可以从某个现有的class继承，新的class称为子类（Subclass），而被继承的class称为基类、父类或超类（Base class、Super class）。继承机制经常用于创建和现有类功能类似的新类，又或是新类只需要在现有类基础上添加一些成员（属性和方法），但又不想直接将现有类代码复制给新类。也就是说，通过使用继承这种机制，可以轻松实现类的重复使用。</span><br></pre></td></tr></table></figure>
<p>class Animal:<br>    def eat(self):<br>        print (self.name+”吃”)<br>    def drink(self):<br>        print (self.name+”喝” )<br>class Cat(Animal):<br>    def <strong>init</strong>(self, name):<br>        self.name &#x3D; name</p>
<pre><code>def shout(self):
    print(self.name+&#39;喵喵叫&#39;) 
</code></pre>
<p>class Dog(Animal):</p>
<pre><code>def __init__(self, name):
    self.name = name

def shout(self):
    print(self.name+&#39;汪汪叫&#39;)
</code></pre>
<p>c1 &#x3D; Cat(‘波斯猫’)<br>c1.eat()</p>
<p>c2 &#x3D; Cat(‘橘猫’)<br>c2.drink()</p>
<p>d1 &#x3D; Dog(‘哈士奇’)<br>d1.eat()<br>d1.shout()</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- 在Python中，如果父类和子类都重新定义了构造方法init( )，在进行子类实例化的时候，子类的构造方法不会自动调用父类的构造方法，必须在子类中显示调用。 </span><br><span class="line">- Python的类可以继承多个类，Java和C#中则只能继承一个类 。</span><br><span class="line">- Python的类如果继承了多个类，那么其寻找方法的方式有两种，分别是：深度优先和广度优先 。</span><br><span class="line">- 当类是经典类时，多继承情况下，会按照深度优先方式查找，当类是新式类时，多继承情况下，会按照广度优先方式查找。</span><br><span class="line">&gt;建议大家尽量不要使用多继承。</span><br><span class="line"></span><br><span class="line"># 八.Python 模块和包</span><br><span class="line">### 1.Python中的模块</span><br><span class="line">Python中为了实现某种逻辑将相关联的函数写在同一个文件里，使逻辑更清楚，这就是一个模块，在python中文件以.py 结尾，这个.py文件就可以称之为模块。Python本身就内置了很多非常有用的模块，只要安装完毕，这些模块就可以立刻使用。</span><br><span class="line"></span><br><span class="line">### 2.Python中的包</span><br><span class="line">为了方便管理模块，python 中引入了包的概念,包是由关联的多个模块组成的目录，在每一个包下而都有一个__init__.py文件，这个文件必须存在,否则，Python就把这个目录当成普通目录，而不是一个包，init.py 可以是空文件，也可是有python代码，因为__init__.py本身就是一个模块</span><br><span class="line"></span><br><span class="line">### 3.Python导入其他模块</span><br></pre></td></tr></table></figure>
<p>import modea</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line">from modea import test # 从 modea中导入test方法</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import modea as moa #导入modea并且将命名空间变成moa</span><br></pre></td></tr></table></figure>
<p>第一次导入后就将模块名加载到内存了，后续的import语句仅是对已经加载大内存中的模块对象增加了一次引用，不会重新执行模块内的语句）</p>
<h3 id="4-Python导入不同包下的模块"><a href="#4-Python导入不同包下的模块" class="headerlink" title="4.Python导入不同包下的模块"></a>4.Python导入不同包下的模块</h3><p><img src="/images/fc1a98cb87ec01e545be6c65d4af2ceb.webp" alt="image.png"><br>需要在不同的包里面加int方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import test.mode_b</span><br></pre></td></tr></table></figure>

<h1 id="九-Python-第三方模块包"><a href="#九-Python-第三方模块包" class="headerlink" title="九.Python 第三方模块包"></a>九.Python 第三方模块包</h1><h3 id="1-Python手动引入第三方模块包-源码安装"><a href="#1-Python手动引入第三方模块包-源码安装" class="headerlink" title="1.Python手动引入第三方模块包(源码安装)"></a>1.Python手动引入第三方模块包(源码安装)</h3><p>很多第三方库都是开源的，几乎都可以在<a target="_blank" rel="noopener" href="https://github.com/">github</a> 或者 <a target="_blank" rel="noopener" href="https://pypi.org/">pypi</a>上找到源码。找到源码格式大概都是 zip 、 tar.zip、 tar.bz2格式的压缩包。</p>
<ol>
<li>下载好后将其解压后复制到Python安装目录的：C:\python\Lib\site-packages文件夹里即可:</li>
</ol>
<ul>
<li>windows默认路径在 C:\Python2.7\Lib\site-packages。</li>
<li>Linux默认路径在 &#x2F;usr&#x2F;local&#x2F;lib&#x2F;python2.7&#x2F;dist-packages。</li>
<li>Mac默认路径在 &#x2F;Library&#x2F;Python&#x2F;2.7&#x2F;site-packages。</li>
</ul>
<ol start="2">
<li>打开cmd命令窗口，进入到包所在的目录里，执行：<code>python setup.py install</code> 即可，用此方法安装包时都执行此命令，因为下载的压缩包里有setup.py文件，并且已经进入此包的文件夹中，所以不必写包的名字。</li>
<li>到此就安装成功了。在Python的交互界面用import 包名，验证是否成功安装，不报错即安装成功。<blockquote>
<p>想要卸载这些库也很简单，进入 site-packages，直接删掉库文件就可以了。</p>
</blockquote>
</li>
</ol>
<h3 id="2-Python通过包管理工具-Pip-引入第三方模块包"><a href="#2-Python通过包管理工具-Pip-引入第三方模块包" class="headerlink" title="2.Python通过包管理工具(Pip)引入第三方模块包"></a>2.Python通过包管理工具(Pip)引入第三方模块包</h3><ol>
<li>首先确定你的Python已经安装了pip;(Python3在安装的过程中自动为用户安装了pip)。</li>
<li>确保电脑是联网状态，输入命令<code>pip install + 要安装的模块名称</code>直接安装即可。</li>
<li>使用pip是会自动的为你识别到Python3的安装目录。</li>
</ol>
<p><strong>常用的pip命令：</strong></p>
<ol>
<li>pip自身的升级：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -m pip  install --upgrade pip</span><br></pre></td></tr></table></figure></li>
<li>pip安装&#x2F;卸载包：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip install 包名             （安装）</span><br><span class="line">pip uninstall 包名           （卸载）</span><br></pre></td></tr></table></figure></li>
<li>pip检查哪些软件需要更新：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip list --outdated</span><br></pre></td></tr></table></figure></li>
<li>pip查看已经安装的包：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pip list</span><br><span class="line">或：</span><br><span class="line">pip freeze</span><br></pre></td></tr></table></figure></li>
<li>pip升级软件包：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install --upgrade 包名</span><br></pre></td></tr></table></figure></li>
<li>pip搜索包：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip search &quot;包名&quot;               （包名用双引号括起来）</span><br></pre></td></tr></table></figure></li>
<li>pip查看某个包的详细信息：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip show 包名</span><br></pre></td></tr></table></figure></li>
<li>pip安装指定版本的包：（安装指定版本的包是，可通过使用&#x3D;&#x3D;, &gt;&#x3D;, &lt;&#x3D;, &gt;, &lt;来指定一个版本号）<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pip install 包名==版本号</span><br><span class="line"></span><br><span class="line">例如：</span><br><span class="line">pip install nose==1.3.1</span><br><span class="line">pip install &#x27;Markdown&lt;2.0&#x27;</span><br><span class="line">pip install &#x27;Markdown&gt;2.0,&lt;2.0.3&#x27;</span><br></pre></td></tr></table></figure></li>
<li>查看pip版本：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip.exe -V             （V：大写）</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="3-查看Python包安装的路径"><a href="#3-查看Python包安装的路径" class="headerlink" title="3.查看Python包安装的路径"></a>3.查看Python包安装的路径</h3><p>命令行模式下输入：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import sys</span><br><span class="line">&gt;&gt;&gt; sys.path</span><br><span class="line">[&#x27;&#x27;, &#x27;C:\\Python27\\Lib\\idlelib&#x27;, ...]</span><br></pre></td></tr></table></figure>

<h1 id="十-Python多进程"><a href="#十-Python多进程" class="headerlink" title="十.Python多进程"></a>十.Python多进程</h1><p>进程是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位.</p>
<h3 id="1-启动多进程"><a href="#1-启动多进程" class="headerlink" title="1:启动多进程"></a>1:启动多进程</h3><h5 id="1-multiprocessing启动多进程"><a href="#1-multiprocessing启动多进程" class="headerlink" title="(1)multiprocessing启动多进程."></a>(1)multiprocessing启动多进程.</h5><p>multiprocessing是一个跨平台的python包，因此我们使用该工具包进行多进程的开发.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">from multiprocessing import Process</span><br><span class="line">#子进程需要执行的代码</span><br><span class="line">def run(str):</span><br><span class="line">   while True:</span><br><span class="line">       # os.getpid()获取当前进程id号</span><br><span class="line">       # os.getppid()获取当前进程的父进程id号</span><br><span class="line">       print(&quot; %s--%s--%s&quot;%(str, os.getpid(),os.getppid()))</span><br><span class="line">       sleep(1)</span><br><span class="line">#创建子进程</span><br><span class="line">#target说明进程执行的任务</span><br><span class="line">p = Process(target=run, args=(&quot;test&quot;,))</span><br><span class="line">#启动进程</span><br><span class="line">p.start()</span><br><span class="line"></span><br><span class="line">#父进程的结束不能影响子进程，让父进程等待子进程结束再执行父进程</span><br><span class="line">process.join()</span><br></pre></td></tr></table></figure>
<h5 id="2-利用进程池生成进程"><a href="#2-利用进程池生成进程" class="headerlink" title="(2)利用进程池生成进程"></a>(2)利用进程池生成进程</h5><p>开多进程是为了并发，通常有几个cpu核心就开几个进程，但是进程开多了会影响效率，主要体现在切换的开销，所以引入进程池限制进程的数量。进程池内部维护一个进程序列，当使用时，则去进程池中获取一个进程，初始化一个Pool时，可以指定一个最大进程数，如果超过这个数，那么请求就会等待，直到池中有进程结束，才会创建新的进程来执行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">rom multiprocessing import Pool</span><br><span class="line">mport os, time, random</span><br><span class="line">ef run(name):</span><br><span class="line">   print(&quot;子进程%d启动--%s&quot; % (name, os.getpid()))</span><br><span class="line">f __name__ == &quot;__main__&quot;:</span><br><span class="line">   #创建多个进程</span><br><span class="line">   #进程池</span><br><span class="line">   #表示可以同时执行的进程数量</span><br><span class="line">   #Pool默认大小是CPU核心数</span><br><span class="line">   pp = Pool(2)</span><br><span class="line">   for i in range(3):</span><br><span class="line">       #创建进程，放入进程池同意管理</span><br><span class="line">       pp.apply_async(run,args=(i,))</span><br><span class="line"></span><br><span class="line">   #在调用join之前必须先调用close,调用close之后就不能再继续添加新的进程了</span><br><span class="line">   pp.close()</span><br><span class="line">   #进程池对象调用join，会等待进程池中所有的子进程结束完毕再去执行父进程</span><br><span class="line">   pp.join()</span><br></pre></td></tr></table></figure>

<h3 id="2-多进程之间的通信"><a href="#2-多进程之间的通信" class="headerlink" title="2.多进程之间的通信"></a>2.多进程之间的通信</h3><p>进程彼此之间互相隔离，要实现进程间通信（IPC），multiprocessing模块支持两种形式：队列和管道，这两种方式都是使用消息传递的。</p>
<h5 id="1-使用进程队列queue实现多进程之间的通信"><a href="#1-使用进程队列queue实现多进程之间的通信" class="headerlink" title="(1)使用进程队列queue实现多进程之间的通信"></a>(1)使用进程队列queue实现多进程之间的通信</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">from multiprocessing import Process, Queue</span><br><span class="line">import os, time</span><br><span class="line"></span><br><span class="line">def write(q):</span><br><span class="line">    print(&quot;启动写子进程%s&quot; % (os.getpid()))</span><br><span class="line">    q.put(&quot;A&quot;)</span><br><span class="line">    print(&quot;结束写子进程%s&quot; % (os.getpid()))</span><br><span class="line"></span><br><span class="line">def read(q):</span><br><span class="line">    print(&quot;启动读子进程%s&quot; % (os.getpid()))</span><br><span class="line">    while True:</span><br><span class="line">        value = q.get(True)</span><br><span class="line">        print(&quot;value = &quot; + value)</span><br><span class="line">    print(&quot;结束读子进程%s&quot; % (os.getpid()))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    #父进程创建队列，并传递给子进程</span><br><span class="line">    q = Queue()</span><br><span class="line">    pw = Process(target=write, args=(q,))</span><br><span class="line">    pr = Process(target=read, args=(q,))</span><br><span class="line"></span><br><span class="line">    pw.start()</span><br><span class="line">    pr.start()</span><br><span class="line"></span><br><span class="line">    pw.join()</span><br><span class="line">    #pr进程里是个死循环，无法等待其结束，只能强行结束</span><br><span class="line">    pr.terminate()</span><br><span class="line"></span><br><span class="line">    print(&quot;父进程结束&quot;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="2-使用进程队列Manager-Queue-实现多进程之间的通信"><a href="#2-使用进程队列Manager-Queue-实现多进程之间的通信" class="headerlink" title="(2)使用进程队列Manager().Queue()实现多进程之间的通信"></a>(2)使用进程队列Manager().Queue()实现多进程之间的通信</h5><p>如果使用进程池pool创建进程的话，就需要使用Manager().Queue()</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">from multiprocessing import Manager, Process, Pool</span><br><span class="line">import threading</span><br><span class="line">import random, time,os</span><br><span class="line"></span><br><span class="line"># queue，实现多进程之间的数据传递，其实就是个消息队列</span><br><span class="line"></span><br><span class="line">def write(q):</span><br><span class="line">    print(&#x27;---write thread is %s&#x27; % os.getpid())</span><br><span class="line">    for value in [&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;]:</span><br><span class="line">        print(&quot;put %s to queue&quot; % value)</span><br><span class="line">        q.put(value)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def read(q):</span><br><span class="line">    print(&#x27;---read thread is %s&#x27; % os.getpid())</span><br><span class="line">    for i in range(q.qsize()):</span><br><span class="line">        print(&quot;Get value is %s&quot; % q.get(True))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if &#x27;__main__&#x27; == __name__:</span><br><span class="line">    print(&#x27;---main thread is %s&#x27; % os.getpid())</span><br><span class="line">    q = Manager().Queue()</span><br><span class="line">    po = Pool()</span><br><span class="line">    po.apply(write, args=(q,))</span><br><span class="line">    po.apply(read, args=(q,))</span><br><span class="line">    po.close()</span><br><span class="line">    po.join()</span><br><span class="line">    print(&#x27;---end---&#x27;)</span><br></pre></td></tr></table></figure>

<h1 id="十一-Python多线程"><a href="#十一-Python多线程" class="headerlink" title="十一.Python多线程"></a>十一.Python多线程</h1><h3 id="1-线程的概念"><a href="#1-线程的概念" class="headerlink" title="1.线程的概念"></a>1.线程的概念</h3><p>在一个进程的内部，要同时干多件事，就需要同时运行多个“子任务”，我们把进程内的这些“子任务”叫做线程。这些线程的运行顺序是不确定的、随机的、不可预测的。Python中提供了两个模块帮助实现多线程:</p>
<ol>
<li>_thread模块属于低级模块。</li>
<li>threading模块高级模块，对_thread进行了封装</li>
</ol>
<h3 id="2-Python启动线程"><a href="#2-Python启动线程" class="headerlink" title="2.Python启动线程"></a>2.Python启动线程</h3><p>在线程里面setDaemon（）和join（）方法都是常用的启动线程方式.</p>
<ul>
<li>join ()方法：主线程A中，创建了子线程B，并且在主线程A中调用了B.join()，那么，主线程A会在调用的地方等待，直到子线程B完成操作后， 才可以接着往下执行，那么在调用这个线程时可以使用被调用线程的join方法。join([timeout]) 里面的参数时可选的，代表线程运行的最大时间，即如果超过这个时间，不管这个此线程有没有执行完毕都会被回收，然后主线程或函数都会接着执行的，如果线程执行时间小于参数表示的 时间，则接着执行，不用一定要等待到参数表示的时间。</li>
<li>setDaemon()方法。主线程A中，创建了子线程B，并且在主线程A中调用了B.setDaemon(),这个的意思是，把主线程A设置为守护线程，这时候，要是主线程A执行结束了，就不管子线程B是否完成，一并和主线程A退出.这就是setDaemon方法的含义，这基本和join是相反的。此外，还有个要特别注意的：必须在start()方法调用之前设置，如果不设置为守护线程，程序会被无限挂起，只有等待了所有线程结束它才结束。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">import threading,time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def run(num):</span><br><span class="line">    print(&quot;子线程(%s)开始&quot; % (threading.current_thread().name))</span><br><span class="line"></span><br><span class="line">    #实现线程的功能</span><br><span class="line">    time.sleep(2)</span><br><span class="line">    print(&quot;打印&quot;, num)</span><br><span class="line">    time.sleep(2)</span><br><span class="line"></span><br><span class="line">    print(&quot;子线程(%s)结束&quot; % (threading.current_thread().name))</span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    #任何进程默认就会启动一个线程，称为主线程，主线程可以启动新的子线程</span><br><span class="line">    #current_thread()：返回返回当前线程的实例</span><br><span class="line">    print(&quot;主线程(%s)启动&quot; % (threading.current_thread().name))</span><br><span class="line"></span><br><span class="line">    #创建子线程                     线程的名称</span><br><span class="line">    t = threading.Thread(target=run, name=&quot;runThread&quot;, args=(1,))</span><br><span class="line">    t.start()</span><br><span class="line">    #t.setDaemon(True)#设置为后台线程，这里默认是Fal#se，设置为True之后则主线程不用等待子线程</span><br><span class="line">    #等待线程结束</span><br><span class="line">    t.join()</span><br><span class="line"></span><br><span class="line">    print(&quot;主线程(%s)结束&quot; % (threading.current_thread().name))</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="3-Python多线程共享数据"><a href="#3-Python多线程共享数据" class="headerlink" title="3.Python多线程共享数据"></a>3.Python多线程共享数据</h3><p>多线程和多进程最大的不同在于，多进程中，同一个变量，各自有一份拷贝存在每个进程中，互不影响。而多线程中，所有变量都由所有线程共享。所以，任何一个变量都可以被任意一个线程修改，因此，线程之间共享数据最大的危险在于多个线程同时修改一个变量，容易把内容改乱了。</p>
<h5 id="1-多线程造成数据混乱"><a href="#1-多线程造成数据混乱" class="headerlink" title="(1)多线程造成数据混乱"></a>(1)多线程造成数据混乱</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import threading</span><br><span class="line">num = 0</span><br><span class="line"></span><br><span class="line">def run(n):</span><br><span class="line">    global num</span><br><span class="line">    for i in range(10000000):</span><br><span class="line">        num = num + n    </span><br><span class="line">        num = num - n    </span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    t1 = threading.Thread(target=run, args=(6,))</span><br><span class="line">    t2 = threading.Thread(target=run, args=(9,))</span><br><span class="line">    t1.start()</span><br><span class="line">    t2.start()</span><br><span class="line">    t1.join()</span><br><span class="line">    t2.join()</span><br><span class="line"></span><br><span class="line">    print(&quot;num =&quot;,num)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="2-线程锁解决多线程数据混乱"><a href="#2-线程锁解决多线程数据混乱" class="headerlink" title="(2)线程锁解决多线程数据混乱"></a>(2)线程锁解决多线程数据混乱</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#锁对象</span><br><span class="line">lock = threading.Lock()</span><br><span class="line"></span><br><span class="line">num = 0</span><br><span class="line">def run(n):</span><br><span class="line">    global num</span><br><span class="line"></span><br><span class="line">    for i in range(10000000):</span><br><span class="line">        # 锁</span><br><span class="line">        # 确保了这段代码只能由一个线程从头到尾的完整执行</span><br><span class="line">        # 阻止了多线程的并发执行，包含锁的某段代码实际上只能以单线程模式执行，所以效率大大滴降低了</span><br><span class="line">        # 由于可以存在多个锁，不同线程持有不同的锁，并试图获取其他的锁，可能造成死锁，导致多个线程挂起。只能靠操作系统强制终止</span><br><span class="line">        &#x27;&#x27;&#x27;</span><br><span class="line">        lock.acquire()</span><br><span class="line">        try:</span><br><span class="line">            num = num + n    #  15 = 9 + 6</span><br><span class="line">            num = num - n    #  9</span><br><span class="line">        finally:</span><br><span class="line">            #修改完一定要释放锁</span><br><span class="line">            lock.release()</span><br><span class="line">        &#x27;&#x27;&#x27;</span><br><span class="line"></span><br><span class="line">        #与上面代码功能相同，with lock可以自动上锁与解锁</span><br><span class="line">        with lock:</span><br><span class="line">            num = num + n</span><br><span class="line">            num = num - n</span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    t1 = threading.Thread(target=run, args=(6,))</span><br><span class="line">    t2 = threading.Thread(target=run, args=(9,))</span><br><span class="line">    t1.start()</span><br><span class="line">    t2.start()</span><br><span class="line">    t1.join()</span><br><span class="line">    t2.join()</span><br><span class="line">    print(&quot;num =&quot;,num)</span><br></pre></td></tr></table></figure>
<h5 id="3-ThreadLocal解决多线程数据混乱"><a href="#3-ThreadLocal解决多线程数据混乱" class="headerlink" title="(3)ThreadLocal解决多线程数据混乱"></a>(3)ThreadLocal解决多线程数据混乱</h5><p>ThreadLocal 主要用来为各个线程管理其内部数据，它本身是一个全局变量，但是每个线程却可以利用它来保存属于自己的私有数据，这些私有数据对其他线程也是不可见的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">import threading</span><br><span class="line"></span><br><span class="line">num = 0</span><br><span class="line">#创建一个全局的ThreadLocal对象</span><br><span class="line">#每个线程有独立的存储空间</span><br><span class="line">#每个线程对ThreadLocal对象都可以读写，但是互不影响</span><br><span class="line">local = threading.local()</span><br><span class="line"></span><br><span class="line">def run(x, n):</span><br><span class="line">    x = x + n</span><br><span class="line">    x = x - n</span><br><span class="line"></span><br><span class="line">def func(n):</span><br><span class="line">    #每个线程都有local.x，就是线程的局部变量</span><br><span class="line">    local.x = num</span><br><span class="line">    for i in range(1000000):</span><br><span class="line">        run(local.x, n)</span><br><span class="line">    print(&quot;%s-%d&quot;%(threading.current_thread().name, local.x))</span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    t1 = threading.Thread(target=func, args=(6,))</span><br><span class="line">    t2 = threading.Thread(target=func, args=(9,))</span><br><span class="line">    t1.start()</span><br><span class="line">    t2.start()</span><br><span class="line">    t1.join()</span><br><span class="line">    t2.join()</span><br><span class="line"></span><br><span class="line">    print(&quot;num =&quot;,num)</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="十二-Python文件操作"><a href="#十二-Python文件操作" class="headerlink" title="十二.Python文件操作"></a>十二.Python文件操作</h1><h3 id="1-Python读取文件"><a href="#1-Python读取文件" class="headerlink" title="1.Python读取文件"></a>1.Python读取文件</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">f = open(&#x27;file.txt&#x27;,&#x27;r&#x27;,encoding=&#x27;utf-8&#x27;)</span><br><span class="line">data = f.read()#一次性读取文件的全部内容</span><br><span class="line">#f.readline(n)#最多读取n个字节的内容</span><br><span class="line">#f.readlines()#一次读取文件的全部内容，并按行返回list</span><br><span class="line">print(data)</span><br></pre></td></tr></table></figure>
<p>权限说明:</p>
<table>
<thead>
<tr>
<th>符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>r</td>
<td>以只读方式打开文件。文件的指针将会放在文件的开头。这是默认模式。</td>
</tr>
<tr>
<td>rb</td>
<td>以二进制格式打开一个文件用于只读。文件指针将会放在文件的开头。这是默认模式。</td>
</tr>
<tr>
<td>r+</td>
<td>打开一个文件用于读写。文件指针将会放在文件的开头。</td>
</tr>
<tr>
<td>rb+</td>
<td>以二进制格式打开一个文件用于读写。文件指针将会放在文件的开头。</td>
</tr>
<tr>
<td>w</td>
<td>打开一个文件只用于写入。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。</td>
</tr>
<tr>
<td>wb</td>
<td>以二进制格式打开一个文件只用于写入。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。</td>
</tr>
<tr>
<td>w+</td>
<td>打开一个文件用于读写。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。</td>
</tr>
<tr>
<td>wb+</td>
<td>以二进制格式打开一个文件用于读写。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。</td>
</tr>
<tr>
<td>a</td>
<td>打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。</td>
</tr>
<tr>
<td>ab</td>
<td>以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。</td>
</tr>
<tr>
<td>a+</td>
<td>打开一个文件用于读写。如果该文件已存在，文件指针将会放在文件的结尾。文件打开时会是追加模式。如果该文件不存在，创建新文件用于读写。</td>
</tr>
<tr>
<td>ab+</td>
<td>以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。如果该文件不存在，创建新文件用于读写。</td>
</tr>
</tbody></table>
<h3 id="2-Python写入文件"><a href="#2-Python写入文件" class="headerlink" title="2.Python写入文件"></a>2.Python写入文件</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#覆盖内容</span><br><span class="line">f = open(&#x27;file.txt2&#x27;,&#x27;w&#x27;,encoding=&#x27;utf-8&#x27;) #文件句柄,使用w时事实上是创建了一个新文件，如果源文件存在，会覆盖</span><br><span class="line">f.write(&quot;新文件&quot;) </span><br><span class="line">#追加内容</span><br><span class="line">f = open(&#x27;file.txt2&#x27;,&#x27;a&#x27;,encoding=&#x27;utf-8&#x27;) #文件句柄</span><br><span class="line">f.write(&quot;See you,tomorrow!&quot;)</span><br><span class="line">f_new.close()#关闭文件流</span><br></pre></td></tr></table></figure>


<h3 id="3-with-open方法打开文件"><a href="#3-with-open方法打开文件" class="headerlink" title="3.with open方法打开文件"></a>3.with open方法打开文件</h3><p>因实际开发过程中，打开文件很容易忘记关闭文件，造成内存不能释放，所以一般可以选择使用with open方法打开文件:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">with open(&quot;test.txt&quot;,&quot;r&quot;,encoding=&quot;utf-8&quot;) as f:</span><br><span class="line">    print(f.read())</span><br></pre></td></tr></table></figure></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://lxlfpeng.github.io">peng</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://lxlfpeng.github.io/2016/12/22/Python%E8%AF%AD%E6%B3%95%E6%80%BB%E7%BB%93/">https://lxlfpeng.github.io/2016/12/22/Python%E8%AF%AD%E6%B3%95%E6%80%BB%E7%BB%93/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://lxlfpeng.github.io" target="_blank">鹏哥的Blog</a>！</span></div></div><div class="tag_share"><div class="post-share"><div class="social-share" data-image="/images/b84e6e02bfdc6e8abdd155bfb6a23c61.webp" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2016/12/31/Windows%E5%8F%8ALinux%E5%B9%B3%E5%8F%B0%E5%AE%89%E8%A3%85AMP(Apache+MySQL+PHP%20)/" title="Windows及Linux平台安装AMP(Apache+MySQL+PHP )"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Windows及Linux平台安装AMP(Apache+MySQL+PHP )</div></div><div class="info-2"><div class="info-item-1">一. linux平台安装AMP安装apache1. 查看是否安装了apache服务器(apache服务的软件包名称叫做httpd)。1231、可以通过 apachectl -v 或者httpd -v 查看apache是否安装，如果安装了的话会显示版本号；2、如果通过rpm包安装的话可以用  rpm -q  httpd 查看，如果安装的的话会显示包的名称；  2. 通过yum安装Apache服务程序。1yum install httpd -y 3. 安装完成后，启用并启动Apache服务。12sudo systemctl enable httpdsudo systemctl start httpd 4. 检查Apache服务的状态和版本。1sudo systemctl status httpd  5. 查看Apache监听的端口。1netstat -an|grep :80 可以看到，80端口处于监听状态，说明服务已经启动，为使客户端能访问Apache服务器的80端口，要打开防火墙的TCP80端口。 1iptables -I INPUT -p tcp --dport 80 -j...</div></div></div></a><a class="pagination-related" href="/2016/12/11/Java-%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B9%8B%E9%94%81/" title="Java-高级特性之锁"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Java-高级特性之锁</div></div><div class="info-2"><div class="info-item-1">Java多线程开发中，如果涉及到共享资源操作场景，那就必不可少要和Java锁打交道。 Java中的锁机制主要分为Lock和Synchronized，本文主要分析Java锁机制的使用和实现原理，按照Java锁使用、JDK中锁实现、系统层锁实现的顺序来进行分析，话不多说，let’s go~ Java锁使用在Lock接口出现之前，Java程序是靠synchronized关键字实现锁功能的，而JavaSE 5之后，并发包中新增了Lock接口（以及相关实现类）用来实现锁功能，它提供了与synchronized关键字类似的同步功能，只是在使用时需要显式地获取和释放锁。虽然它缺少了（通过synchronized块或者方法）隐式获取释放锁的便捷性，但是却拥有了锁获取与释放的可操作性、可中断的获取锁以及超时获取锁等多种synchronized关键字所不具备的同步特性。 Java锁使用示例： Lock lock &#x3D; new ReentrantLock();lock.lock();try {&#x2F;&#x2F; ..} finally...</div></div></div></a></nav><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="giscus-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/images/about_avatar.webp" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">peng</div><div class="author-info-description">过往不恋 未来不迎 当下不负</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">127</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">59</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">24</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/lxlfpeng"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/lxlfpeng" target="_blank" title="Github"><i class="fab fa-github" style="color: #4a7dbe;"></i></a><a class="social-icon" href="mailto:565289282@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎来到我的博客!</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80-python%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E3%80%82"><span class="toc-number">1.</span> <span class="toc-text">一.python的基本数据类型。</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Number%EF%BC%88%E6%95%B0%E5%AD%97%EF%BC%89"><span class="toc-number">1.0.1.</span> <span class="toc-text">1.Number（数字）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-String%EF%BC%88%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%89"><span class="toc-number">1.0.2.</span> <span class="toc-text">1.String（字符串）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%88%87%E7%89%87"><span class="toc-number">1.0.2.0.1.</span> <span class="toc-text">(1)字符串切片</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BF%9E%E6%8E%A5"><span class="toc-number">1.0.2.0.2.</span> <span class="toc-text">(2)字符串连接</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%A7%E5%B0%8F%E5%86%99%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.0.2.0.3.</span> <span class="toc-text">(3)字符串大小写转换</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9D%A1%E4%BB%B6%E5%88%A4%E6%96%AD"><span class="toc-number">1.0.2.0.4.</span> <span class="toc-text">(4)字符串条件判断</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%90%9C%E7%B4%A2%E5%AE%9A%E4%BD%8D%E4%B8%8E%E6%9B%BF%E6%8D%A2"><span class="toc-number">1.0.2.0.5.</span> <span class="toc-text">(5)字符串搜索定位与替换</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%BC%96%E7%A0%81%E4%B8%8E%E8%A7%A3%E7%A0%81"><span class="toc-number">1.0.2.0.6.</span> <span class="toc-text">(6)字符串编码与解码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%88%86%E5%89%B2%E5%8F%98%E6%8D%A2"><span class="toc-number">1.0.2.0.7.</span> <span class="toc-text">(7)字符串分割变换</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-List%EF%BC%88%E5%88%97%E8%A1%A8%EF%BC%89"><span class="toc-number">1.0.3.</span> <span class="toc-text">3.List（列表）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%88%97%E8%A1%A8%E5%A2%9E%E5%8A%A0%E6%96%B0%E7%9A%84%E5%85%83%E7%B4%A0"><span class="toc-number">1.0.3.0.1.</span> <span class="toc-text">(1)列表增加新的元素</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%88%A0%E9%99%A4list-%E4%B8%AD%E7%9A%84%E5%85%83%E7%B4%A0"><span class="toc-number">1.0.3.0.2.</span> <span class="toc-text">(2)删除list 中的元素</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E6%9F%A5%E7%9C%8B%E5%88%97%E8%A1%A8%E4%B8%AD%E7%9A%84%E5%80%BC"><span class="toc-number">1.0.3.0.3.</span> <span class="toc-text">(3)查看列表中的值</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B%E5%8C%96"><span class="toc-number">2.</span> <span class="toc-text">实例化</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%B0%83%E7%94%A8%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95"><span class="toc-number">3.</span> <span class="toc-text">调用实例方法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B%E5%8C%96-1"><span class="toc-number">4.</span> <span class="toc-text">实例化</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%B0%83%E7%94%A8%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95-1"><span class="toc-number">5.</span> <span class="toc-text">调用实例方法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B1%BB-%E6%96%B9%E6%B3%95%E5%90%8D%E8%B0%83%E7%94%A8"><span class="toc-number">6.</span> <span class="toc-text">类.方法名调用</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B%E5%8C%96-2"><span class="toc-number">7.</span> <span class="toc-text">实例化</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%B0%83%E7%94%A8%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95-2"><span class="toc-number">8.</span> <span class="toc-text">调用实例方法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B1%BB-%E6%96%B9%E6%B3%95%E5%90%8D%E8%B0%83%E7%94%A8-1"><span class="toc-number">9.</span> <span class="toc-text">类.方法名调用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-Python%E5%AF%BC%E5%85%A5%E4%B8%8D%E5%90%8C%E5%8C%85%E4%B8%8B%E7%9A%84%E6%A8%A1%E5%9D%97"><span class="toc-number">9.0.1.</span> <span class="toc-text">4.Python导入不同包下的模块</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B9%9D-Python-%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A8%A1%E5%9D%97%E5%8C%85"><span class="toc-number">10.</span> <span class="toc-text">九.Python 第三方模块包</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Python%E6%89%8B%E5%8A%A8%E5%BC%95%E5%85%A5%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A8%A1%E5%9D%97%E5%8C%85-%E6%BA%90%E7%A0%81%E5%AE%89%E8%A3%85"><span class="toc-number">10.0.1.</span> <span class="toc-text">1.Python手动引入第三方模块包(源码安装)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Python%E9%80%9A%E8%BF%87%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7-Pip-%E5%BC%95%E5%85%A5%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A8%A1%E5%9D%97%E5%8C%85"><span class="toc-number">10.0.2.</span> <span class="toc-text">2.Python通过包管理工具(Pip)引入第三方模块包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%9F%A5%E7%9C%8BPython%E5%8C%85%E5%AE%89%E8%A3%85%E7%9A%84%E8%B7%AF%E5%BE%84"><span class="toc-number">10.0.3.</span> <span class="toc-text">3.查看Python包安装的路径</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81-Python%E5%A4%9A%E8%BF%9B%E7%A8%8B"><span class="toc-number">11.</span> <span class="toc-text">十.Python多进程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%90%AF%E5%8A%A8%E5%A4%9A%E8%BF%9B%E7%A8%8B"><span class="toc-number">11.0.1.</span> <span class="toc-text">1:启动多进程</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-multiprocessing%E5%90%AF%E5%8A%A8%E5%A4%9A%E8%BF%9B%E7%A8%8B"><span class="toc-number">11.0.1.0.1.</span> <span class="toc-text">(1)multiprocessing启动多进程.</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%88%A9%E7%94%A8%E8%BF%9B%E7%A8%8B%E6%B1%A0%E7%94%9F%E6%88%90%E8%BF%9B%E7%A8%8B"><span class="toc-number">11.0.1.0.2.</span> <span class="toc-text">(2)利用进程池生成进程</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%A4%9A%E8%BF%9B%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1"><span class="toc-number">11.0.2.</span> <span class="toc-text">2.多进程之间的通信</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E4%BD%BF%E7%94%A8%E8%BF%9B%E7%A8%8B%E9%98%9F%E5%88%97queue%E5%AE%9E%E7%8E%B0%E5%A4%9A%E8%BF%9B%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1"><span class="toc-number">11.0.2.0.1.</span> <span class="toc-text">(1)使用进程队列queue实现多进程之间的通信</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E4%BD%BF%E7%94%A8%E8%BF%9B%E7%A8%8B%E9%98%9F%E5%88%97Manager-Queue-%E5%AE%9E%E7%8E%B0%E5%A4%9A%E8%BF%9B%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1"><span class="toc-number">11.0.2.0.2.</span> <span class="toc-text">(2)使用进程队列Manager().Queue()实现多进程之间的通信</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81%E4%B8%80-Python%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-number">12.</span> <span class="toc-text">十一.Python多线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">12.0.1.</span> <span class="toc-text">1.线程的概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Python%E5%90%AF%E5%8A%A8%E7%BA%BF%E7%A8%8B"><span class="toc-number">12.0.2.</span> <span class="toc-text">2.Python启动线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-Python%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE"><span class="toc-number">12.0.3.</span> <span class="toc-text">3.Python多线程共享数据</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%80%A0%E6%88%90%E6%95%B0%E6%8D%AE%E6%B7%B7%E4%B9%B1"><span class="toc-number">12.0.3.0.1.</span> <span class="toc-text">(1)多线程造成数据混乱</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E7%BA%BF%E7%A8%8B%E9%94%81%E8%A7%A3%E5%86%B3%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%95%B0%E6%8D%AE%E6%B7%B7%E4%B9%B1"><span class="toc-number">12.0.3.0.2.</span> <span class="toc-text">(2)线程锁解决多线程数据混乱</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-ThreadLocal%E8%A7%A3%E5%86%B3%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%95%B0%E6%8D%AE%E6%B7%B7%E4%B9%B1"><span class="toc-number">12.0.3.0.3.</span> <span class="toc-text">(3)ThreadLocal解决多线程数据混乱</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81%E4%BA%8C-Python%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C"><span class="toc-number">13.</span> <span class="toc-text">十二.Python文件操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Python%E8%AF%BB%E5%8F%96%E6%96%87%E4%BB%B6"><span class="toc-number">13.0.1.</span> <span class="toc-text">1.Python读取文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Python%E5%86%99%E5%85%A5%E6%96%87%E4%BB%B6"><span class="toc-number">13.0.2.</span> <span class="toc-text">2.Python写入文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-with-open%E6%96%B9%E6%B3%95%E6%89%93%E5%BC%80%E6%96%87%E4%BB%B6"><span class="toc-number">13.0.3.</span> <span class="toc-text">3.with open方法打开文件</span></a></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer" style="background-image: url(/images/b84e6e02bfdc6e8abdd155bfb6a23c61.webp);"><div id="footer-wrap"><div class="copyright">&copy;2015 - 2025 By peng</div><div class="footer_custom_text"> <a target="_blank" rel="nofollow noopener"><span>千里之行</span></a> <i class="iconfont icon-love"></i> <a target="_blank" rel="nofollow noopener"><span>始于足下</span></a> </div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.isShuoshuo
  const option = null

  const getGiscusTheme = theme => theme === 'dark' ? 'dark' : 'light'

  const createScriptElement = config => {
    const ele = document.createElement('script')
    Object.entries(config).forEach(([key, value]) => {
      ele.setAttribute(key, value)
    })
    return ele
  }

  const loadGiscus = (el = document, key) => {
    const mappingConfig = isShuoshuo
      ? { 'data-mapping': 'specific', 'data-term': key }
      : { 'data-mapping': (option && option['data-mapping']) || 'pathname' }

    const giscusConfig = {
      src: 'https://giscus.app/client.js',
      'data-repo': 'lxlfpeng/blog_comments',
      'data-repo-id': 'R_kgDONYoexA',
      'data-category-id': 'DIC_kwDONYoexM4Ck4JQ',
      'data-theme': getGiscusTheme(document.documentElement.getAttribute('data-theme')),
      'data-reactions-enabled': '1',
      crossorigin: 'anonymous',
      async: true,
      ...option,
      ...mappingConfig
    }

    const scriptElement = createScriptElement(giscusConfig)

    el.querySelector('#giscus-wrap').appendChild(scriptElement)

    if (isShuoshuo) {
      window.shuoshuoComment.destroyGiscus = () => {
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }
  }

  const changeGiscusTheme = theme => {
    const iframe = document.querySelector('#giscus-wrap iframe')
    if (iframe) {
      const message = {
        giscus: {
          setConfig: {
            theme: getGiscusTheme(theme)
          }
        }
      }
      iframe.contentWindow.postMessage(message, 'https://giscus.app')
    }
  }

  btf.addGlobalFn('themeChange', changeGiscusTheme, 'giscus')

  if (isShuoshuo) {
    'Giscus' === 'Giscus'
      ? window.shuoshuoComment = { loadComment: loadGiscus }
      : window.loadOtherComment = loadGiscus
    return
  }

  if ('Giscus' === 'Giscus' || !false) {
    if (false) btf.loadComment(document.getElementById('giscus-wrap'), loadGiscus)
    else loadGiscus()
  } else {
    window.loadOtherComment = loadGiscus
  }
})()</script></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="false"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>