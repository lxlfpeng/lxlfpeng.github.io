<!DOCTYPE html><html lang="zh-CN" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>面向对象设计模式理论总结-Java版 | 鹏哥的Blog</title><meta name="author" content="peng"><meta name="copyright" content="peng"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#0d0d0d"><meta name="description" content="一. 什么是UML类图?UML类图是一种结构图，用于描述一个系统的静态结构。类图以反映类结构和类之间关系为目的，用以描述软件系统的结构，是一种静态建模方法。类图中的类，与面向对象语言中的类的概念是对应的，因此又称统一建模语言，类图是使用频率最高的UML图之一。 二. 类图中的表示方式1.类在类图中的表示方式在UML类图中，类使用包含类名、属性(field) 和方法(method) 且带有分割线的矩">
<meta property="og:type" content="article">
<meta property="og:title" content="面向对象设计模式理论总结-Java版">
<meta property="og:url" content="https://lxlfpeng.github.io/2017/05/19/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%90%86%E8%AE%BA%E6%80%BB%E7%BB%93-Java%E7%89%88/index.html">
<meta property="og:site_name" content="鹏哥的Blog">
<meta property="og:description" content="一. 什么是UML类图?UML类图是一种结构图，用于描述一个系统的静态结构。类图以反映类结构和类之间关系为目的，用以描述软件系统的结构，是一种静态建模方法。类图中的类，与面向对象语言中的类的概念是对应的，因此又称统一建模语言，类图是使用频率最高的UML图之一。 二. 类图中的表示方式1.类在类图中的表示方式在UML类图中，类使用包含类名、属性(field) 和方法(method) 且带有分割线的矩">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://lxlfpeng.github.io/images/311e68177cc2ec89577840663136ab3e.webp">
<meta property="article:published_time" content="2017-05-18T16:00:00.000Z">
<meta property="article:modified_time" content="2025-04-12T15:02:01.855Z">
<meta property="article:author" content="peng">
<meta property="article:tag" content="设计模式">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://lxlfpeng.github.io/images/311e68177cc2ec89577840663136ab3e.webp"><link rel="shortcut icon" href="/images/favicon.webp"><link rel="canonical" href="https://lxlfpeng.github.io/2017/05/19/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%90%86%E8%AE%BA%E6%80%BB%E7%BB%93-Java%E7%89%88/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '面向对象设计模式理论总结-Java版',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  isShuoshuo: false
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/images/about_avatar.webp" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">127</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">59</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">24</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/categories"><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/images/311e68177cc2ec89577840663136ab3e.webp);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src="/images/nav_logo.webp" alt="Logo"><span class="site-name">鹏哥的Blog</span></a><a class="nav-page-title" href="/"><span class="site-name">面向对象设计模式理论总结-Java版</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/categories"><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">面向对象设计模式理论总结-Java版</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2017-05-18T16:00:00.000Z" title="发表于 2017-05-19 00:00:00">2017-05-19</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/">编程基础</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">5.6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>17分钟</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="一-什么是UML类图"><a href="#一-什么是UML类图" class="headerlink" title="一. 什么是UML类图?"></a>一. 什么是UML类图?</h1><p>UML类图是一种结构图，用于描述一个系统的静态结构。类图以反映类结构和类之间关系为目的，用以描述软件系统的结构，是一种静态建模方法。类图中的类，与面向对象语言中的类的概念是对应的，因此又称统一建模语言，类图是使用频率最高的UML图之一。</p>
<h1 id="二-类图中的表示方式"><a href="#二-类图中的表示方式" class="headerlink" title="二. 类图中的表示方式"></a>二. 类图中的表示方式</h1><h3 id="1-类在类图中的表示方式"><a href="#1-类在类图中的表示方式" class="headerlink" title="1.类在类图中的表示方式"></a>1.类在类图中的表示方式</h3><p>在UML类图中，类使用包含类名、属性(field) 和方法(method) 且带有分割线的矩形来表示，比如下图表示一个Employee类，它包含name、age和email这3个属性，以及modifyInfo()方法。<br><img src="/images/a55e5548bce33cf410160b449545c7f6.webp"><br>对应代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Employee &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line">    private String email;</span><br><span class="line">    </span><br><span class="line">    public void modifyInfo() &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-类图中可见性符号"><a href="#2-类图中可见性符号" class="headerlink" title="2.类图中可见性符号"></a>2.类图中可见性符号</h3><p>UML类图中表示可见性的符号有三种，用来<code>表示属性或方法的可见性</code>：</p>
<ul>
<li>+：表示public</li>
<li>-：表示private</li>
<li>‘#’：表示protected</li>
</ul>
<h3 id="3-类图中属性的完整表示"><a href="#3-类图中属性的完整表示" class="headerlink" title="3.类图中属性的完整表示"></a>3.类图中属性的完整表示</h3><p>属性的完整表示方式是这样的：<br><strong>可见性  名称 ：类型 [ &#x3D; 缺省值]</strong></p>
<ul>
<li>“可见性”表示该属性对于类外的元素而言是否可见，包括公有(public)、私有(private)和受保护(protected)三种，在类图中分别用符号+、-和#表示。</li>
<li>“名称”表示属性名，用一个字符串表示。</li>
<li>“类型”表示属性的数据类型，可以是基本数据类型，也可以是用户自定义类型。</li>
<li>“缺省值”是一个可选项，即属性的初始值。<blockquote>
<p>中括号中的内容表示是可选的</p>
</blockquote>
</li>
</ul>
<h3 id="4-类图中方法的完整表示"><a href="#4-类图中方法的完整表示" class="headerlink" title="4.类图中方法的完整表示"></a>4.类图中方法的完整表示</h3><p>方法的完整表示方式如下：<br><strong>可见性  名称(参数列表) [ ： 返回类型]</strong></p>
<ul>
<li>“可见性”的定义与属性的可见性定义相同。</li>
<li>“名称”即方法名，用一个字符串表示。</li>
<li>“参数列表”表示方法的参数，其语法与属性的定义相似，参数个数是任意的，多个参数之间用逗号“，”隔开。</li>
<li>“返回类型”是一个可选项，表示方法的返回值类型，依赖于具体的编程语言，可以是基本数据类型，也可以是用户自定义类型，还可以是空类型(void)，如果是构造方法，则无返回类型。<blockquote>
<p>中括号中的内容是可选的。</p>
</blockquote>
</li>
</ul>
<p>只有方法没有属性的表示方式：<br><img src="/images/070d42fcc5d31c2b3d3e85db276a4a6b.webp"></p>
<ul>
<li>public方法method1接收一个类型为Object的参数，返回值类型为void。</li>
<li>protected方法method2无参数，返回值类型为String。</li>
<li>private方法method3接收类型分别为int、int[]的参数，返回值类型为int。</li>
</ul>
<h1 id="三-类与类之间关系的表示方式"><a href="#三-类与类之间关系的表示方式" class="headerlink" title="三.类与类之间关系的表示方式"></a>三.类与类之间关系的表示方式</h1><p>在软件系统中，类并不是孤立存在的，类与类之间存在各种关系，对于不同类型的关系，UML提供了不同的表示方式。在UML类图中，常见的有以下几种关系: <code>泛化（Generalization）,  实现（Realization），关联（Association)，聚合（Aggregation），组合(Composition)，依赖(Dependency)</code></p>
<h3 id="1-泛化关系（继承关系）"><a href="#1-泛化关系（继承关系）" class="headerlink" title="1.泛化关系（继承关系）"></a>1.泛化关系（继承关系）</h3><p>泛化(Generalization)关系也就是<strong>继承关系</strong>，用于描述父类与子类之间的关系，父类又称作基类或超类，子类又称作派生类。继承关系对应的是extend关键字，在UML类图中用带空心三角形的直线表示，如下图所示中，Student类与Teacher类继承了Person类。<br><img src="/images/9481a601ddc3b10c0a927bfa278ef63f.webp"><br><code>由子类指向父类。</code></p>
<h3 id="2-接口实现关系"><a href="#2-接口实现关系" class="headerlink" title="2.接口实现关系"></a>2.接口实现关系</h3><p> 接口之间也可以有与类之间关系类似的继承关系和依赖关系，但是接口和类之间还存在一种<strong>实现(Realization)关系</strong>。这种关系对应implement关键字，在UML类图中用带空心三角形的虚线表示。如下图中，Car类与Ship类都实现了Vehicle接口。<br><img src="/images/3dc4a44001b7b08d3d5a760a3927ed1a.webp"><br><code>实现类指向接口</code></p>
<h3 id="3-组合关系"><a href="#3-组合关系" class="headerlink" title="3.组合关系"></a>3.组合关系</h3><p>组合关系与聚合关系见得最大不同在于：这里的“部分”脱离了“整体”便不复存在。比如下图：<br><img src="/images/24fb505ab81e376db15f9ad91440c753.webp"><br>显然，嘴是头的一部分且不能脱离了头而单独存在。在UML类图中，组合关系用一个带实心菱形和箭头的直线表示。</p>
<blockquote>
<p>整体与部分的关系，但是整体与部分不可以分开。整体指向部分</p>
</blockquote>
<h3 id="4-聚合关系"><a href="#4-聚合关系" class="headerlink" title="4.聚合关系"></a>4.聚合关系</h3><p>聚合是整体与部分的关系，且部分可以离开整体而单独存在。<br><img src="/images/825368394a08a86ba00bb2532a8adf34.webp"><br>上图中的Car类与Engine类就是聚合关系（Car类中包含一个Engine类型的成员变量）。由上图我们可以看到，UML中聚合关系用带空心菱形和箭头的直线表示。聚合关系强调是“整体”包含“部分”，但是“部分”可以脱离“整体”而单独存在。比如上图中汽车包含了发动机，而发动机脱离了汽车也能单独存在。</p>
<blockquote>
<p>整体和部分的关系，整体与部分可以分开。整体指向部分</p>
</blockquote>
<h3 id="5-关联关系"><a href="#5-关联关系" class="headerlink" title="5.关联关系"></a>5.关联关系</h3><p>表示一个类的属性保存了对另一个类的一个实例（或多个实例）的<strong>引用</strong>。关联关系又可进一步分为单向关联、双向关联和自关联。 关联关系是类与类之间最常用的一种关系，表示一类对象与另一类对象之间有联系。组合、聚合也属于关联关系，只是关联关系的类间关系比其他两种要弱。</p>
<h5 id="1-单向关联关系"><a href="#1-单向关联关系" class="headerlink" title="(1.)单向关联关系"></a>(1.)单向关联关系</h5><p><img src="/images/9596a838fb2d8f0f58f7e38320f4d2d7.webp"><br>我们可以看到，在UML类图中单向关联用一个带箭头的直线表示。上图表示每个顾客都有一个地址，这通过让Customer类持有一个类型为Address的成员变量类实现。</p>
<h5 id="2-双向关联关系"><a href="#2-双向关联关系" class="headerlink" title="(2.)双向关联关系"></a>(2.)双向关联关系</h5><p><img src="/images/4d12d92c703d9cad355417df442d87fe.webp"><br>从上图中我们很容易看出，所谓的双向关联就是双方各自持有对方类型的成员变量。在UML类图中，双向关联用一个不带箭头的直线表示。上图中在Customer类中维护一个Product[]数组，表示一个顾客购买了那些产品；在Product类中维护一个Customer类型的成员变量表示这个产品被哪个顾客所购买。</p>
<h5 id="自关联"><a href="#自关联" class="headerlink" title="自关联"></a>自关联</h5><p><img src="/images/eae420ba882da507ea312c769458489a.webp"><br>自关联在UML类图中用一个带有箭头且指向自身的直线表示。上图的意思就是Node类包含类型为Node的成员变量，也就是“自己包含自己”。<br><code>拥有者指向被拥有者</code></p>
<h3 id="6-依赖关系"><a href="#6-依赖关系" class="headerlink" title="6.依赖关系"></a>6.依赖关系</h3><p>依赖关系（Dependence）：假设A类的变化引起了B类的变化，则说名B类依赖于A类。大多数情况下，依赖关系体现在某个类的方法使用另一个类的对象作为参数。依赖(Dependency)关系是一种使用关系，特定事物的改变有可能会影响到使用该事物的其他事物，在需要表示一个事物使用另一个事物时使用依赖关系。大多数情况下，依赖关系体现在某个类的方法使用另一个类的对象作为参数。<br><img src="/images/240413eab421604eb45deb66bf9faac9.webp"><br>从上图我们可以看到，Driver的drive方法只有传入了一个Car对象才能发挥作用，因此我们说Driver类依赖于Car类。在UML类图中，依赖关系用一条带有箭头的虚线表示。</p>
<p><code>使用者指向被使用者</code></p>
<blockquote>
<p>这六种类关系中，组合、聚合和关联的代码结构一样，可以从关系的强弱来理解，各类关系从强到弱依次是：<strong>继承→实现→组合→聚合→关联→依赖</strong>。UML类图是面向对象设计的辅助工具。</p>
</blockquote>
<h1 id="四-软件设计模式"><a href="#四-软件设计模式" class="headerlink" title="四.软件设计模式"></a>四.软件设计模式</h1><h3 id="1-什么是软件设计模式"><a href="#1-什么是软件设计模式" class="headerlink" title="1.什么是软件设计模式?"></a>1.什么是软件设计模式?</h3><p>软件设计模式（Software Design Pattern），又称设计模式，是指在软件开发中，经过验证的，用于解决在特定环境下、重复出现的、特定问题的解决方案。</p>
<h3 id="2-软件设计模式的目的"><a href="#2-软件设计模式的目的" class="headerlink" title="2.软件设计模式的目的"></a>2.软件设计模式的目的</h3><p>设计模式的本质是面向对象设计原则的实际运用，是对类的封装性、继承性和多态性以及类的关联关系和组合关系的充分理解。正确使用设计模式具有以下优点。</p>
<ul>
<li>可以提高程序员的思维能力、编程能力和设计能力。</li>
<li>使程序设计更加标准化、代码编制更加工程化，使软件开发效率大大提高，从而缩短软件的开发周期。</li>
<li>使设计的代码可重用性高、可读性强、可靠性高、灵活性好、可维护性强。</li>
</ul>
<h1 id="五-面向对象设计的七大原则"><a href="#五-面向对象设计的七大原则" class="headerlink" title="五.面向对象设计的七大原则"></a>五.面向对象设计的七大原则</h1><ul>
<li>开闭原则（Open Closed Principle，OCP）</li>
<li>单一职责原则（Single Responsibility Principle, SRP）</li>
<li>里氏代换原则（Liskov Substitution Principle，LSP）</li>
<li>依赖倒转原则（Dependency Inversion Principle，DIP）</li>
<li>接口隔离原则（Interface Segregation Principle，ISP）</li>
<li>合成&#x2F;聚合复用原则（Composite&#x2F;Aggregate Reuse Principle，CARP）</li>
<li>迪米特法则（Law of Demeter，LOD） 或者最少知识原则（Least Knowledge Principle，LKP）</li>
</ul>
<blockquote>
<p>其中，单一职责原则、开闭原则、迪米特法则、里氏代换原则和接口隔离原则的英文首字母拼在一起就是<strong>SOLID（稳定的）</strong>，所以也称之为SOLID原则。</p>
</blockquote>
<h3 id="1-单一职责原则（Single-Responsibility-Principle）"><a href="#1-单一职责原则（Single-Responsibility-Principle）" class="headerlink" title="1.单一职责原则（Single Responsibility Principle）"></a>1.单一职责原则（Single Responsibility Principle）</h3><p>对类来说的，即一个类应该只负责一项职责。如类A负责两个不同职责：职责1，职责2。当职责1需求变更而改变A时，可能造成职责2执行错误，所以需要将类A的粒度分解为A1和A2。类的职责要单一，不能将太多的职责放在一个类中。<br><strong>例如:大学学生工作管理程序。</strong><br>分析：大学学生工作主要包括学生生活辅导和学生学业指导两个方面的工作，其中生活辅导主要包括班委建设、出勤统计、心理辅导、费用催缴、班级管理等工作，学业指导主要包括专业引导、学习辅导、科研指导、学习总结等工作。如果将这些工作交给一位老师负责显然不合理，正确的做 法是生活辅导由辅导员负责，学业指导由学业导师负责，其类图如图所示。<br><img src="/images/b3e1e762f6b029f858cef33dcb6606ae.webp"></p>
<p>单一职责原则注意事项和细节:</p>
<ul>
<li>降低类的复杂度，一个类只负责一项职责。</li>
<li>提高类的可读性，可维护性。</li>
<li>降低变更引起的风险。</li>
<li>通常情况下，我们应当遵守单一职责原则，只有逻辑足够简单，才可以在代码级违反单一职责原则：只有类种方法数量足够少，可以在方法级别保持单一职责原则。</li>
</ul>
<blockquote>
<p>注意：单一职责同样也适用于方法。一个方法应该尽可能做好一件事情。如果一个方法处理的事情太多，其颗粒度会变得不细，不利于重用。</p>
</blockquote>
<h3 id="2-开闭原则-Open-Closed-Principle"><a href="#2-开闭原则-Open-Closed-Principle" class="headerlink" title="2.开闭原则(Open-Closed Principle)"></a>2.开闭原则(Open-Closed Principle)</h3><p>对扩展开放，对修改关闭。 一般情况，我们接到需求变更的通知，通常方式可能就是修改模块的源代码，然而修改已经存在的源代码是存在很大风险的，尤其是项目上线运行一段时间后，开发人员发生变化，这种风险可能就更大。 所以，为了避免这种风险，在面对需求变更时，我们一般不修改源代码，即所谓的对修改关闭。不允许修改源代码，我们如何应对需求变更呢？答案就是我们下面要说的对扩展开放。 通过扩展去应对需求变化，就要求我们必须要面向接口编程，或者说面向抽象编程。所有参数类型、引用传递的对象必须使用抽象（接口或者抽象类）的方式定义，不能使用实现类的方式定义； 通过抽象去界定扩展，比如我们定义了一个接口A的参数，那么我们的扩展只能是接口A的实现类。这样原则设计出来的系统，遇到增加功能的需求时，几乎不用修改源代码，只是增加几个类，然后调用就好。 这样既增加了新功能满足了需求，又维护了原本系统的稳定性。<br><strong>例如:</strong></p>
<ol>
<li>首先创建一个手机接口:<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public interface Phone &#123;</span><br><span class="line">    String getName();//名称</span><br><span class="line"></span><br><span class="line">    Double getPrice();//价格</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>创建一个IPhone手机实现手机接口:<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class IPhone implements Phone &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private Double price;</span><br><span class="line"></span><br><span class="line">    public IPhone(String name, Double price) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.price = price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Double getPrice() &#123;</span><br><span class="line">        return price;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>使用类<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class PhoneSore &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Phone phone = new IPhone(&quot;Iphone 4S&quot;, 6000.00);</span><br><span class="line">        System.out.println(&quot;欢迎购买：名字：&quot; + phone.getName() + &quot; 价格：&quot; + String.valueOf(phone.getPrice()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
上面的代码可以正常地运行，我们可以方便地添加新的手机。但是如果需求发生了变更，手机店推出了打折地活动。如何解决？<br>有下面三种方法可以解决此问题：</li>
</ol>
<ul>
<li><p>修改接口<br>在IPhone接口中，增加一个方法getDiscountPrice，专门用于处理打折需求。但是这个方法是有问题的，接口应该是稳定且可靠的，不应该经常发生变化，否则接口作为契约的作用就失去了。且违背了开闭原则，因此否定。</p>
</li>
<li><p>修改实现类<br>第二种方法是通过修改实现类中的getPrice方法或者增加getDiscountPrice方法实现其需求，但是这样一个类中就存在了两个读取价格的方法，且违背了开闭原则，所以此方法也不是一个最优方案。</p>
</li>
<li><p>通过扩展实现变化<br>我们可以通过增加一个子类IPhoneDiscount，复写getPrice方法，此方法修改少，对现有的代码没有影响，风险少，是个好方法。</p>
</li>
</ul>
<ol start="4">
<li>添加打折类<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class IPhoneDiscount extends IPhone &#123;</span><br><span class="line">    public IPhoneDiscount(String name, Double price) &#123;</span><br><span class="line">        super(name, price);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //打折活动</span><br><span class="line">    public Double getPrice() &#123;</span><br><span class="line">        //九折优惠</span><br><span class="line">        return super.getPrice() * 0.90;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p><img src="/images/447f586d18b8adec5daf3af1ef790e91.webp"></p>
<h3 id="3-里式替换原则-Liskov-Substitution-Principle"><a href="#3-里式替换原则-Liskov-Substitution-Principle" class="headerlink" title="3.里式替换原则(Liskov Substitution Principle)"></a>3.里式替换原则(Liskov Substitution Principle)</h3><p>所有引用基类（父类）的地方，都必须能透明地使用其子类的对象。父类可被子类替换，但反之不一定成立。也就是说，代码中可以将父类全部替换为子类，程序不会出现异常。当使用继承时，遵循里氏替换原则。类B继承类A时，除添加新的方法完成新增功能P2外，尽量不要重写父类A的方法，也尽量不要重载父类A的方法。里氏替换原则通俗的来讲就是：子类可以扩展父类的功能，但不能改变父类原有的功能。<br>例如：我喜欢动物，那我一定喜欢狗，因为狗是动物的子类。但是我喜欢狗，不能据此断定我喜欢动物，因为我并不喜欢老鼠，虽然它也是动物。</p>
<blockquote>
<p>尽量不要重写父类方法，而是增加自己特有的方法。继承给程序设计带来巨大便利的同时，也带来了弊端。如果一个类被其他的类所继承，则当这个类需要修改时，必须考虑到所有的子类，并且父类修改后，所有涉及到子类的功能都有可能会产生BUG。</p>
</blockquote>
<p>例如：</p>
<ol>
<li>先定义一个鸟的接口。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Bird &#123;</span><br><span class="line">    private int velocity;</span><br><span class="line"></span><br><span class="line">    public int getVelocity() &#123;</span><br><span class="line">        return velocity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setVelocity(int velocity) &#123;</span><br><span class="line">        this.velocity = velocity;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>定义鸵鸟去实现鸟的功能。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Ostrich extends Bird&#123;</span><br><span class="line"></span><br><span class="line">    public int getVelocity() &#123;</span><br><span class="line">        //鸵鸟是不会飞的所以他的飞行时间就为0</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>测试<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class main &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //计算鸟的飞行时间    </span><br><span class="line">        Bird bird = new Bird();</span><br><span class="line">        bird.setVelocity(100);</span><br><span class="line">        int h = flyTime(bird);</span><br><span class="line">        System.out.println(&quot;飞行时间是:&quot;+h);</span><br><span class="line"></span><br><span class="line">        //计算鸵鸟的飞行时间</span><br><span class="line">        Bird ostrich = new  Ostrich();</span><br><span class="line">        ostrich.setVelocity(100);</span><br><span class="line">        int h = flyTime(ostrich);</span><br><span class="line">        System.out.println(&quot;飞行时间是:&quot;+h);</span><br><span class="line">    &#125;</span><br><span class="line">/*</span><br><span class="line">*计算飞行3000米需要的时间</span><br><span class="line">*/</span><br><span class="line">    public static int flyTime(Bird bird)</span><br><span class="line">    &#123;</span><br><span class="line">        return 3000/bird.getVelocity();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
结果：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">普通鸟运行结果正确，飞行时间是:30。</span><br><span class="line">计算鸵鸟的飞行时间报错。</span><br></pre></td></tr></table></figure></li>
</ol>
<p>面向对象的语言的三大特点是继承，封装，多态，里氏替换原则是依赖于继承，多态这两大特性。里氏替换原则的定义是，所有引用基类的地方必须能透明地使用其子类的对象。通俗来讲是只要父类能出现的地方子类就可以出现，而且替换为子类也不会产生任何错误和异常。而我们在使用flyTime方法时 ，当使用者flyTime方法里的参数Bird被Ostrich替换掉后，结果出现了异常，那么它明显违背了里氏替换原则。</p>
<h3 id="4-接口隔离原则-Interface-Segregation-Principle"><a href="#4-接口隔离原则-Interface-Segregation-Principle" class="headerlink" title="4.接口隔离原则(Interface Segregation Principle)"></a>4.接口隔离原则(Interface Segregation Principle)</h3><p>使用多个专门的接口，而不使用单一的总接口。不要对外暴露没有实际意义的接口。也就是说使用多个专门的接口比使用单一的总接口要好。<br>例如：对于鸟的实现（Bird），我们可以定义两个功能接口，分别是Fly和Eat，我们可以让Bird分别实现这两个接口。 如果我们还有一个Dog，那么对于Eat接口，可以复用。但是如果只有一个接口（包含Fly和Eat两个功能），对于Dog来说， 它是不会飞（Fly）的，那么就需要针对Dog再声明一个新的接口，这是没有必要的设计。</p>
<h3 id="5-依赖倒置原则-Dependence-Inversion-Principle"><a href="#5-依赖倒置原则-Dependence-Inversion-Principle" class="headerlink" title="5.依赖倒置原则(Dependence Inversion Principle)"></a>5.依赖倒置原则(Dependence Inversion Principle)</h3><p>高层模块不应该依赖低层模块，二者都应该依赖其抽象。抽象不应该依赖细节，细节应该依赖抽象 。一开始类A依赖于类B，由于需求发生了改变。要将类A依赖于类C，则我们需要修改类A依赖于类B的相关代码，这样会对程序产生不好的影响。假如需求又发生了改变，我们又需要修改类A的代码。</p>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class UserService &#123;</span><br><span class="line">    private Plaintext plaintext; // 明文登录注册</span><br><span class="line">    </span><br><span class="line">    public void register()&#123;</span><br><span class="line">        Plaintext.register();    // 调用明文的注册方法</span><br><span class="line">    &#125;</span><br><span class="line">    public void login()&#123;</span><br><span class="line">        Plaintext.login();        // 调用明文的登录方法</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的例子可以看出，UserService类依赖于Plaintext类。有一天，由于使用明文登录注册不安全，需求改为使用密文登录注册。我们可以怎么办？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//不符合 依赖倒置原则</span><br><span class="line">public class UserService &#123;</span><br><span class="line">    // private Plaintext plaintext;</span><br><span class="line">    private Ciphertext ciphertext;    // 密文登录注册</span><br><span class="line">    </span><br><span class="line">    public void register()&#123;</span><br><span class="line">        // Plaintext.register();</span><br><span class="line">        Ciphertext.register();        // 调用密文的注册方法</span><br><span class="line">    &#125;</span><br><span class="line">    public void login()&#123;</span><br><span class="line">        // Plaintext.login();</span><br><span class="line">        Ciphertext.login();            // 调用密文的登录方法</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的例子，修改一个需求几乎将整个UserService类都修改了一遍，这不但麻烦，而且会给程序带来很多风险。所以上面的例子不符合依赖倒置原则。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">//符合 依赖倒置原则</span><br><span class="line">public class UserService &#123;</span><br><span class="line">    private Authentication authentication;    // 依赖于接口（抽象）</span><br><span class="line">    </span><br><span class="line">    public UserServer(Authentication auth) &#123;</span><br><span class="line">        //接口与实现类对接</span><br><span class="line">        this.authentication = auth;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void register()&#123;</span><br><span class="line">        authentication.register();</span><br><span class="line">    &#125;</span><br><span class="line">    public void login()&#123;</span><br><span class="line">        authentication.login();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public interface Authentication &#123;</span><br><span class="line">    //...登录注册</span><br><span class="line">&#125;</span><br><span class="line">public class Ciphertext implements Authentication &#123;</span><br><span class="line">    //...使用明文的实现</span><br><span class="line">&#125;</span><br><span class="line">public class Plaintext implements Authentication &#123;</span><br><span class="line">    //...使用密文的实现</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的例子Ciphertext类和Plaintext类实现了Authentication接口。而UserService类依赖于Authentication接口。这样可以在构造函数里随意切换登录注册的模式。 假设以后还需要更改需求，只需要实现Authentication接口然后在构造函数里注入就可以了。</p>
<h3 id="6-迪米特法则-Law-Of-Demeter"><a href="#6-迪米特法则-Law-Of-Demeter" class="headerlink" title="6.迪米特法则(Law Of Demeter)"></a>6.迪米特法则(Law Of Demeter)</h3><p>如果两个类不彼此通信，那么这两个类就不应当直接地发生相互作用。如果其中一个类需要另一个类的某一个方法的话，可以通过第三者转发这个调用。 迪米特法则的初衷是降低类之间的耦合，由于每个类都减少了不必要的依赖，因此的确可以降低耦合关系。 但是凡事都有度，虽然可以避免与非直接的类通信，但是要通信，必然会通过一个“中介”来发生联系，过分的使用迪米特原则，会产生大量这样的中介和传递类，导致系统复杂度变大。 所以在采用迪米特法则时要反复权衡，既做到结构清晰，又要高内聚低耦合。</p>
<h3 id="7-合成复用原则-Composite-Aggregate-Reuse-Principle"><a href="#7-合成复用原则-Composite-Aggregate-Reuse-Principle" class="headerlink" title="7.合成复用原则(Composite&#x2F;Aggregate Reuse Principle)"></a>7.合成复用原则(Composite&#x2F;Aggregate Reuse Principle)</h3><p>合成复用原则目的就是尽量使用对象组合，而不是继承来达到复用的目的。通过继承来进行复用的主要问题在于继承复用会破坏系统的封装性，因为继承会将基类的实现细节暴露给子类，由于基类的内部细节通常对子类来说是可见的， 所以这种复用又称“白箱”复用，子类与父类的耦合度高。父类的实现的任何改变都会导致子类的实现发生变化，这不利于类的扩展与维护。而且它限制了复用的灵活性。 从父类继承而来的实现是静态的，在编译时已经定义，所以在运行时不可能发生变化。</p>
<p>由于组合或聚合关系可以将已有的对象（也可称为成员对象）纳入到新对象中，使之成为新对象的一部分，因此新对象可以调用已有对象的功能，这样做可以使得成员对象的内部实现细节对于新对象不可见，所以这种复用又称为“黑箱”复用，相对继承关系而言，其耦合度相对较低，成员对象的变化对新对象的影响不大，可以在新对象中根据实际需要有选择性地调用成员对象的操作；<br>合成复用可以在运行时动态进行，新对象可以动态地引用与成员对象类型相同的其他对象。</p>
<h3 id="8-总结"><a href="#8-总结" class="headerlink" title="8.总结"></a>8.总结</h3><p><img src="/images/c374affe87a93bb04cca6fc91b685aa7.webp"></p>
<p>参考资料：<br><a target="_blank" rel="noopener" href="http://www.throwable.club/2019/05/05/design-pattern-basic-law/">设计模式概念和七大原则</a><br><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/24614363">设计模式之七大基本原则</a><br><a target="_blank" rel="noopener" href="https://juejin.im/post/6844904065806106632">万字总结之设计模式七大原则</a><br><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/24614363">设计模式之七大基本原则</a></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://lxlfpeng.github.io">peng</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://lxlfpeng.github.io/2017/05/19/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%90%86%E8%AE%BA%E6%80%BB%E7%BB%93-Java%E7%89%88/">https://lxlfpeng.github.io/2017/05/19/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%90%86%E8%AE%BA%E6%80%BB%E7%BB%93-Java%E7%89%88/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://lxlfpeng.github.io" target="_blank">鹏哥的Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a></div><div class="post-share"><div class="social-share" data-image="/images/311e68177cc2ec89577840663136ab3e.webp" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2017/06/11/Okhttp3.0%E9%85%8D%E7%BD%AE%E6%94%AF%E6%8C%81%E7%AC%AC%E4%B8%89%E6%96%B9%E7%AD%BE%E5%90%8DHttps%E8%AF%81%E4%B9%A6/" title="Okhttp3.0配置支持第三方签名Https证书"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Okhttp3.0配置支持第三方签名Https证书</div></div><div class="info-2"><div class="info-item-1">一.Https简介HTTPS全称为Hyper Text Transfer Protocol over Secure Socket Layer或是Hypertext Transfer Protocol Secure 中文含义为“超文本传输安全协议” 。是以安全为目标的HTTP通道，在HTTP的基础上通过传输加密和身份认证保证了传输过程的安全性 。HTTPS 在HTTP 的基础下加入SSL，HTTPS 的安全基础是 SSL，因此加密的详细内容就需要 SSL。 HTTPS 存在不同于 HTTP 的默认端口及一个加密&#x2F;身份验证层（在 HTTP与 TCP 之间）。这个系统提供了身份验证与加密通讯方法。它被广泛用于万维网上安全敏感的通讯，例如交易支付等方面。 二.Okhttp支持Httpsokhttp默认情况下是支持https协议的网站的，比如https://www.baidu.com等，可以直接通过okhttp请求就可以获取对应的数据。需要注意的是Okhttp支持的https的网站基本都是CA机构颁发的证书，...</div></div></div></a><a class="pagination-related" href="/2017/02/17/Android%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E6%A1%86%E6%9E%B6Dagger2%E5%85%A8%E9%9D%A2%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/" title="Android依赖注入框架Dagger2全面使用总结"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Android依赖注入框架Dagger2全面使用总结</div></div><div class="info-2"><div class="info-item-1">一 依赖注入依赖注入（DI）是控制反转（Inversion of Control,IoC）的一种重要方式，IoC是将依赖对象的创建和绑定通过被依赖对象类的外部来实现。依赖注入提供一种机制，将需要依赖对象的引用传递给被依赖对象。它是面向对象的一种设计模式，其目的是为了降低耦合。举个栗子： 12345public class Person &#123;    Decorate decorate;    public Person()&#123;        decorate = new Decorate(jacket,shoe);    &#125; 这里的Person对象的初始化为实例化Decorate，如果Decorate类实例化参数增加，则必须对Person对象初始化进行修改。如果还有其他类的也是按照这种方式创建Decorate类，那么就需要修改多处，这违背了单一职责原则和开闭原则。因此需要引入依赖注入来解决这个问题。依赖注入，就是将依赖注入到宿主类（或者叫目标类）中，从而解决上面所述的问题。 二...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2020/03/11/Java%E5%B8%B8%E8%A7%81%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F(%E4%B8%8B)/" title="Java常见的设计模式(下)"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2020-03-11</div><div class="info-item-2">Java常见的设计模式(下)</div></div><div class="info-2"><div class="info-item-1">一. 常见的软件设计模式接上一篇，我们说到面向对象设计模式总体来说23种设计模式分为三大类： 创建型模式（5种）单例模式、建造者模式、工厂方法模式、抽象工厂模式、原型模式。 结构型模式（7种）适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。 行为型模式（11种）策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。 二. 适配器模式1. 概念将一个类的接口转换成客户希望的另外一个接口，从而使原本因接口不匹配而无法在一起工作的两个类能够在一起工作。例子：笔记本电脑电源一般用的都是5V电压，但是我们的家用电是220V，我们要让笔记本充上电，最好的办法应该是通过一个工具把220V的电压转换成5V，这个工具就是适配器。 2. 适配器模式涉及3个角色 目标 Target（目标抽象类）：目标抽象类定义客户所需接口，可以是一个抽象类或接口，也可以是具体类，相当于插座。 适配器...</div></div></div></a><a class="pagination-related" href="/2020/02/10/Java%E5%B8%B8%E8%A7%81%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F(%E4%B8%8A)/" title="Java常见的设计模式(上)"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2020-02-10</div><div class="info-item-2">Java常见的设计模式(上)</div></div><div class="info-2"><div class="info-item-1">一. 常见的软件设计模式总体来说23种设计模式分为三大类： 创建型模式（5种）单例模式、建造者模式、工厂方法模式、抽象工厂模式、原型模式。 结构型模式（7种）适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。 行为型模式（11种）策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。 二. 单例模式1. 单例模式的特点?确保一个类最多只有一个实例对象，并向整个系统提供这个实例。优点：由于单例模式只生成了一个实例，所以能够节约系统资源，减少性能开销，提高系统效率，同时也能够严格控制客户对它的访问。缺点：也正是因为系统中只有一个实例，这样就导致了单例类的职责过重，违背了“单一职责原则”，同时也没有抽象类，这样扩展起来有一定的困难。 2.单例模式的使用场景 整个程序的运行中只允许有一个类的实例。 需要频繁实例化然后销毁的对象。 创建对象时耗时过多或者耗资源过多，但又经常用到的对象。 方便资源相互通信的环境。  3....</div></div></div></a></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="giscus-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/images/about_avatar.webp" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">peng</div><div class="author-info-description">过往不恋 未来不迎 当下不负</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">127</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">59</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">24</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/lxlfpeng"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/lxlfpeng" target="_blank" title="Github"><i class="fab fa-github" style="color: #4a7dbe;"></i></a><a class="social-icon" href="mailto:565289282@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎来到我的博客!</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80-%E4%BB%80%E4%B9%88%E6%98%AFUML%E7%B1%BB%E5%9B%BE"><span class="toc-number">1.</span> <span class="toc-text">一. 什么是UML类图?</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C-%E7%B1%BB%E5%9B%BE%E4%B8%AD%E7%9A%84%E8%A1%A8%E7%A4%BA%E6%96%B9%E5%BC%8F"><span class="toc-number">2.</span> <span class="toc-text">二. 类图中的表示方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%B1%BB%E5%9C%A8%E7%B1%BB%E5%9B%BE%E4%B8%AD%E7%9A%84%E8%A1%A8%E7%A4%BA%E6%96%B9%E5%BC%8F"><span class="toc-number">2.0.1.</span> <span class="toc-text">1.类在类图中的表示方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E7%B1%BB%E5%9B%BE%E4%B8%AD%E5%8F%AF%E8%A7%81%E6%80%A7%E7%AC%A6%E5%8F%B7"><span class="toc-number">2.0.2.</span> <span class="toc-text">2.类图中可见性符号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E7%B1%BB%E5%9B%BE%E4%B8%AD%E5%B1%9E%E6%80%A7%E7%9A%84%E5%AE%8C%E6%95%B4%E8%A1%A8%E7%A4%BA"><span class="toc-number">2.0.3.</span> <span class="toc-text">3.类图中属性的完整表示</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E7%B1%BB%E5%9B%BE%E4%B8%AD%E6%96%B9%E6%B3%95%E7%9A%84%E5%AE%8C%E6%95%B4%E8%A1%A8%E7%A4%BA"><span class="toc-number">2.0.4.</span> <span class="toc-text">4.类图中方法的完整表示</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89-%E7%B1%BB%E4%B8%8E%E7%B1%BB%E4%B9%8B%E9%97%B4%E5%85%B3%E7%B3%BB%E7%9A%84%E8%A1%A8%E7%A4%BA%E6%96%B9%E5%BC%8F"><span class="toc-number">3.</span> <span class="toc-text">三.类与类之间关系的表示方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%B3%9B%E5%8C%96%E5%85%B3%E7%B3%BB%EF%BC%88%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB%EF%BC%89"><span class="toc-number">3.0.1.</span> <span class="toc-text">1.泛化关系（继承关系）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0%E5%85%B3%E7%B3%BB"><span class="toc-number">3.0.2.</span> <span class="toc-text">2.接口实现关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E7%BB%84%E5%90%88%E5%85%B3%E7%B3%BB"><span class="toc-number">3.0.3.</span> <span class="toc-text">3.组合关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E8%81%9A%E5%90%88%E5%85%B3%E7%B3%BB"><span class="toc-number">3.0.4.</span> <span class="toc-text">4.聚合关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%85%B3%E8%81%94%E5%85%B3%E7%B3%BB"><span class="toc-number">3.0.5.</span> <span class="toc-text">5.关联关系</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%8D%95%E5%90%91%E5%85%B3%E8%81%94%E5%85%B3%E7%B3%BB"><span class="toc-number">3.0.5.0.1.</span> <span class="toc-text">(1.)单向关联关系</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%8F%8C%E5%90%91%E5%85%B3%E8%81%94%E5%85%B3%E7%B3%BB"><span class="toc-number">3.0.5.0.2.</span> <span class="toc-text">(2.)双向关联关系</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%87%AA%E5%85%B3%E8%81%94"><span class="toc-number">3.0.5.0.3.</span> <span class="toc-text">自关联</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB"><span class="toc-number">3.0.6.</span> <span class="toc-text">6.依赖关系</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9B-%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.</span> <span class="toc-text">四.软件设计模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AF%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.0.1.</span> <span class="toc-text">1.什么是软件设计模式?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%9B%AE%E7%9A%84"><span class="toc-number">4.0.2.</span> <span class="toc-text">2.软件设计模式的目的</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%94-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E7%9A%84%E4%B8%83%E5%A4%A7%E5%8E%9F%E5%88%99"><span class="toc-number">5.</span> <span class="toc-text">五.面向对象设计的七大原则</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E5%8E%9F%E5%88%99%EF%BC%88Single-Responsibility-Principle%EF%BC%89"><span class="toc-number">5.0.1.</span> <span class="toc-text">1.单一职责原则（Single Responsibility Principle）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99-Open-Closed-Principle"><span class="toc-number">5.0.2.</span> <span class="toc-text">2.开闭原则(Open-Closed Principle)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E9%87%8C%E5%BC%8F%E6%9B%BF%E6%8D%A2%E5%8E%9F%E5%88%99-Liskov-Substitution-Principle"><span class="toc-number">5.0.3.</span> <span class="toc-text">3.里式替换原则(Liskov Substitution Principle)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%99-Interface-Segregation-Principle"><span class="toc-number">5.0.4.</span> <span class="toc-text">4.接口隔离原则(Interface Segregation Principle)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E4%BE%9D%E8%B5%96%E5%80%92%E7%BD%AE%E5%8E%9F%E5%88%99-Dependence-Inversion-Principle"><span class="toc-number">5.0.5.</span> <span class="toc-text">5.依赖倒置原则(Dependence Inversion Principle)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E8%BF%AA%E7%B1%B3%E7%89%B9%E6%B3%95%E5%88%99-Law-Of-Demeter"><span class="toc-number">5.0.6.</span> <span class="toc-text">6.迪米特法则(Law Of Demeter)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E5%90%88%E6%88%90%E5%A4%8D%E7%94%A8%E5%8E%9F%E5%88%99-Composite-Aggregate-Reuse-Principle"><span class="toc-number">5.0.7.</span> <span class="toc-text">7.合成复用原则(Composite&#x2F;Aggregate Reuse Principle)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E6%80%BB%E7%BB%93"><span class="toc-number">5.0.8.</span> <span class="toc-text">8.总结</span></a></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer" style="background-image: url(/images/311e68177cc2ec89577840663136ab3e.webp);"><div id="footer-wrap"><div class="copyright">&copy;2015 - 2025 By peng</div><div class="footer_custom_text"> <a target="_blank" rel="nofollow noopener"><span>千里之行</span></a> <i class="iconfont icon-love"></i> <a target="_blank" rel="nofollow noopener"><span>始于足下</span></a> </div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.isShuoshuo
  const option = null

  const getGiscusTheme = theme => theme === 'dark' ? 'dark' : 'light'

  const createScriptElement = config => {
    const ele = document.createElement('script')
    Object.entries(config).forEach(([key, value]) => {
      ele.setAttribute(key, value)
    })
    return ele
  }

  const loadGiscus = (el = document, key) => {
    const mappingConfig = isShuoshuo
      ? { 'data-mapping': 'specific', 'data-term': key }
      : { 'data-mapping': (option && option['data-mapping']) || 'pathname' }

    const giscusConfig = {
      src: 'https://giscus.app/client.js',
      'data-repo': 'lxlfpeng/blog_comments',
      'data-repo-id': 'R_kgDONYoexA',
      'data-category-id': 'DIC_kwDONYoexM4Ck4JQ',
      'data-theme': getGiscusTheme(document.documentElement.getAttribute('data-theme')),
      'data-reactions-enabled': '1',
      crossorigin: 'anonymous',
      async: true,
      ...option,
      ...mappingConfig
    }

    const scriptElement = createScriptElement(giscusConfig)

    el.querySelector('#giscus-wrap').appendChild(scriptElement)

    if (isShuoshuo) {
      window.shuoshuoComment.destroyGiscus = () => {
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }
  }

  const changeGiscusTheme = theme => {
    const iframe = document.querySelector('#giscus-wrap iframe')
    if (iframe) {
      const message = {
        giscus: {
          setConfig: {
            theme: getGiscusTheme(theme)
          }
        }
      }
      iframe.contentWindow.postMessage(message, 'https://giscus.app')
    }
  }

  btf.addGlobalFn('themeChange', changeGiscusTheme, 'giscus')

  if (isShuoshuo) {
    'Giscus' === 'Giscus'
      ? window.shuoshuoComment = { loadComment: loadGiscus }
      : window.loadOtherComment = loadGiscus
    return
  }

  if ('Giscus' === 'Giscus' || !false) {
    if (false) btf.loadComment(document.getElementById('giscus-wrap'), loadGiscus)
    else loadGiscus()
  } else {
    window.loadOtherComment = loadGiscus
  }
})()</script></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="false"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>