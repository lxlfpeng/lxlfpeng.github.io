<!DOCTYPE html><html lang="zh-CN" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Android依赖注入框架Dagger2全面使用总结 | 鹏哥的Blog</title><meta name="author" content="peng"><meta name="copyright" content="peng"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#0d0d0d"><meta name="description" content="一 依赖注入依赖注入（DI）是控制反转（Inversion of Control,IoC）的一种重要方式，IoC是将依赖对象的创建和绑定通过被依赖对象类的外部来实现。依赖注入提供一种机制，将需要依赖对象的引用传递给被依赖对象。它是面向对象的一种设计模式，其目的是为了降低耦合。举个栗子： 12345public class Person &#123;    Decorate decorate;">
<meta property="og:type" content="article">
<meta property="og:title" content="Android依赖注入框架Dagger2全面使用总结">
<meta property="og:url" content="https://lxlfpeng.github.io/2017/02/17/Android%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E6%A1%86%E6%9E%B6Dagger2%E5%85%A8%E9%9D%A2%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/index.html">
<meta property="og:site_name" content="鹏哥的Blog">
<meta property="og:description" content="一 依赖注入依赖注入（DI）是控制反转（Inversion of Control,IoC）的一种重要方式，IoC是将依赖对象的创建和绑定通过被依赖对象类的外部来实现。依赖注入提供一种机制，将需要依赖对象的引用传递给被依赖对象。它是面向对象的一种设计模式，其目的是为了降低耦合。举个栗子： 12345public class Person &#123;    Decorate decorate;">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://lxlfpeng.github.io/images/about_avatar.webp">
<meta property="article:published_time" content="2017-02-16T16:00:00.000Z">
<meta property="article:modified_time" content="2025-04-12T15:02:01.828Z">
<meta property="article:author" content="peng">
<meta property="article:tag" content="依赖注入">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://lxlfpeng.github.io/images/about_avatar.webp"><link rel="shortcut icon" href="/images/favicon.webp"><link rel="canonical" href="https://lxlfpeng.github.io/2017/02/17/Android%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E6%A1%86%E6%9E%B6Dagger2%E5%85%A8%E9%9D%A2%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Android依赖注入框架Dagger2全面使用总结',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  isShuoshuo: false
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/images/about_avatar.webp" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">127</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">59</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">24</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/categories"><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background: linear-gradient(20deg, #0062be, #925696, #cc426e, #fb0347);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src="/images/nav_logo.webp" alt="Logo"><span class="site-name">鹏哥的Blog</span></a><a class="nav-page-title" href="/"><span class="site-name">Android依赖注入框架Dagger2全面使用总结</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/categories"><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Android依赖注入框架Dagger2全面使用总结</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2017-02-16T16:00:00.000Z" title="发表于 2017-02-17 00:00:00">2017-02-17</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Android%E5%BC%80%E5%8F%91/">Android开发</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">7.6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>30分钟</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="一-依赖注入"><a href="#一-依赖注入" class="headerlink" title="一 依赖注入"></a>一 依赖注入</h1><p>依赖注入（DI）是控制反转（Inversion of Control,IoC）的一种重要方式，IoC是将依赖对象的创建和绑定通过被依赖对象类的外部来实现。依赖注入提供一种机制，将需要依赖对象的引用传递给被依赖对象。<br>它是面向对象的一种设计模式，其目的是为了降低耦合。举个栗子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class Person &#123;</span><br><span class="line">    Decorate decorate;</span><br><span class="line">    public Person()&#123;</span><br><span class="line">        decorate = new Decorate(jacket,shoe);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这里的Person对象的初始化为实例化Decorate，如果Decorate类实例化参数增加，则必须对Person对象初始化进行修改。如果还有其他类的也是按照这种方式创建Decorate类，那么就需要修改多处，这违背了单一职责原则和开闭原则。<br>因此需要引入依赖注入来解决这个问题。依赖注入，就是将依赖注入到宿主类（或者叫目标类）中，从而解决上面所述的问题。</p>
<h1 id="二-依赖注入实现的三种方式"><a href="#二-依赖注入实现的三种方式" class="headerlink" title="二 依赖注入实现的三种方式"></a>二 依赖注入实现的三种方式</h1><p>下面将会介绍三种简单的依赖注入方式，一般依赖注入的框架的基本原理基本一样，避免在被依赖对象中直接实例化依赖对象，而是通过其他方式引入。根据依赖注入的定义，下面例子中依赖对象为Decorate，被依赖对象为Person。</p>
<h3 id="1-构造注入"><a href="#1-构造注入" class="headerlink" title="1. 构造注入"></a>1. 构造注入</h3><p>通过构造函数直接注入</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class Person &#123;</span><br><span class="line">    private Decorate decorate;</span><br><span class="line">    public Person(Decorate decorate)&#123;</span><br><span class="line">        this.decorate = decorate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-属性注入"><a href="#2-属性注入" class="headerlink" title="2. 属性注入"></a>2. 属性注入</h3><p>通过属性来传递依赖即通过set方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class Person &#123;</span><br><span class="line">    private Decorate decorate;</span><br><span class="line">    public void setPerson(Decorate decorate)&#123;</span><br><span class="line">        this.decorate = decorate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="3-通过Java注解"><a href="#3-通过Java注解" class="headerlink" title="3. 通过Java注解"></a>3. 通过Java注解</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class Person &#123;</span><br><span class="line">    //此时并不会完成注入，还需要依赖注入框架的支持，如RoboGuice,Dagger2</span><br><span class="line">    @inject Decorate decorate;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在Dagger2中用的就是最后一种注入方式，通过注解的方式，将依赖注入到宿主类中。</p>
<h1 id="三-Dagger2注解使用"><a href="#三-Dagger2注解使用" class="headerlink" title="三 Dagger2注解使用"></a>三 Dagger2注解使用</h1><p>Dagger2是Dagger的升级版，是一个依赖注入框架，现在由Google接手维护。在github上Dagger2是这样定义的，Dagger2是一个Android和java快速依赖注入框架。<br>Dragger2是在编译时注解的方式实现依赖注入，是Dagger的升级版，取消了反射的使用。通过@Component的接口替代ObjectGraph&#x2F;Injector，从而使代码更精简。<br>早期的一些注入框架是通过反射机制在运行时完成注入的工作，而反射对性能影响很大，所以现在基本上是采用编译时通过工具生成相应的类文件实现的。</p>
<h3 id="1-Dagger2的依赖引入"><a href="#1-Dagger2的依赖引入" class="headerlink" title="1.Dagger2的依赖引入"></a>1.Dagger2的依赖引入</h3><p>完成Dagger2的依赖方式有两种，分别为annotationProcessor和android-apt。android-apt是开发者自己开发的apt框架，随着谷歌Android Gradle2.2插件的发布，插件提供了annotationProcessor来替换android-apt，<br>自此基本上都使用annotationProcessor。<br>项目中通过annotationProcessor的方式进行依赖，在app的build.gradle添加：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">implementation &#x27;com.google.dagger:dagger:2.10&#x27;</span><br><span class="line">annotationProcessor &quot;com.google.dagger:dagger-compiler:2.10&quot;</span><br><span class="line">implementation &quot;org.glassfish:javax.annotation:10.0-b28&quot;</span><br></pre></td></tr></table></figure>

<h3 id="2-Inject方式注入（Inject-Component）"><a href="#2-Inject方式注入（Inject-Component）" class="headerlink" title="2.Inject方式注入（Inject+Component）"></a>2.Inject方式注入（Inject+Component）</h3><ol>
<li>定义一个Person类，在构造函数前加上@Inject，表明支持依赖注入。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Person &#123;</span><br><span class="line">    @Inject</span><br><span class="line">    public Person()&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    public String getName()&#123;</span><br><span class="line">        return &quot;xiaoming&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>定义接口MainActivityComponent，在接口前添加@Component，定义相应的抽象方法，方法的参数为需要注入对象的真实所在的类，方法名一般为Inject。<br>Component可以理解为Person（依赖对象）和MainActivity（被依赖对象）之间的桥梁。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public interface MainActivityComponent &#123;</span><br><span class="line">    void inject(MainActivity activity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>对项目进行Rebuild，Dagger2框架会根据MainActivityComponent自动生成DaggerMainActivityComponent(命名规则Dagger+Component名称)。<br>在MainActivity声明Person对象，并用@Inject的注解，然后通过DaggerMainActivityComponent注入Person对象。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class DaggerSimpleActivity extends AppCompatActivity &#123;</span><br><span class="line"></span><br><span class="line">    private static final String TAG = &quot;MainActivity&quot;;</span><br><span class="line">    @Inject</span><br><span class="line">    Person person;</span><br><span class="line">    @Override</span><br><span class="line">    protected void onCreate(@Nullable Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        DaggerMainActivityComponent.builder().build().inject(this);</span><br><span class="line">        Log.d(TAG,person.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
执行结果:<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MainActivity: xiaoming</span><br></pre></td></tr></table></figure>
可以看出MainActivity成功注入了Person类，下面分析是如何注入Person类的：<br>打开DaggerMainActivityComponent，可以看出其对应的路径\app\build\generated\source\apt\debug，在其目录下同时也有其他两个类Person_Factory，MainActivity_MembersInjector。<br>DaggerMainActivityComponent.java:<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public final class DaggerMainActivityComponent implements MainActivityComponent &#123;</span><br><span class="line">    private DaggerMainActivityComponent() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Builder builder() &#123;</span><br><span class="line">        return new Builder();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //1.调用create实际上是调用Builder().build()方法</span><br><span class="line">    public static MainActivityComponent create() &#123;</span><br><span class="line">        return new Builder().build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //3.重写MainActivityComponent的inject方法</span><br><span class="line">    @Override</span><br><span class="line">    public void inject(MainActivity activity) &#123;</span><br><span class="line">        injectMainActivity(activity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //4. 调用  MainActivity_MembersInjector的injectMPerson方法将MainActivity的引用和new 创建的Person对象传入</span><br><span class="line">    private MainActivity injectMainActivity(MainActivity instance) &#123;</span><br><span class="line">        MainActivity_MembersInjector.injectMPerson(instance, new Person());</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static final class Builder &#123;</span><br><span class="line">        private Builder() &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //2.build()会通过new关键字创建DaggerMainActivityComponent对象</span><br><span class="line">        public MainActivityComponent build() &#123;</span><br><span class="line">            return new DaggerMainActivityComponent();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
在MainActivity中DaggerMainActivityComponent.builder().build()将会通过构建者实例化DaggerMainActivityComponent，<br>DaggerMainActivityComponent实现了MainActivityComponent接口.重写MainActivityComponent的inject方法.因此我们再MainActivity中调用inject方法时会走<br>4中的步骤MainActivity_MembersInjector的injectMPerson方法将MainActivity的引用和new 创建的Person对象传入.</li>
</ol>
<p>MainActivity_MembersInjector.java</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public final class MainActivity_MembersInjector implements MembersInjector&lt;MainActivity&gt; &#123;</span><br><span class="line">  private final Provider&lt;Person&gt; mPersonProvider;</span><br><span class="line"></span><br><span class="line">  public MainActivity_MembersInjector(Provider&lt;Person&gt; mPersonProvider) &#123;</span><br><span class="line">    this.mPersonProvider = mPersonProvider;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public static MembersInjector&lt;MainActivity&gt; create(Provider&lt;Person&gt; mPersonProvider) &#123;</span><br><span class="line">    return new MainActivity_MembersInjector(mPersonProvider);&#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void injectMembers(MainActivity instance) &#123;</span><br><span class="line">    injectMPerson(instance, mPersonProvider.get());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  //1.在DaggerMainActivityComponent的injectMainActivity方法中将MainActivity对象和Person对象传入</span><br><span class="line">  @InjectedFieldSignature(&quot;com.base.example.dagger.simple.MainActivity.mPerson&quot;)</span><br><span class="line">  public static void injectMPerson(MainActivity instance, Person mPerson) &#123;</span><br><span class="line">    //2.这里的instance就是MainActivity,这里为MainActivity的mPerson对象赋值了刚传入的Person对象</span><br><span class="line">    instance.mPerson = mPerson;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>MainActivity_MembersInjector类是实例化Person类的关键，也是注入具体的实现方式。aggerMainActivityComponent的injectMainActivity方法中将MainActivity对象和Person对象传入,<br>然后对MainActivity的mPerson对象赋值了刚传入的Person对象.因此在MainActivity就完成了Person的依赖注入.MainActivity持有了Person对象.</p>
<h3 id="3-带Module的Inject方式（Inject-Component-Module）"><a href="#3-带Module的Inject方式（Inject-Component-Module）" class="headerlink" title="3.带Module的Inject方式（Inject+Component+Module）"></a>3.带Module的Inject方式（Inject+Component+Module）</h3><p>在上面的Person中是自己定义的类，如果是某个库中的类，我们不能够改它的源码因此是不能够去该类中添加@Inject注解了，那么注入这种类该如何注入呢，这个时候就需要Module。<br>Module可以理解为对象的实例化，向Component的提供依赖对象。下面以Person类为对象说明：<br>1 .创建一个MainModule，并用@Module注解，在类中提供Person对象的方法并用@Provider注解（取消之前Person类中的@Inject注解）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Module</span><br><span class="line">public class MainModule &#123;</span><br><span class="line">    @Provides</span><br><span class="line">    public Person providePerson()&#123;</span><br><span class="line">        return new Person();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>修改MainActivityComponent，为其添加Module应用，来说明其可能需要用到MainModule中提供的对象。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Component(modules = MainModule.class)</span><br><span class="line">public interface MainActivityComponent &#123;</span><br><span class="line">    void inject(MainActivity activity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>MainActivity保持不变</li>
</ol>
<p>执行结果:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MainActivity: xiaoming</span><br></pre></td></tr></table></figure>

<p>可以看出和上面的例子结果一样，主要不同的是增加了MainModule。我们接下来再来分析一下生成的源码.</p>
<p>DaggerMainActivityComponent.java:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">public final class DaggerMainActivityComponent implements MainActivityComponent &#123;</span><br><span class="line">  private final MainModule mainModule;</span><br><span class="line"></span><br><span class="line">  //3. 对DaggerMainActivityComponent中的mainModule进行赋值</span><br><span class="line">  private DaggerMainActivityComponent(MainModule mainModuleParam) &#123;</span><br><span class="line">    this.mainModule = mainModuleParam;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public static Builder builder() &#123;</span><br><span class="line">    return new Builder();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public static MainActivityComponent create() &#123;</span><br><span class="line">    return new Builder().build();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  //4.MainActivity中调用DaggerMainActivityComponent的inject方法将MainActivity的引用传入</span><br><span class="line">  @Override</span><br><span class="line">  public void inject(MainActivity activity) &#123;</span><br><span class="line">    injectMainActivity(activity);&#125;</span><br><span class="line"></span><br><span class="line">    //调用了MainActivity_MembersInjector的injectMPerson方法传入MainActivity的引用</span><br><span class="line">  private MainActivity injectMainActivity(MainActivity instance) &#123;</span><br><span class="line">    MainActivity_MembersInjector.injectMPerson(instance, MainModule_ProvidePersonFactory.providePerson(mainModule));</span><br><span class="line">    return instance;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public static final class Builder &#123;</span><br><span class="line">    private MainModule mainModule;</span><br><span class="line"></span><br><span class="line">    private Builder() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Builder mainModule(MainModule mainModule) &#123;</span><br><span class="line">      this.mainModule = Preconditions.checkNotNull(mainModule);</span><br><span class="line">      return this;</span><br><span class="line">    &#125;</span><br><span class="line">    //1.这里通过new关键字创建了MainModule对象.</span><br><span class="line">    public MainActivityComponent build() &#123;</span><br><span class="line">      if (mainModule == null) &#123;</span><br><span class="line">        this.mainModule = new MainModule();</span><br><span class="line">      &#125;</span><br><span class="line">      //2.通过new关键字创建DaggerMainActivityComponent对象将mainModule传入</span><br><span class="line">      return new DaggerMainActivityComponent(mainModule);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们看到调用MainActivity_MembersInjector.injectMPerson的时候的Person对象是通过MainModule_ProvidePersonFactory获取到的.<br>MainModule_ProvidePersonFactory.java:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public final class MainModule_ProvidePersonFactory implements Factory&lt;Person&gt; &#123;</span><br><span class="line">  private final MainModule module;</span><br><span class="line"></span><br><span class="line">  public MainModule_ProvidePersonFactory(MainModule module) &#123;</span><br><span class="line">    this.module = module;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public Person get() &#123;</span><br><span class="line">    return providePerson(module);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public static MainModule_ProvidePersonFactory create(MainModule module) &#123;</span><br><span class="line">    return new MainModule_ProvidePersonFactory(module);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  //1.调用MainModule的providePerson()方法返回Person对象</span><br><span class="line">  public static Person providePerson(MainModule instance) &#123;</span><br><span class="line">    return Preconditions.checkNotNull(instance.providePerson(), &quot;Cannot return null from a non-@Nullable @Provides method&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="5-Module带参数"><a href="#5-Module带参数" class="headerlink" title="5.Module带参数"></a>5.Module带参数</h3><p>一般情况下大多数的类都需要传入参数的，下面看下带参数的类的实例化是如何的。</p>
<ol>
<li>修改Person类<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class Person &#123;</span><br><span class="line"></span><br><span class="line">    private int age;</span><br><span class="line"></span><br><span class="line">    public Person(int age) &#123;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return &quot;mike&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getAge() &#123;</span><br><span class="line">        return age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>将Person类的age参数传入<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Module</span><br><span class="line">public class MainModule &#123;</span><br><span class="line">    int age;</span><br><span class="line">    public MainModule(int age)&#123;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    @Provides</span><br><span class="line">    public Person providePerson()&#123;</span><br><span class="line">        return new Person(age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
3 .在MainActivity中设置MainModule对象的参数<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DaggerMainActivityComponent.builder().mainModule(new MainModule(19)).build().inject(this);</span><br></pre></td></tr></table></figure>
执行结果:<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MainActivity: 19</span><br><span class="line"></span><br></pre></td></tr></table></figure>
需要注意的是在无参数的时候，DaggerMainActivityComponent会提供create方法，但是有参数时，只有build方法，因为需要传入MainModule对象<br>。一般建议通过provide方法提供参数，主要是解耦和增加代码的可读性。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@Module</span><br><span class="line">public class MainModule &#123;</span><br><span class="line">    int age;</span><br><span class="line">    public MainModule(int age)&#123;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Provides</span><br><span class="line">    public int provideAge()&#123;</span><br><span class="line">        return age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Provides</span><br><span class="line">    public Person providePerson()&#123;</span><br><span class="line">        return new Person(age);</span><br><span class="line">    &#125;</span><br><span class="line">    @Provides</span><br><span class="line">    public Decorate providerDecorate()&#123;</span><br><span class="line">        return new Decorate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
Module中不能出现参数和返回参数一致的情况，否则会导致死循环。如：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Provides</span><br><span class="line">public int provideAge(int age)&#123;</span><br><span class="line">    return age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="四-Inject-和-Provides-的优先级"><a href="#四-Inject-和-Provides-的优先级" class="headerlink" title="四.@Inject 和 @Provides 的优先级"></a>四.@Inject 和 @Provides 的优先级</h1><p>Dagger2 依赖查找的顺序是先查找 Module 内所有的 @Provides 提供的依赖，如果查找不到再去查找 @Inject 提供的依赖。</p>
<ul>
<li>步骤1：查找Module中是否存在创建该类的方法。</li>
<li>步骤2：若存在创建类方法，查看该方法是否存在参数</li>
<li>步骤2.1：若存在参数，则按从步骤1开始依次初始化每个参数</li>
<li>步骤2.2：若不存在参数，则直接初始化该类实例，一次依赖注入到此结束</li>
<li>步骤3：若不存在创建类方法，则查找Inject注解的构造函数，看构造函数是否存在参数</li>
<li>步骤3.1：若存在参数，则从步骤1开始依次初始化每个参数</li>
<li>步骤3.2：若不存在参数，则直接初始化该类实例，一次依赖注入到此结束</li>
</ul>
<h1 id="五-Scope作用域"><a href="#五-Scope作用域" class="headerlink" title="五.Scope作用域"></a>五.Scope作用域</h1><h3 id="1-Scope作用域"><a href="#1-Scope作用域" class="headerlink" title="1.Scope作用域"></a>1.Scope作用域</h3><p>scope 就是作用域的意思，在不使用@Scope的情况下，每次注入的对象都会是一个新的不同的对象，而@Scope能限制被注入的对象.<br>在MainActivity中注入两个Person对象</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@Inject</span><br><span class="line">Person person1;</span><br><span class="line">@Inject</span><br><span class="line">Person person2;</span><br><span class="line">@Override</span><br><span class="line">protected void onCreate(@Nullable Bundle savedInstanceState) &#123;</span><br><span class="line">    super.onCreate(savedInstanceState);</span><br><span class="line">    setContentView(R.layout.activity_main);</span><br><span class="line">    DaggerMainActivityComponent.builder().mainModule(new MainModule(19)).build().inject(this);</span><br><span class="line">    Log.d(TAG,&quot;person1 hash:&quot;+person1.toString());</span><br><span class="line">    Log.d(TAG,&quot;person2 hash:&quot;+person2.toString());</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行程序可以看到可以看到person1和person2的hash值并不相同,因此说明它们是两个不同的对象.在 dagger2 中，@scope 的一个默认实现就是 @Singleton.</p>
<h3 id="2-Singleton注解"><a href="#2-Singleton注解" class="headerlink" title="2.Singleton注解"></a>2.Singleton注解</h3><p>如果标注了Scope注解，那么注入器可能就会保持这个实例，下次注入需要这个依赖时就可以重用了.@scope 的一个默认实现就是 @Singleton.<br>@Singleton，这是一个标注了@Scope的注解</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Identifies a type that the injector only instantiates once. Not inherited.</span><br><span class="line"> *</span><br><span class="line"> * @see javax.inject.Scope @Scope</span><br><span class="line"> */</span><br><span class="line">@Scope</span><br><span class="line">@Documented</span><br><span class="line">@Retention(RUNTIME)</span><br><span class="line">public @interface Singleton &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>从Scope文档中的示例可以看出，这个Singleton的写法并没有什么特殊的，仅仅是在文档注释写了句标记单例的类型.实际上，Scope就是作为一种类型的标记而已，而这种标记的目的是为了更好地区分作用域.<br>@Scope所描述的注解用于两个地方：</p>
<ul>
<li>Component类</li>
<li>Module中用于创建实例的provideXXX方法</li>
</ul>
<p>使用Singleton注解来看看效果.</p>
<ol>
<li>在PersonModule中加入<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Module</span><br><span class="line">public class PersonModule &#123;</span><br><span class="line">    @Provides</span><br><span class="line">    @Singleton  //1.添加@Singleton标明该方法产生只产生一个实例</span><br><span class="line">    public Person providePerson()&#123;</span><br><span class="line">        return new Person();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>在Component中加入</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Singleton //2.添加@Singleton标明该Component中有Module使用了@Singleton</span><br><span class="line">@Component(modules = PersonModule.class)</span><br><span class="line">interface ScopeComponent &#123;</span><br><span class="line">    void inject(DaggerScopeActivity daggerActivity);//针对这个参数对象进行依赖注入</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>添加完Singleton注解以后.再次运行程序.我们发现在MainActivity中person1和person2的hash值相同.说明他们在MainActivity中保持了单例.</p>
<p>我们通过分析Dagger自动生成的代码来分析如何实现单例的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">public final class DaggerMainActivityComponent implements MainActivityComponent &#123;</span><br><span class="line">  private Provider&lt;Person&gt; providePersonProvider;</span><br><span class="line"></span><br><span class="line">  private DaggerMainActivityComponent(MainModule mainModuleParam) &#123;</span><br><span class="line">    //2. 这里会调用initialize方法</span><br><span class="line">    initialize(mainModuleParam);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public static Builder builder() &#123;</span><br><span class="line">    return new Builder();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public static MainActivityComponent create() &#123;</span><br><span class="line">    return new Builder().build();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">  private void initialize(final MainModule mainModuleParam) &#123;</span><br><span class="line">    //2.根据MainModule创建providePersonProvider对象</span><br><span class="line">    this.providePersonProvider = DoubleCheck.provider(MainModule_ProvidePersonFactory.create(mainModuleParam));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void inject(MainActivity activity) &#123;</span><br><span class="line">    injectMainActivity(activity);&#125;</span><br><span class="line"></span><br><span class="line">  private MainActivity injectMainActivity(MainActivity instance) &#123;</span><br><span class="line">    //3.providePersonProvider是单例的所以providePersonProvider.get()获取到的对象也是相同的</span><br><span class="line">    MainActivity_MembersInjector.injectMPerson(instance, providePersonProvider.get());</span><br><span class="line">    MainActivity_MembersInjector.injectMPerson2(instance, providePersonProvider.get());</span><br><span class="line">    return instance;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public static final class Builder &#123;</span><br><span class="line">    private MainModule mainModule;</span><br><span class="line"></span><br><span class="line">    private Builder() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Builder mainModule(MainModule mainModule) &#123;</span><br><span class="line">      this.mainModule = Preconditions.checkNotNull(mainModule);</span><br><span class="line">      return this;</span><br><span class="line">    &#125;</span><br><span class="line">    //1.通过build方法会创建一个MainModule对象</span><br><span class="line">    public MainActivityComponent build() &#123;</span><br><span class="line">      if (mainModule == null) &#123;</span><br><span class="line">        this.mainModule = new MainModule();</span><br><span class="line">      &#125;</span><br><span class="line">      return new DaggerMainActivityComponent(mainModule);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在创建DaggerMainActivityComponent时会调用initialize生成providePersonProvider对象.<br>MainModule_ProvidePersonFactory.java:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public final class MainModule_ProvidePersonFactory implements Factory&lt;Person&gt; &#123;</span><br><span class="line">  private final MainModule module;</span><br><span class="line"></span><br><span class="line">  public MainModule_ProvidePersonFactory(MainModule module) &#123;</span><br><span class="line">    this.module = module;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public Person get() &#123;</span><br><span class="line">    return providePerson(module);</span><br><span class="line">  &#125;</span><br><span class="line">  //1.通过new关键字创建MainModule_ProvidePersonFactory对象</span><br><span class="line">  public static MainModule_ProvidePersonFactory create(MainModule module) &#123;</span><br><span class="line">    return new MainModule_ProvidePersonFactory(module);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public static Person providePerson(MainModule instance) &#123;</span><br><span class="line">    return Preconditions.checkNotNull(instance.providePerson(), &quot;Cannot return null from a non-@Nullable @Provides method&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在DaggerMainActivityComponent的inject方法中providePersonProvider是单例的所以providePersonProvider.get()获取到的对象也是相同的.就算换个Scope，生成的也是一样的代码.<br>这个单例只针对同一个Component实例的情况下，毕竟Component本身也是能重复创建的,Dagger通过Singleton创建出来的单例并不保持在静态域上，而是保留在Component实例中。</p>
<p>那在别的Activity中是否也会是使用MainActivity中的单例对象呢?<br>我们再添加一个界面SecondActivity.<br>在SecondActivity中注入两个Person对象</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@Inject</span><br><span class="line">Person person3;</span><br><span class="line">@Inject</span><br><span class="line">Person person4;</span><br><span class="line">@Override</span><br><span class="line">protected void onCreate(@Nullable Bundle savedInstanceState) &#123;</span><br><span class="line">    super.onCreate(savedInstanceState);</span><br><span class="line">    setContentView(R.layout.activity_main);</span><br><span class="line">    DaggerMainActivityComponent.builder().mainModule(new MainModule(19)).build().inject(this);</span><br><span class="line">    Log.d(TAG,person1+&quot;&quot;);</span><br><span class="line">    Log.d(TAG,person2+&quot;&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重新运行程序.我们发现在SecondActivity中的person3和person4对象是相同的,但是并不和MainActivity中person1和person2的hash值相同.<br>这里也印证了我们上面的结论:用 @Singleton 确定的单例作用域应该也是在 Component 的范围内。这个范围在单个的 Component 中。<br>MainActivity 和 SecondActivity 运用了不同的 Component 即使他们都添加了@Singleton 注解 MainActivity 和 SecondActivity 中的生成的对象 也不是同一个。<br>如果在应用的Application中创建Component，在Activity中进行注入,那么被注入的对象在整个应用程序中就是单例的。</p>
<p>**在 Dagger2 中 Scope 机制可以保证在 Scope 标记的 Component 作用域内 ，类会保持单例 **</p>
<p>并不是只有 @Singleton  注解标记的相关类生产的实例是单例的，是所有的 Scope(自定义 Scope) 标记的相关类生产的实例 都是单例 的，只不过这个单例是有条件的 – 在 Scope 注解标记 Component 的作用域内生产的实例是单例的 。<br>Scope 机制下的单例其实和 @Singleton 的字面意义 没有一点点关系，可以把 @Singleton  换成任意单词，什么 @Dog、@Cat、@XXx 都可以，你只要保证这个注解标记的 Component 在 App 进程中为单例的，并且得到正确的实现(被正确的标记到 类构造器 或 Module 中的 @Provides 标记的方法)，那么它对应生成的类实例就是 单例 的。<br>@Singleton 之所以被默认实现，只是因为这可以让人根据它的字面意思，知道被他标记的相关生成的类实例为单例，这符合了 Java 的命名规范。<br>例如我们要创建整个应用程序中的单例对象:<br>MyApplication.Java:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class MyApplication extends Application &#123;</span><br><span class="line"></span><br><span class="line">    ActivityComponent activityComponent;</span><br><span class="line">    @Override</span><br><span class="line">    public void onCreate() &#123;</span><br><span class="line">        super.onCreate();</span><br><span class="line">        activityComponent = DaggerActivityComponent.builder().build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static MyApplication getApplication(Context context)&#123;</span><br><span class="line">        return (MyApplication) context.getApplicationContext();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   public ActivityComponent getActivityComponent()&#123;</span><br><span class="line">        return activityComponent;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>FirstActivity.java:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class FirstActivity extends AppCompatActivity &#123;</span><br><span class="line">    private TextView mContentTextView;</span><br><span class="line"></span><br><span class="line">    @Inject</span><br><span class="line">    Person person1;</span><br><span class="line">    @Inject</span><br><span class="line">    Person person2;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_singleton_and_scope);</span><br><span class="line">        mContentTextView = (TextView) findViewById(R.id.contentTextView);</span><br><span class="line">        //通过Application中的Component注入</span><br><span class="line">        MyApplication.getApplication(this).getActivityComponent().inject(this);</span><br><span class="line">        mContentTextView.setText(person1.hashCode() + &quot;\n&quot; + person2.hashCode());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>SecondActivity.java</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class SecondActivity extends AppCompatActivity &#123;</span><br><span class="line">    private TextView mContentTextView;</span><br><span class="line"></span><br><span class="line">    @Inject</span><br><span class="line">    Person person1;</span><br><span class="line">    @Inject</span><br><span class="line">    Person person2;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_singleton_and_scope);</span><br><span class="line">        mContentTextView = (TextView) findViewById(R.id.contentTextView);</span><br><span class="line">        //通过Application中的Component注入</span><br><span class="line">        MyApplication.getApplication(this).getActivityComponent().inject(this);</span><br><span class="line">        mContentTextView.setText(person1.hashCode() + &quot;\n&quot; + person2.hashCode());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>按照如上修改我们就可以得到全局的单例对象.</p>
<h3 id="3-自定义-Scope"><a href="#3-自定义-Scope" class="headerlink" title="3.自定义@Scope"></a>3.自定义@Scope</h3><p>对于Android，我们通常会定义一个针对整个APP全生命周期的@PerApp的Scope注解,通过仿照@Singleton</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Scope</span><br><span class="line">@Documented</span><br><span class="line">@Retention(RUNTIME)</span><br><span class="line">public @interface PerApp&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>你可能会发现，这个自定义的@Scope 和@Singleton代码完全一样，那@PerApp是不是也能具有实现单例模式的功能?答案是肯定的.<br>那你可能会有疑问，既然功能都是一样的，干嘛还自定义@Scope 结论就是不同的@Scope ，定义单例对象的生命周期，也就是使用范围。<br>在写代码时，程序员更加清楚什么时候创建Component，什么时候结束。</p>
<p>自定义@Scope总结起来有以下两点好处：</p>
<ul>
<li><p>更好的管理ApplicationComponent和Module之间的关系，Component和Component之间的依赖和继承关系。如果关系不匹配，在编译期间会报错</p>
</li>
<li><p>代码可读性，让程序猿更好的了解Module中创建的类实例的使用范围。</p>
</li>
</ul>
<p>@Singleton”并没有真正为你产生单列”，该注解只是保证只是在同一个Component对象中是单列而已，不同的Component进行注入，就会导致不是单例了，真正要实现全局单列，还是得靠自己控制，保证我们所有的地方都是使用同一个Component注入的对象.</p>
<p>总结的结论：</p>
<ul>
<li>必须使用同一个Component对象来生成，也就是DaggerActivityComponent.builder().build()只能执行一次。</li>
<li>Component和它的Module要使用相同的Scope。同一个Module中需要使用同样的Scope，否则相应的Component不知道使用什么Scope。</li>
<li>有依赖关系或者包含关系的Component不能使用同样的Scope。</li>
</ul>
<blockquote>
<p>注意，Scope只的单例是在Component的生命周期中相关依赖是单例的，也就是同一个Component对象注入的同类型的依赖是相同的。按上面例子，如果我们又创建了个AppComponent，它注入的InfoRepository对象与之前的肯定不是一个。<br>这里所谓的「生命周期」是与 Component 相关联的。与 Activity 等任何 Android 组件没有任何关系.</p>
</blockquote>
<h1 id="六-Named和-Qualifier注解"><a href="#六-Named和-Qualifier注解" class="headerlink" title="六.@Named和@Qualifier注解"></a>六.@Named和@Qualifier注解</h1><p>如果一个类有多个构造方法，或者有两个相同依赖时，它们都继承同一个父类或者实现同一个接口，那么怎么区分呢？这就要用到@Named或者@Qualifier注解了。</p>
<h3 id="1-Named"><a href="#1-Named" class="headerlink" title="1. @Named"></a>1. @Named</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class Car &#123;</span><br><span class="line">    private String engine = &quot;默认引擎&quot;;</span><br><span class="line">    private String tyre = &quot;默认轮胎&quot;;</span><br><span class="line">    private String color = &quot;默认颜色&quot;;</span><br><span class="line"></span><br><span class="line">    public Car() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Car(String engine) &#123;</span><br><span class="line">        this.engine = engine;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Car(String engine, String tyre) &#123;</span><br><span class="line">        this.engine = engine;</span><br><span class="line">        this.tyre = tyre;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Car(String engine, String tyre, String color) &#123;</span><br><span class="line">        this.engine = engine;</span><br><span class="line">        this.tyre = tyre;</span><br><span class="line">        this.color = color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String make() &#123;</span><br><span class="line">        return &quot;改装完成车的引擎是:&quot; + engine + &quot; 车的颜色是:&quot; + color + &quot; 车的轮胎是:&quot; + tyre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">@Module</span><br><span class="line">public class QualifierModule &#123;</span><br><span class="line"></span><br><span class="line">    //普通车</span><br><span class="line">    @Provides</span><br><span class="line">    @Named(&quot;nomal&quot;)</span><br><span class="line">    public Car defaultCarProvides() &#123;</span><br><span class="line">        return new Car();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //赛车</span><br><span class="line">    @Provides</span><br><span class="line">    @Named(&quot;racing&quot;)</span><br><span class="line">    public Car racingCarProvides() &#123;</span><br><span class="line">        return new Car(&quot;赛车引擎&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //自定义改装车</span><br><span class="line">    @Provides</span><br><span class="line">    @Named(&quot;custom&quot;)</span><br><span class="line">    public Car customCarProvides() &#123;</span><br><span class="line">        return new Car(&quot;赛车引擎&quot;, &quot;米其林轮胎&quot;, &quot;红色&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class  DaggerQualifierActivity extends AppCompatActivity() &#123;</span><br><span class="line"></span><br><span class="line">    //普通车</span><br><span class="line">    @Inject</span><br><span class="line">    @Named(&quot;nomal&quot;)</span><br><span class="line">    Car defaultCar;</span><br><span class="line"></span><br><span class="line">    //赛车</span><br><span class="line">    @Inject</span><br><span class="line">    @Named(&quot;racing&quot;)</span><br><span class="line">    Car racingCar;</span><br><span class="line"></span><br><span class="line">    //自定义改装车</span><br><span class="line">    @Inject</span><br><span class="line">    @Named(&quot;custom&quot;)</span><br><span class="line">    Car customCar;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.test_activity_dagger_qualifier);</span><br><span class="line">        DaggerQualifierComponent.builder().qualifierModule(QualifierModule()).build().Inject(this)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-Qualifier"><a href="#2-Qualifier" class="headerlink" title="2.@Qualifier"></a>2.@Qualifier</h3><p>以上通过 @Named 实现的标识功能 @Qualifier 同样可以实现，但是需要我们自定义注解来完成，具体一个使用场景如下：</p>
<p>自定义注解</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Qualifier</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">public @interface UserThirdQualifier &#123;</span><br><span class="line">    String value() default &quot;&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，这里自定义注解需要使用 @Qualifier 进行标注。</p>
<p>Module 类中标记</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@Module</span><br><span class="line">public class UserThirdModule &#123;</span><br><span class="line"></span><br><span class="line">    @UserThirdQualifier(&quot;c&quot;)</span><br><span class="line">    @Provides</span><br><span class="line">    UserThird provideUserThird()&#123;</span><br><span class="line">        return new UserThird(&quot;男&quot;,1243);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @UserThirdQualifier(&quot;d&quot;)   </span><br><span class="line">    @Provides</span><br><span class="line">    UserThird provideUserThirdWithoutParams() &#123;</span><br><span class="line">        return new UserThird();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>目标类</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class ThirdActivity extends AppCompatActivity &#123;</span><br><span class="line">    @UserThirdQualifier(&quot;c&quot;)</span><br><span class="line">    @Inject</span><br><span class="line">    UserThird mUserTwoC;</span><br><span class="line"></span><br><span class="line">    @UserThirdQualifier(&quot;d&quot;)</span><br><span class="line">    @Inject</span><br><span class="line">    UserThird mUserTwoD;</span><br><span class="line"></span><br><span class="line">    private static final String TAG = &quot;SecondActivity&quot;;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_second);</span><br><span class="line">        DaggerUserThirdComponent.builder().userThirdModule(new UserThirdModule()).build().injectToThirdActivity(this);</span><br><span class="line">        Log.e(TAG, &quot;onCreate: &quot; + &quot;sex&quot; + mUserTwoC.getSex() + &quot; number：&quot; + mUserTwoC.getCarNum());</span><br><span class="line">        mUserTwoC.setCarNum(46);</span><br><span class="line">        mUserTwoC.setSex(&quot;女&quot;);</span><br><span class="line">        Log.e(TAG, &quot;onCreate: &quot; + &quot;sex&quot; + mUserTwoC.getSex() + &quot; number：&quot; + mUserTwoC.getCarNum());</span><br><span class="line">        Log.e(TAG, &quot;onCreate: &quot; + &quot;sex&quot; + mUserTwoD.getSex() + &quot; number：&quot; + mUserTwoD.getCarNum());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样的，以上代码需要重点关注的是 Module 类 中使用 @UserThirdQualifier 注解方法和在 目标类 中使用 @UserThirdQualifier 注解标记类的实例变量，并且 Module 中的 @UserThirdQualifier(“c”) 和 目标类中的 @UserThirdQualifier(“c”)是一 一对应的。</p>
<h1 id="七-Dagger2-中的懒加载和重加载"><a href="#七-Dagger2-中的懒加载和重加载" class="headerlink" title="七.Dagger2 中的懒加载和重加载"></a>七.Dagger2 中的懒加载和重加载</h1><h3 id="1-Dagger2-中的懒加载"><a href="#1-Dagger2-中的懒加载" class="headerlink" title="1. Dagger2 中的懒加载"></a>1. Dagger2 中的懒加载</h3><p>智能懒加载，是Dagger2实现高性能的重要举措之一：在需要的时候才对成员变量进行初始化，可以大幅缩短应用初始化的时间。</p>
<p>使用方法：用Lazy<T>修饰变量即可。Lazy 是泛型类，接受任何类型的参数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">    @Inject</span><br><span class="line">    Lazy&lt;Object&gt; object;</span><br><span class="line">```    </span><br><span class="line">用Lazy&lt;T&gt;修饰需要被注入的对象即可。</span><br></pre></td></tr></table></figure>
<p>public class Car {<br>    &#x2F;**<br>     * @Inject：@Inject有两个作用，一是用来标记需要依赖的变量，以此告诉Dagger2为它提供依赖<br>     *&#x2F;<br>    @Inject<br>    Lazy<Engine> engine;</p>
<pre><code>public Car() &#123;
    DaggerCarComponent.builder().build().inject(this);
&#125;

public Engine getEngine() &#123;
    return this.engine;
&#125;

public static void main(String ... args)&#123;
    Car car = new Car();
    System.out.println(car.getEngine());
&#125;
</code></pre>
<p>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">### 2.Provider 强制重新加载</span><br><span class="line">@Singleton 标注实现的单例可以让我们每次获取的都是同一个对象（暂不细究全局/局部单例），但有时，我们希望每次都创建一个新的实例，这种情况与 @Singleton 完全相反。</span><br><span class="line">Dagger2 通过 Provider 就可以实现。它的使用方法和 Lazy 很类似。</span><br><span class="line"></span><br><span class="line">使用方法：用Provider&lt;T&gt;修饰变量即可。Provider是泛型类，接受任何类型的参数。 </span><br></pre></td></tr></table></figure>
<pre><code>@Inject
Provider&lt;Object&gt; object;
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">用Provider&lt;T&gt;修饰需要被注入的对象即可。 </span><br></pre></td></tr></table></figure>
<p>public class Car {<br>    &#x2F;**<br>     * @Inject：@Inject有两个作用，一是用来标记需要依赖的变量，以此告诉Dagger2为它提供依赖<br>     *&#x2F;<br>    @Inject<br>    Provider<Engine> engine;</p>
<pre><code>public Car() &#123;
    DaggerCarComponent.builder().build().inject(this);
&#125;

public Engine getEngine() &#123;
    return this.engine;
&#125;

public static void main(String ... args)&#123;
    Car car = new Car();
    System.out.println(car.getEngine());
&#125;
</code></pre>
<p>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">但是，需要注意的是 Provider 所表达的重新加载是说每次重新执行 Module 相应的 @Provides 方法，如果这个方法本身每次返回同一个对象，那么每次调用 get() 的时候，对象也会是同一个。</span><br><span class="line"></span><br><span class="line"># 八.Component间依赖的两种方式</span><br><span class="line">Component 管理着依赖实例，根据依赖实例之间的关系就能确定 Component 的关系。在 Dagger 2 中 Component 的组织关系分为两种：dependence和subcomponent，有些像组合和继承的关系。</span><br><span class="line">- 依赖关系：一个 Component 依赖其他 Compoent ，以获得其中公开的依赖实例，用 Component 中的dependencies声明。</span><br><span class="line">- 继承关系：一个 Component 继承（扩展）其他的 Component， 以获得其他的Component中的依赖，SubComponent 就是继承关系的体现。</span><br><span class="line">### 1.Dependence方式</span><br><span class="line">Component 依赖 是通过 @Component 的注解中 dependencies 选项来标识的，意思是指 该 Component 依赖 dependencies 指定的 Component 。</span><br><span class="line">举个例子，看以下代码：</span><br><span class="line">创建RetrofitUtils网络请求工具</span><br></pre></td></tr></table></figure>
<p>public class RetrofitUtils {<br>    public String doNetWork() {<br>        return “网络请求到数据了:xxx”;<br>    }<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">创建JsonUtils解析工具</span><br></pre></td></tr></table></figure>
<p>public class JsonUtils {<br>    &#x2F;&#x2F;解析Json数据<br>    public String parseJson(String json) {<br>        return “解析过后的Json数据:” + json;<br>    }<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">创建NetWorkModule提供RetrofitUtils和JsonUtils对象</span><br></pre></td></tr></table></figure>
<p>@Module<br>public class NetWorkModule {<br>    &#x2F;&#x2F;向外提供JsonUrils对象<br>    @Provides<br>    JsonUtils providesGson() {<br>        return new JsonUtils();<br>    }</p>
<pre><code>//向外提供RetrofitUtils对象
@Provides
RetrofitUtils providesRetrofit() &#123;
    return new RetrofitUtils();
&#125;
</code></pre>
<p>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">以MVP架构为例:在Presenter中我们需要用到RetrofitUtils来请求网络数据,还需要用到JsonUtils来解析数据.</span><br></pre></td></tr></table></figure>
<p>public class Presenter {</p>
<pre><code>private JsonUtils mJsonUtils;

private RetrofitUtils mNetWorkUtils;


public Presenter(JsonUtils jsonUtils, RetrofitUtils netWorkUtils) &#123;
    this.mJsonUtils = jsonUtils;
    this.mNetWorkUtils = netWorkUtils;
&#125;

public String doNetWork() &#123;
    String respon = mNetWorkUtils.doNetWork();//请求网络数据
    String jsonString = mJsonUtils.parseJson(respon);//解析网路数据
    return jsonString;
&#125;
</code></pre>
<p>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">创建提供Presenter的PresenterModule</span><br></pre></td></tr></table></figure>
<p>@Module<br>public class PresenterModule {<br>    &#x2F;&#x2F;这里的JsonUtils和RetrofitUtils 是通过PresenterComponent里dependencies &#x3D; NetWorkComponent,从NetWorkComponent里面获取的.<br>    @Provides<br>    public Presenter providesPresenter(JsonUtils jsonUtils, RetrofitUtils retrofitUtils) {<br>        return new Presenter(jsonUtils, retrofitUtils);<br>    }<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">创建NetWork依赖注入接口NetWorkComponent</span><br></pre></td></tr></table></figure>
<p>@Component(modules &#x3D; NetWorkModule.class)<br>public interface NetWorkComponent {</p>
<pre><code>//将NetWorkModule中的Gson对象、WorkUtils暴露出来，以便于其他依赖于NetWorkComponent的Component调用
JsonUtils getGson();

RetrofitUtils getNetWorkUtils();

//自己本身也可以座位Component进行注入
//void inject(DaggerDependenciesActivity daggerDependenciesActivity);
</code></pre>
<p>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">创建PresenterComponent依赖注入对象:</span><br></pre></td></tr></table></figure>
<p>@Component(modules &#x3D; PresenterModule.class, dependencies &#x3D; NetWorkComponent.class)<br>public interface PresenterComponent {<br>    void inject(DaggerDependenciesActivity daggerDependenciesActivity);<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">DaggerDependenciesActivity.java</span><br></pre></td></tr></table></figure>
<p>public class DaggerDependenciesActivity extends AppCompatActivity {<br>    @Inject<br>    Presenter mPresenter;<br>    @Inject<br>    RetrofitUtils mRetrofitUtils;<br>    @Inject<br>    JsonUtils mJsonUtils;</p>
<pre><code>@Override
protected void onCreate(@Nullable Bundle savedInstanceState) &#123;
    super.onCreate(savedInstanceState);
    setContentView(R.layout.test_activity_dagger_dependencies);
    DaggerPresenterComponent.builder().netWorkComponent(DaggerNetWorkComponent.create()).presenterModule(new PresenterModule()).build().inject(this);
    findViewById(R.id.btn_test).setOnClickListener(v -&gt; &#123;
        ToastUtils.showShort(mPresenter.doNetWork());
    &#125;);
&#125;
</code></pre>
<p>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">### 2.SubComponent</span><br><span class="line">@SubComponent  也是管理 Component 间的依赖，不同的是这种方式不需要 在被依赖的 Component 中显式的声明可以获取相应类实例的方法。</span><br><span class="line">通过 @SubComponent 来管理的 Component 之间是一种 继承关系，子 Component 理所当然的可以使用父 Component 的可以提供的类实例</span><br><span class="line"></span><br><span class="line">子Component需要使用@Subcomponent注解，同时需要提供一个Builder接口，供父Component来生成Component，Builder接口中需提供一个返回子Component的抽象接口方法</span><br><span class="line">子组件可以使用父组件所有的Module实现进行依赖注入，同时在构建子组件时的代码实现方式也和构建组件依赖时不一样。</span><br><span class="line"></span><br><span class="line">首先定义一个使用@Subcomponent注解的依赖注入组件接口：</span><br></pre></td></tr></table></figure>
<p>@Subcomponent(modules &#x3D; {SubModule.class})<br>public interface MySubComponent {<br>    void inject(SubActivity activity);<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">它依赖的 SubModule 为：</span><br></pre></td></tr></table></figure>
<p>@Module<br>public class SubModule {<br>    @Provides<br>    public Flower provideFlower() {<br>        return new Flower(“腊梅”, “红色”);<br>    }<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果我们想让 DetailComponent 做为 MySubComponent 的父组件，则需要在 DetailComponent 中定义一个返回 MySubComponent 的方法，方法参数为其依赖的 Module 类型：</span><br></pre></td></tr></table></figure>
<p>@DetailActivityScope<br>@Component(modules &#x3D; {DetailModule.class})<br>public interface DetailComponent {<br>    void inject(DetailActivity activity);</p>
<pre><code>// 定义返回子组件的方法，参数为子组件需要的module
MySubComponent getSubComponent(SubModule module);
</code></pre>
<p>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">到这里我们的子组件就实现完成了，如何使用呢？子依赖注入注入组件是不能单独直接使用的，因为编译后并不会生成类似DaggerMySubComponent的辅助类，所以需要通过父组件来获取，</span><br><span class="line">这也是我们需要在父组件中定义返回子组件方法的原因。具体的用法如下：</span><br></pre></td></tr></table></figure>
<p>public class SubActivity extends AppCompatActivity {<br>    @Inject<br>    Book book;</p>
<pre><code>@Inject
Flower flower;

public static void start(Context context) &#123;
    context.startActivity(new Intent(context, SubActivity.class));
&#125;

@Override
protected void onCreate(Bundle savedInstanceState) &#123;
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_sub);
    // 创建父组件对象
    DetailComponent detailComponent = DaggerDetailComponent.builder().detailModule(new DetailModule()).build();
    // 得到子组件，并完成依赖注入
    detailComponent.getSubComponent(new SubModule()).inject(this);

    Log.e(&quot;SubActivity-book&quot;, book.toString());
    Log.e(&quot;flower&quot;, flower.toString());
&#125;
</code></pre>
<p>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">我们并没有在 SubModule 中定义提供 Flowerd 对象的方法，但是同过这种“继承”，MySubComponent 就可以提供 Flower 对象了.</span><br><span class="line"></span><br><span class="line">### 5.依赖关系 vs 继承关系</span><br><span class="line">相同点：</span><br><span class="line">- 两者都能复用其他 Component 的依赖</span><br><span class="line">- 有依赖关系和继承关系的 Component 不能有相同的 Scope</span><br><span class="line"></span><br><span class="line">区别：</span><br><span class="line">- 依赖关系中被依赖的 Component 必须显式地提供公开依赖实例的接口，而 SubComponent 默认继承 parent Component 的依赖。</span><br><span class="line">- 依赖关系会生成两个独立的 DaggerXXComponent 类，而 SubComponent 不会生成 独立的 DaggerXXComponent 类。</span><br><span class="line">- 在 Android 开发中，Activity 是 App 运行中组件，Fragment 又是 Activity 一部分，这种组件化思想适合继承关系，所以在 Android 中一般使用 SubComponent。</span><br><span class="line"></span><br><span class="line">### 4.SubComponent 的其他问题</span><br><span class="line">抽象工厂方法定义继承关系</span><br><span class="line">除了使用 Module 的subcomponents属性定义继承关系，还可以在 parent Component 中声明返回 SubComponent 的抽象工厂方法来定义：</span><br></pre></td></tr></table></figure>
<p>@ManScope<br>@Component(modules &#x3D; CarModule.class)<br>public interface ManComponent {<br>    void injectMan(Man man);<br>    SonComponent sonComponent();    &#x2F;&#x2F; 这个抽象工厂方法表明 SonComponent 继承 ManComponent<br>}</p>
<pre><code>这种定义方式不能很明显地表明继承关系，一般推荐使用 Module 的subcomponents属性定义。

&gt;Component 之间共用相同依赖，可以有两种组织关系：依赖关系与继承关系。在 Android 开发中，一般使用继承关系，以 AppComponent 作为 root Component，
AppComponent 一般还会使用 @Singleton 作用域，而 ActivityComponent 为 SubComponent。

参考资料:
[史上最适合新手的Dagger2教程（一）基本注入](https://blog.csdn.net/u014653815/article/details/81201865)
[Android |《看完不忘系列》之dagger](https://juejin.cn/post/6865659377957732359#heading-8)
[深入浅出依赖注入框架Dagger2](https://blog.csdn.net/cao861544325/article/details/81070582)
[Android -- 带你从源码角度领悟Dagger2入门到放弃（一）](https://www.cnblogs.com/wjtaigwh/p/6739614.html)
[Android -- 带你从源码角度领悟Dagger2入门到放弃（二）](https://www.cnblogs.com/wjtaigwh/p/6740643.html)
[Android -- 带你从源码角度领悟Dagger2入门到放弃（三）](https://www.cnblogs.com/wjtaigwh/p/6744939.html)
[Android基础知识：Dagger2入门](https://juejin.cn/post/6844903840450347016#heading-7)
[Dagger2从入门到放弃再到恍然大悟](https://juejin.cn/post/6847902225679958023)
[Dagger 2 系列（一） -- 前奏篇：依赖注入的基本介绍](https://juejin.cn/post/6844903682908094471)
[Android 神兵利器Dagger2使用详解（一）基础使用](https://blog.csdn.net/mq2553299/article/details/73065745)
[Dagger 2 使用及原理](https://www.jianshu.com/p/9f737e477d60)
[听说你还不会用Dagger2？Dagger2 For Android最佳实践教程](https://juejin.cn/post/6844903696417947662)
[轻松学，听说你还没有搞懂 Dagger2](https://blog.csdn.net/briblue/article/details/75578459)
[Dagger2的组件依赖及使用详解](https://blog.csdn.net/lylodyf/article/details/53009042)
[Dagger2 in Android（二）进阶](http://www.chenhe.cc/p/186#i-4)
[Dagger 2 完全解析（三），Component 的组织关系与 SubComponent](https://johnnyshieh.me/posts/dagger-subcomponent/)
[Dagger2 Android应用：@Scope和@Subcomponent](https://cloud.tencent.com/developer/article/1179695)
[Dagger2利器系列二：懒/重加载+Component 的组织关系](https://blog.csdn.net/lucasxu01/article/details/105645626)
[Android | 从 Dagger2 到 Hilt 玩转依赖注入（一）](https://www.jianshu.com/p/32a17846c2b0)
[Dagger2学习笔记4(@Singleton 与@ Scope 实现全局单例与作用域单例)](https://www.jianshu.com/p/c822faa2c083)
[详解 Dagger2 的 @Scope 和 @Subcomponent](https://juejin.cn/post/6844903459909533710)
[Dagger2 in Android（三）Scope与生命周期](https://juejin.cn/post/6844904201223405575)
[Dagger 2 系列（六） -- 进阶篇：Component 依赖、@SubComponent 与多 Component 下的 Scope 使用限制](https://juejin.cn/post/6844903683843424264)
</code></pre>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://lxlfpeng.github.io">peng</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://lxlfpeng.github.io/2017/02/17/Android%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E6%A1%86%E6%9E%B6Dagger2%E5%85%A8%E9%9D%A2%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/">https://lxlfpeng.github.io/2017/02/17/Android%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E6%A1%86%E6%9E%B6Dagger2%E5%85%A8%E9%9D%A2%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://lxlfpeng.github.io" target="_blank">鹏哥的Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/">依赖注入</a></div><div class="post-share"><div class="social-share" data-image="/images/about_avatar.webp" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2017/05/19/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%90%86%E8%AE%BA%E6%80%BB%E7%BB%93-Java%E7%89%88/" title="面向对象设计模式理论总结-Java版"><img class="cover" src="/images/311e68177cc2ec89577840663136ab3e.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">面向对象设计模式理论总结-Java版</div></div><div class="info-2"><div class="info-item-1">一. 什么是UML类图?UML类图是一种结构图，用于描述一个系统的静态结构。类图以反映类结构和类之间关系为目的，用以描述软件系统的结构，是一种静态建模方法。类图中的类，与面向对象语言中的类的概念是对应的，因此又称统一建模语言，类图是使用频率最高的UML图之一。 二. 类图中的表示方式1.类在类图中的表示方式在UML类图中，类使用包含类名、属性(field) 和方法(method) 且带有分割线的矩形来表示，比如下图表示一个Employee类，它包含name、age和email这3个属性，以及modifyInfo()方法。对应代码： 123456789public class Employee &#123;    private String name;    private int age;    private String email;        public void modifyInfo() &#123;        ...   ...</div></div></div></a><a class="pagination-related" href="/2017/02/13/%E5%BC%80%E5%8F%91%E4%BA%BA%E5%91%98%E5%BF%85%E7%9F%A5%E7%9A%84%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/" title="开发人员必知的网络基础知识总结"><img class="cover" src="/images/dd71e626215b0002229989133ed60ac9.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">开发人员必知的网络基础知识总结</div></div><div class="info-2"><div class="info-item-1">一.网络分层模型1.什么是网络分层模型?为了减少网络设计的复杂性，大多数网络都采用了分层结构。在相同的网络中，处于第N层的机器之间使用第N层的协议进行通信。计算机网络的各层及其协议的集合被称为网络的体系结构，按照不同的维度，通常被分为七层、五层、四层网络结构。 2.七层网络模型开放式系统互联模型（Open System Interconnection Model，简称为 OSI 模型）是一种概念模型，由国际标准化组织提出，并试图成为计算机在世界范围内互连为网络的标准框架，它具有七层网络结构。主要是由：应用层（Application）、表示层（Presentation）、会话层（Session）、传输层（Transport）、网络层（Network）、数据链路层（Data Link）、物理层（Physical）构成。 3.四层网络模型互联网协议套件（Internet Protocol Suite，IPS）是多个网络传输协议的集合，它为网际网络的基础通信提供架构支撑。由于该协议族中最核心的两个协议分别为 TCP（传输控制协议）和 IP（网际协议），因此它也被称为...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2021/11/02/Android%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E6%A1%86%E6%9E%B6hilt%E4%BD%BF%E7%94%A8/" title="Android依赖注入框架hilt使用"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2021-11-02</div><div class="info-item-2">Android依赖注入框架hilt使用</div></div><div class="info-2"><div class="info-item-1">一.什么是HiltHilt 是Google 最新的依赖注入框架，其基于Dagger研发。Hilt可以说是专门为Android 打造，提供了一种将Dagger依赖项注入到Android应用程序的标准方法，而且创建了一些标准的组件和作用域，这些组件会自动集成到Android应用程序的各个生命周期中，以简化开发者的上手难度。 二. 引入Hilt1.AndroidStudio版本需要AndroidStudio4.0版本及以上以上 2.项目根目录build.gradle添加依赖1234567buildscript &#123;    ...    dependencies &#123;        ...        classpath &#x27;com.google.dagger:hilt-android-gradle-plugin:2.28-alpha&#x27;    &#125;&#125; 3.在module下的build.gradle添加以下依赖项：1234567891011121314151617...apply plugin:...</div></div></div></a><a class="pagination-related" href="/2020/10/12/Android%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E6%A1%86%E6%9E%B6%E4%B9%8BKoin/" title="Android依赖注入框架之Koin"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2020-10-12</div><div class="info-item-2">Android依赖注入框架之Koin</div></div><div class="info-2"><div class="info-item-1">一.依赖引入Koin是一款轻量级的依赖注入框架，根据官方的描述，它无代理，无代码生成，无反射。 12345678def koinVersion = &quot;2.2.2&quot;   //Koin for android   implementation &quot;org.koin:koin-android:$koinVersion&quot;   //Koin for scope feature   implementation &quot;org.koin:koin-android-scope:$koinVersion&quot;   //Koin for viewModel feature   implementation &quot;org.koin:koin-android-viewmodel:$koinVersion&quot;  二.基础使用在application中来做startkoin初始化的动作 123456789101112class MyApp : Application() &#123;    override fun onCreate()...</div></div></div></a></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="giscus-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/images/about_avatar.webp" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">peng</div><div class="author-info-description">过往不恋 未来不迎 当下不负</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">127</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">59</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">24</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/lxlfpeng"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/lxlfpeng" target="_blank" title="Github"><i class="fab fa-github" style="color: #4a7dbe;"></i></a><a class="social-icon" href="mailto:565289282@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎来到我的博客!</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80-%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5"><span class="toc-number">1.</span> <span class="toc-text">一 依赖注入</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C-%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E5%AE%9E%E7%8E%B0%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-number">2.</span> <span class="toc-text">二 依赖注入实现的三种方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%9E%84%E9%80%A0%E6%B3%A8%E5%85%A5"><span class="toc-number">2.0.1.</span> <span class="toc-text">1. 构造注入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%B1%9E%E6%80%A7%E6%B3%A8%E5%85%A5"><span class="toc-number">2.0.2.</span> <span class="toc-text">2. 属性注入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E9%80%9A%E8%BF%87Java%E6%B3%A8%E8%A7%A3"><span class="toc-number">2.0.3.</span> <span class="toc-text">3. 通过Java注解</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89-Dagger2%E6%B3%A8%E8%A7%A3%E4%BD%BF%E7%94%A8"><span class="toc-number">3.</span> <span class="toc-text">三 Dagger2注解使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Dagger2%E7%9A%84%E4%BE%9D%E8%B5%96%E5%BC%95%E5%85%A5"><span class="toc-number">3.0.1.</span> <span class="toc-text">1.Dagger2的依赖引入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Inject%E6%96%B9%E5%BC%8F%E6%B3%A8%E5%85%A5%EF%BC%88Inject-Component%EF%BC%89"><span class="toc-number">3.0.2.</span> <span class="toc-text">2.Inject方式注入（Inject+Component）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%B8%A6Module%E7%9A%84Inject%E6%96%B9%E5%BC%8F%EF%BC%88Inject-Component-Module%EF%BC%89"><span class="toc-number">3.0.3.</span> <span class="toc-text">3.带Module的Inject方式（Inject+Component+Module）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-Module%E5%B8%A6%E5%8F%82%E6%95%B0"><span class="toc-number">3.0.4.</span> <span class="toc-text">5.Module带参数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9B-Inject-%E5%92%8C-Provides-%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">4.</span> <span class="toc-text">四.@Inject 和 @Provides 的优先级</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%94-Scope%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">5.</span> <span class="toc-text">五.Scope作用域</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Scope%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">5.0.1.</span> <span class="toc-text">1.Scope作用域</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Singleton%E6%B3%A8%E8%A7%A3"><span class="toc-number">5.0.2.</span> <span class="toc-text">2.Singleton注解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E8%87%AA%E5%AE%9A%E4%B9%89-Scope"><span class="toc-number">5.0.3.</span> <span class="toc-text">3.自定义@Scope</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AD-Named%E5%92%8C-Qualifier%E6%B3%A8%E8%A7%A3"><span class="toc-number">6.</span> <span class="toc-text">六.@Named和@Qualifier注解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Named"><span class="toc-number">6.0.1.</span> <span class="toc-text">1. @Named</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Qualifier"><span class="toc-number">6.0.2.</span> <span class="toc-text">2.@Qualifier</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%83-Dagger2-%E4%B8%AD%E7%9A%84%E6%87%92%E5%8A%A0%E8%BD%BD%E5%92%8C%E9%87%8D%E5%8A%A0%E8%BD%BD"><span class="toc-number">7.</span> <span class="toc-text">七.Dagger2 中的懒加载和重加载</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Dagger2-%E4%B8%AD%E7%9A%84%E6%87%92%E5%8A%A0%E8%BD%BD"><span class="toc-number">7.0.1.</span> <span class="toc-text">1. Dagger2 中的懒加载</span></a></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer" style="background: linear-gradient(20deg, #0062be, #925696, #cc426e, #fb0347);"><div id="footer-wrap"><div class="copyright">&copy;2015 - 2025 By peng</div><div class="footer_custom_text"> <a target="_blank" rel="nofollow noopener"><span>千里之行</span></a> <i class="iconfont icon-love"></i> <a target="_blank" rel="nofollow noopener"><span>始于足下</span></a> </div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.isShuoshuo
  const option = null

  const getGiscusTheme = theme => theme === 'dark' ? 'dark' : 'light'

  const createScriptElement = config => {
    const ele = document.createElement('script')
    Object.entries(config).forEach(([key, value]) => {
      ele.setAttribute(key, value)
    })
    return ele
  }

  const loadGiscus = (el = document, key) => {
    const mappingConfig = isShuoshuo
      ? { 'data-mapping': 'specific', 'data-term': key }
      : { 'data-mapping': (option && option['data-mapping']) || 'pathname' }

    const giscusConfig = {
      src: 'https://giscus.app/client.js',
      'data-repo': 'lxlfpeng/blog_comments',
      'data-repo-id': 'R_kgDONYoexA',
      'data-category-id': 'DIC_kwDONYoexM4Ck4JQ',
      'data-theme': getGiscusTheme(document.documentElement.getAttribute('data-theme')),
      'data-reactions-enabled': '1',
      crossorigin: 'anonymous',
      async: true,
      ...option,
      ...mappingConfig
    }

    const scriptElement = createScriptElement(giscusConfig)

    el.querySelector('#giscus-wrap').appendChild(scriptElement)

    if (isShuoshuo) {
      window.shuoshuoComment.destroyGiscus = () => {
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }
  }

  const changeGiscusTheme = theme => {
    const iframe = document.querySelector('#giscus-wrap iframe')
    if (iframe) {
      const message = {
        giscus: {
          setConfig: {
            theme: getGiscusTheme(theme)
          }
        }
      }
      iframe.contentWindow.postMessage(message, 'https://giscus.app')
    }
  }

  btf.addGlobalFn('themeChange', changeGiscusTheme, 'giscus')

  if (isShuoshuo) {
    'Giscus' === 'Giscus'
      ? window.shuoshuoComment = { loadComment: loadGiscus }
      : window.loadOtherComment = loadGiscus
    return
  }

  if ('Giscus' === 'Giscus' || !false) {
    if (false) btf.loadComment(document.getElementById('giscus-wrap'), loadGiscus)
    else loadGiscus()
  } else {
    window.loadOtherComment = loadGiscus
  }
})()</script></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="false"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>