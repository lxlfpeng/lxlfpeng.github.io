---
title: 开发人员必知的网络基础知识总结
date: 2017-02-13
categories: 
  - 网络基础
---

# 一.网络分层模型
### 1.什么是网络分层模型?
为了减少网络设计的复杂性，大多数网络都采用了分层结构。在相同的网络中，处于第N层的机器之间使用第N层的协议进行通信。计算机网络的各层及其协议的集合被称为网络的体系结构，按照不同的维度，通常被分为七层、五层、四层网络结构。

### 2.七层网络模型
开放式系统互联模型（Open System Interconnection Model，简称为 OSI 模型）是一种概念模型，由国际标准化组织提出，并试图成为计算机在世界范围内互连为网络的标准框架，它具有七层网络结构。主要是由：``应用层（Application）、表示层（Presentation）、会话层（Session）、传输层（Transport）、网络层（Network）、数据链路层（Data Link）、物理层（Physical）``构成。

### 3.四层网络模型
互联网协议套件（Internet Protocol Suite，IPS）是多个网络传输协议的集合，它为网际网络的基础通信提供架构支撑。由于该协议族中最核心的两个协议分别为 TCP（传输控制协议）和 IP（网际协议），因此它也被称为 TCP/IP 协议族（TCP/IP Protocol Suite 或 TCP/IP Protocols），简称 TCP/IP，它具有四层网络结构 。

### 4.五层网络模型
国际化标准组织制定的 OSI 七层网络模型，本来是最应该在全球范围内推广的网络模型，不过因为 OSI  七层网络模型的设计过于理想不合实际，再加上当时应用 TCP/IP 模型的因特网（Internet）已经覆盖了全球大部分地区。种种原因，导致 OSI 并没有取得市场化的成功，仅仅是获得了理论上的研究成果。而 TCP/IP 模型则被作为了事实上的国际标准。TCP/IP 模型定义了``应用层、传输层、网际层、网络接口层``这四层网络结构，但并没有给出网络接口层的具体内容，因此在学习和开发中，通常将网络接口层替换为 OSI 七层模型中的数据链路层和物理层来进行理解。

### 5.网络分层模型详解
![](/images/dcc0bb77e4e8895ca6149018ea3ecb2b.webp)
通信特点：对等通信，为了使数据分组从源传送到目的地，源端OSI模型的每一层都必须与目的端的对等层进行通信，这种通信方式称为对等层通信。在每一层通信过程中，使用本层自己协议进行通信。
![](/images/3c81a9cd254736f27a32d28113e4c903.webp)
##### (1.) 物理层
物理层的作用就是把电脑连接起来，可用光缆、电缆、双绞线、无线电波等方式连接起来组网。物理层传输比特流0和1，实际最终信号的传输是通过物理层实现的。
通过物理介质传输比特流。规定了电平、速度和电缆针脚。常用设备有（各种物理设备）集线器、中继器、调制解调器、网线、双绞线、同轴电缆。这些都是物理层的传输介质。
##### (2.) 数据链路层
数据链路层规定了0和1的分包形式，确定了网络数据包的形式将比特组合成字节，再将字节组合成帧，使用链路层地址 (以太网使用MAC地址)来访问介质，并进行差错检测。数据实际会以电信号的形式在物理介质中传输，
不过单纯的0和1数字显然是没有价值的，需要为电信号进行分组和排序，以特有的组织方式来赋予其特定的含义。
##### (3.) 网络层
从理论来讲，使用 MAC 地址就可以实现定位到这里世界上任意一台计算机，前提是广播的作用域也是全球范围的，但这并不现实。MAC 地址的定位方式存在本地子网的局限性。
网络层层通过IP寻址来建立两个节点之间的连接，为源端的运输层送来的分组，选择合适的路由和交换节点，正确无误地按照地址传送给目的端的运输层。就是通常说的IP层。这一层就是我们经常说的IP协议层。
IP协议是Internet的基础。网络层规定了数据包的传输路线，而传输层则规定了数据包的传输方式。
##### (4.) 传输层
传输层建立了主机端到端的链接，传输层的作用是为上层协议提供端到端的可靠和透明的数据传输服务，包括处理差错控制和流量控制等问题。该层向高层屏蔽了下层数据通信的细节，
使高层用户看到的只是在两个传输实体间的一条主机到主机的、可由用户控制和设定的、可靠的数据通路。我们通常说的，TCP UDP就是在这一层。端口号既是这里的“端”。每一个应用程序都会在网卡注册一个端口号，该层就是端口与端口的通信！常用的（TCP／IP）协议；
##### (5.) 会话层
会话层就是负责建立、管理和终止表示层实体之间的通信会话。该层的通信由不同设备中的应用程序之间的服务请求和响应组成。
##### (6.) 表示层
表示层提供各种用于应用层数据的编码和转换功能，确保一个系统的应用层发送的数据能被另一个系统的应用层识别。如果必要，该层可提供一种标准表示形式，用于将计算机内部的多种数据格式转换成通信中采用的标准表示形式。数据压缩和加密也是表示层可提供的转换功能之一。
例如，IBM主机使用EBCDIC编码，而大部分PC机使用的是ASCII码。在这种情况下，便需要表示层来完成这种转换。
##### (7.) 应用层
应用层是直接面向用户的，所以相对于数据传输的细节，应用层更加关注数据的表示形式，其主要工作是定义数据格式并按照相应的格式要求进行数据解读。因此，应用层定义了各种各样的协议来规范数据格式，常见的有 HTTP(万维网)， FTP(文件传输)， SMTP(邮件) 等等。
应用层也是OSI参考模型中最靠近用户的一层，是为计算机用户提供应用接口，也为用户直接提供各种网络服务。我们常见应用层的网络服务协议有：HTTP，HTTPS，FTP，POP3、SMTP等。

### 6.网络数据传输流程
![](/images/53d12bb5b7b925431d84bb3f5b3ad8d3.webp)

# 二.网络处理流程
### 1.数据封装过程（快件打包）
（1）应用层传输
这里可以理解为翻译的过程，当然这是属于计算机的翻译过程，应用层便是将数据进行二进制编码。
（2）传输层传输（数据段）
传输层将上层数据分割成诸多数据段（方便解决传输出错问题），并且为每个分段后的数据
封装—— TCP报文头部。其中TCP报文头部有一个关键的字段信息——端口号（保证上层应用数据通信）。
（3）网络层传输 （数据包）
网络层将上层数据再度添加封装——IP头部，其头部包含一个关键的字段信息——IP地址，用于标识网络
的逻辑地址。
（4）数据链路层传输（数据帧）
数据链路层将上层数据再次添加封装——MAC头部，其包含一个关键的字段信息——MAC地址， 可以理解
为固化在硬件中的物理地址，和我们的个人银行卡号一样具有唯一性。 该封装过程中的尾部封装暂不讨论。
（5）物理层传输（比特流）
物理层将上层二进制数据转成电信号在网络中传输。

### 2.Ip协议
每一台电脑都有自己的ip地址，每台电脑上的网络应用程序都有自己的通信端口，张三的电脑（ip：192.168.1.110）上有一个网络应用程序A（通信端口5000），李四的电脑（ip：192.168.1.220）上有一个网络应用程序B（通信端口8000），
张三给李四发消息，首先要知道李四的ip地址，向指定的ip（李四ip：192.168.1.220）发信息，信息就发到了李四的电脑。 再指定一下发送的端口号（通信端口8000），信息就发到了李四电脑的网络应用程序B上。

# 三.传输层协议(TCP协议和UDP协议)
### 1.TCP协议
TCP--一种网络通信方式而已。分为服务器（网络应用程序）和客户端（网络应用程序），TCP通信过程，首先打开服务器，监听自己的网络通信端口（假设为9000），打开客户端，
设置好要连接的ip地址和服务器的网络通信端口（9000），这样服务器一旦监听到网络通信端口有连接，二者就建立了连接。
#### (1.)定义
TCP（Transmission Control Protocol 传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议，由IETF的RFC 793定义。
#### (2.)特征
提供的是面向连接、可靠的字节流服务。当客户和服务器彼此交换数据前，必须先在双方之间建立一个TCP连接，之后才能传输数据。TCP提供超时重发，丢弃重复数据，检验数据，流量控制等功能，保证数据能从一端传到另一端。
#### (3.)优缺点
优点：安全、传输数据无大小限制、准确可靠，先发先至
缺点：效率低，不能做离线任务、连接有耗时
#### (4.)三次握手
第一次握手：客户端尝试连接服务器，向服务器发送syn包（同步序列编号Synchronize Sequence Numbers）， syn=j，客户端进入SYN_SEND状态等待服务器确认
第二次握手：服务器接收客户端syn包并确认（ack=j+1），同时向客户端发送一个SYN包（syn=k），即SYN+ACK包， 此时服务器进入SYN_RECV状态
第三次握手：第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1），此包发送完毕， 客户端和服务器进入ESTABLISHED状态，完成三次握手
#### (5.)四次挥手
第一次挥手：Client发送一个FIN，用来关闭Client到Server的数据传送，Client进入FIN_WAIT_1状态。
第二次挥手：Server收到FIN后，发送一个ACK给Client，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），Server进入CLOSE_WAIT状态。
第三次挥手：Server发送一个FIN，用来关闭Server到Client的数据传送，Server进入LAST_ACK状态。
第四次挥手：Client收到FIN后，Client进入TIME_WAIT状态，接着发送一个ACK给Server，确认序号为收到序号+1， Server进入CLOSED状态，完成四次挥手。

### 2.TCP粘包拆包问题
##### (1.)什么是粘包、拆包？
TCP 协议对于应用层来说，没有“包”的概念只有“流”的概念。TCP 相当于一个自来水管，水不停的流出来，应用层可以用矿泉水瓶去分割，
也可以用水桶去分割（提前指定数据长度或分隔符），或者约定自来水来源地控制水流停止时机（短连接），这是应用层必须解决的问题。
流，最大的问题是没有边界，没有边界就会造成数据粘在一起，这种粘在一起就叫做粘包。就像是人类的沟通无一例外是通过“说话的停顿”和“对于语言内容的理解”来进行断句的，
如果不按照一定得规则进行断句那么就无法识别想要表达得意思.

假设客户端向服务端连续发送了两个数据包，用packet1和packet2来表示，那么服务端收到的数据可以分为三种，现列举如下：
**第一种情况** 接收端正常收到两个数据包，即没有发生拆包和粘包的现象，此种情况不在本文的讨论范围内。
![image_8.png](/images/8d7d662f3e40de4328d4633573b5dc2c.webp)
**第二种情况**接收端只收到一个数据包，由于TCP是不会出现丢包的，所以这一个数据包中包含了发送端发送的两个数据包的信息，这种现象即为粘包。这种情况由于接收端不知道这两个数据包的界限，所以对于接收端来说很难处理。
![image_9.png](/images/beaeb421805ff3a0430f0aa91ea20d51.webp)
**第三种情况**这种情况有两种表现形式，如下图。接收端收到了两个数据包，但是这两个数据包要么是不完整的，要么就是多出来一块，这种情况即发生了拆包和粘包。这两种情况如果不加特殊处理，对于接收端同样是不好处理的。
![image_10.png](/images/5ce41ed75659ad9baf63b97181401810.webp)
![image_11.png](/images/0d2f5c5985a68ec3e57d860eb8a47408.webp)


##### (2.)为什么会发生TCP粘包？
TCP 是一个面向字节流的协议，它是性质是流式的，所以它并没有分段。就像水流一样，你没法知道什么时候开始，什么时候结束。所以他只会根据当前的套接字缓冲区的情况进行拆包或是粘包。
发送端的字节流都会先传入缓冲区，再通过网络传入到接收端的缓冲区中，最终由接收端获取。当我们发送两个完整包到接收端的时候：正常情况会接收到两个完整的报文。但也有以下的情况：
接收到的是一个报文，它是由发送的两个报文组成的，这样对于应用程序来说就很难处理了（这样称为粘包）。
发生TCP粘包、拆包主要是由于下面一些原因：
- 应用程序写入的数据大于套接字缓冲区大小，这将会发生拆包。
- 应用程序写入数据小于套接字缓冲区大小，网卡将应用多次写入的数据发送到网络上，这将会发生粘包。
- 进行MSS（最大报文长度）大小的TCP分段，当TCP报文长度-TCP头部长度>MSS的时候将发生拆包。
- 接收方法不及时读取套接字缓冲区数据，这将发生粘包。

##### (3.)粘包解决办法
TCP本身是面向流的，作为网络服务器，如何从这源源不断涌来的数据流中拆分出或者合并出有意义的信息呢？通常会有以下一些常用的方法：
1. 发送端给每个数据包添加包首部，首部中应该至少包含数据包的长度，这样接收端在接收到数据后，通过读取包首部的长度字段，便知道每一个数据包的实际长度了。
2. 发送端将每个数据包封装为固定长度（不够的可以通过补0填充），这样接收端每次从接收缓冲区中读取固定长度的数据就自然而然的把每个数据包拆分开来。
3. 可以在数据包之间设置边界，如添加特殊符号，这样，接收端通过这个边界就可以将不同的数据包拆分开。


### 3.UDP协议
#### (1.)UDP定义
UDP 是User Datagram Protocol的简称， 是OSI（Open System Interconnection，开放式系统互联）参考模型中一种无连接的传输层协议，UDP在IP报文的协议号是17。
UDP 为应用程序提供了一种无需建立连接就可以发送封装的 IP 数据包的方法。从应用程序传递过来的数据，会附加上多路复用/多路分解的源和目的端口号字段，以及其他字段，然后将形成的报文传递给网络层，网络层将运输层报文段封装到 IP 数据报中，然后尽力而为的交付给目标主机。最关键的一点就是，使用 UDP 协议在将数据报传递给目标主机时，
发送方和接收方的运输层实体间是没有握手的。正因为如此，UDP 被称为是无连接的协议。
#### (2.)UDP特征
1. UDP是一个无连接协议，传输数据之前源端和终端不建立连接，当它想传送时就简单地去抓取来自应用程序的数据，并尽可能快地把它扔到网络上。在发送端，UDP传送数据的速度仅仅是受应用程序生成数据的速度、计算机的能力和传输带宽的限制；在接收端，UDP把每个消息段放在队列中，应用程序每次从队列中读一个消息段。
2. 由于传输数据不建立连接，因此也就不需要维护连接状态，包括收发状态等，因此一台服务机可同时向多个客户机传输相同的消息。
3. 不可靠传输协议。
4. 吞吐量不受拥挤控制算法的调节，只受应用软件生成数据的速率、传输带宽、源端和终端主机性能的限制。
5. UDP使用尽最大努力交付，即不保证可靠交付，因此主机不需要维持复杂的链接状态表（这里面有许多参数）。
6. UDP是面向报文的。发送方的UDP对应用程序交下来的报文，在添加首部后就向下交付给IP层。既不拆分，也不合并，而是保留这些报文的边界，因此，应用程序需要选择合适的报文大小。
#### (3.)UDP优缺点
优点：可以传输大文件，速度快，效率高
缺点：不安全，容易丢包（数据）、先发未必先至
#### (4.)UDP适合场景
当一个消息丢失后，不久就会有一个新消息替代他的场景。
#### (5.)UDP单播，组播和广播实现
- 单播是：有具体目标地址的帧从源到达目标地址的过程。
- 多播（组播）：就是帧送往定义在一组内的地址。
- 广播：就是把帧发往所有能到达的地址。

# 四.应用层协议
应用层是网络协议栈中最上的一层，也是网络通信的第一层，它提供了让两个终端设备进行信息交换的服务。它``定义了信息交换的格式，然后把定义好的信息交给它下面一层的传输层去传输``。
### 1.HTTP协议
HTTP协议（Hyper Text Transfer Protocol，超文本传输协议）是一种最基本的客户机/服务器的访问协议。浏览器向服务器发送请求，而服务器回应相应的网页，用于从万维网（WWW:World Wide Web ）服务器传输超文本到本地浏览器的传送协议。
传统Web应用中浏览器与服务器进行数据交互通常需要经过以下几个步骤：
1. DNS查询
2. TCP三次握手
3. 传送HTTP请求头
4. 传送HTTP请求体(如果有)
5. 服务器处理后传送响应头
6. 服务器传送响应体
7. TCP四次挥手，断开TCP连接

>HTTP是基于TCP的应用层协议，虽然TCP是支持长连接的，但是HTTP并不强制要求长连接，大部分情况下，一次HTTP请求的完成经过了建立TCP链接->客户端发送报文->服务端返回报文->服务端或客户端关闭此连接这个过程，由于每次都要建立连接，并在完成一次请求响应后关闭连接，所以大家称为“短连接”。HTTP的所谓Keep-Alive，实际上是一种不可控的行为，是为了在一定程度上改善HTTP性能的，即服务端和客户端希望不立刻断开连接，这样下次发送数据时就不需要建立TCP连接了，但是服务端和客户端的任何一方都可以随时断开。

### 2.FTP协议（File Transfer Protocol，文件传输协议）
基于客户服务器模式，FTP协议包括两个组成部分，其一为FTP服务器，其二为FTP客户端，提供交互式的访问 面向连接 ，使用TCP/IP可靠的运输服务，主要功能:减少/消除不同操作系统下文件的不兼容性。

### 3.JDBC协议
应用层的协议，和FTP，HTTP同一个级别。DBC（Java DataBase Connectivity，java数据库连接）是一种用于执行SQL语句的Java API，可以为多种关系数据库提供统一访问，它由一组用Java语言编写的类和接口组成。

### 4.WebSocket协议
同HTTP一样也是应用层的协议，但是它是一种双向通信协议，是建立在TCP之上的，WebSocket 看成是 HTTP 协议为了支持长连接所打的一个大补丁，它和 HTTP 有一些共性，它解决了服务器与客户端全双工通信的问题，
包含两部分:一部分是“握手”，一部分是“数据传输”。握手成功后，数据就直接从 TCP 通道传输，与 HTTP 无关了。
在WebSocket中进行交互通常为以下几个步骤：
1. DNS查询
2. TCP三次握手
3. WebSocket握手
4. 浏览器发送请求
5. 服务器发送响应
6. 断开TCP连接

WebSocket协议
基于Http协议的扩展，支持长连接，用于建立客户端和服务器的双向通道。

而传统的轮询方式（即采用http协议不断发送请求）的缺点：浪费流量（http请求头比较大）、浪费资源（没有更新也要请求）、消耗服务器

CPU占用（没有信息也要接收请求）。

WebSocket是保证只要在服务端和客户端建立连接后任何一端发起消息，相互推送消息，效率也是极大的提高了，并且服务端和客户端之间的标头信息很小，可以降低服务端的资源浪费。

WebSocket、HTTP与TCP
Http、WebSocket等协议属于应用层协议，IP协议工作在网络层，TCP协议工作在传输层。HTTP、WebSocket等应用层协议，都是基于TCP协议来传输数据的。

对于WebSocket来说，它必须依赖Http协议进行一次握手，握手成功后，数据就直接从TCP通道传输，与Http无关了

# 五.传输层协议和应用层协议区别
传输层协议关注的是怎么传，应用协议关注的是传什么，http规定传输超文本，而且他不关心传输层使用什么协议来传递或承载它，TCP和UDP是传输层协议，http是应用层协议，它是基于传输层的tcp。 传输层传输的都是二进制字节。应用层传输的是具体的应用数据。比如你写一个tcp应用，你就需要写编码、解码器，来传输应用数据。
通俗地说，应用层协议其实就是在传输层协议上标识了端口号。
例如：
- HTTP协议默认使用了TCP协议的80端口。
- FTP协议默认使用了TCP协议的21端口。
- DNS协议默认使用了UDP协议的53端口。
- DHCP协议默认使用了UDP协议的67端口。

# 六.DNS协议概述
Domain Name System 域名系统。也叫做域名解析协议。在浏览器访问网页的时候，通常是用一连串有意义的英文字符标识，比如www.baidu.com、www.sohu.com等。
但计算机并不是通过这些字符串去找到对应的计算机，而是通过32位的二进制，也就是我们的IP地址来找。所以就有了DNS协议，它的作用就是将域名解析成对应的IP地址。
因为让我们人去记那些IP地址，很难记得住，所以就想办法让IP地址转变为了现在的域名，在进行访问的时候，只需要将域名解析为对应的IP地址就行了。
1. 通过域名访问网页
2. 计算机会先将域名发送到一个解析域名的服务器上
3. 在其服务器上有很多服务器，能解析各种各样的域名，比如有专门解析.org的，解析.com的，解析.net的。等等，最主要的有一个根域名服务器
   - 域名解析(在服务器上查找IP地址)的过程有两种算法，迭代查询，递归查询。一般是两种查询的结合。
   - 本机计算机找到其中一台解析域名的服务器(可能是.com)，如果没有找到对应的IP地址，那么就会去找根域名服务器，根域名服务器知道所有的子服务器，所以他肯定知道该域名所对应的IP地址在那个子服务器中，所以告诉第一次查询的服务器要他去另一台服务器上找，找到了，就将其返回给计算机， 以后在有另一台计算机也通过这个域名访问，那么第一台服务器会有原来的域名IP地址的缓存，就不用去找根服务器了。
4. 找到了相应域名对应的ip地址，就能访问对应的服务器了。

>全球共有13台根域名服务器。

# 七.Socket编程
### 1.什么是Socket?
socket翻译为套接字，socket是在应用层和传输层之间的一个抽象层，它把TCP/IP层复杂的操作过程，抽象为几个简单的接口(API)供应用层调用，从而实现进程在网络中的通信。
程序员做网络通讯开发时，通过调用Socket API就可以实现基于TCP、UDP等应用的网络通信功能. 也就是说Socket是为了方便开发者直接使用更底层协议（一般是TCP或UDP）而存在的一个抽象层。
Socket实际上是对TCP/IP协议的抽象，本身并不是协议，而它只是操作系统提供给应用程序进行网络通信的抽象API。 Socket的出现只是使得程序员更方便地使用TCP/IP协议栈而已，
Socket包含最基本的函数接口(API)，比如create、listen、connect、accept、send、read和write。
例如:
主机A的应用程序要能和主机B的应用程序通信，必须通过Socket建立连接，而建立Socket连接必须需要底层TCP/IP协议来建立TCP连接。建立TCP连接需要底层IP协议来寻找网络中的主机。
我们知道网络层使用IP协议可以帮助我们根据IP地址来找到目标主机，但是一台主机上可能运行着多个应用程序，如何才能与指定的应用程序通信就要通过TCP或UDP的地址也就是端口号来指定。
这样就可以通过一个Socket实例唯一代表一个主机上的一个应用程序的通信链路了。

![](/images/3f1993cb804713f7648603dfa550487f.webp)

>socket像是一个管道，管理里面流的形式可以是基于tcp，也可以是udp， tcp，和udp都是一种网络传输协议。

### 2.Socket通信的基本流程
Socket本身有“插座”的意思，不是Java中特有的概念，而是一个语言无关的标准，任何可以实现网络编程的编程语言都有Socket。可以这么理解：Socket就是网络上的两个应用程序通过一个双向通信连接实现数据交换的编程接口API。
如果一个程序创建了一个socket，并让其监听80端口，其实是向TCP/IP协议栈声明了其对80端口的占有。 此后，所有目标是80端口的TCP数据包都会转发给该程序 （这里的程序，因为使用的是Socket编程接口，所以首先由Socket层来处理） 。所谓accept函数，其实抽象的是TCP的连接建立过程。
accept函数返回的新socket其实指代的是本次创建的连接，而一个连接是包括两部分信息的，一个是源IP和源端口，另一个是宿IP和宿端口。 所以，accept可以产生多个不同的socket，而这些socket里包含的宿IP和宿端口是不变的，变化的只是源IP和源端口。
这样的话，这些socket宿端口就可以都是80，而Socket层还是能根据源/宿对来准确地分辨出IP包和socket的归属关系，从而完成对TCP/IP协议的操作封装！
Socket通信的基本流程具体步骤如下所示:
1. 服务端通过Listen开启监听，等待客户端接入。
2. 客户端的套接字通过Connect连接服务器端的套接字，服务端通过Accept接收客户端连接。在connect-accept过程中，操作系统将会进行三次握手。
3. 客户端和服务端通过write和read发送和接收数据，操作系统将会完成TCP数据的确认、重发等步骤。
4. 通过close关闭连接，操作系统会进行四次挥手。
5. 针对Java编程语言，java.net包是网络编程的基础类库。其中ServerSocket和Socket是网络编程的基础类型。

>SeverSocket是服务端应用类型。Socket是建立连接的类型。当连接建立成功后，服务器和客户端都会有一个Socket对象示例，可以通过这个Socket对象示例，完成会话的所有操作。对于一个完整的网络连接来说，Socket是平等的，没有服务器客户端分级情况。

### 3.socket在Android中的应用
1.在一般的android开发中，调用的各种实现所谓的http连接的api(包括java自带的httpurlconnection)其底层基本上都是调用的jdk的socket接口。
2.socket是基于tcp/ip协议封装的一套实现tcp连接的接口，或者说是工具。
4.http只是一种协议，什么请求头，请求题，响应头都是根据固定的格式制定的报文，然后最终(因为可能不直接调用socket的api接口而是用的其他第三方工具，比如volley，okhttp等间接调用Socket)都会通过socket接口将这些报文发给服务器或者客户端。

### 4.socket和tcp、http的关系
##### (1.)IP/TCP/UDP
TCP/IP代表传输控制协议/网际协议，指的是一系列协议。
TCP和UDP使用IP协议从一个网络传送数据包到另一个网络。把IP想像成一种高速公路，它允许其它协议在上面行驶并找到到其它电脑的出口。TCP和UDP是高速公路上的“卡车”，它们携带的货物就是像HTTP，文件传输协议FTP这样的协议等。
TCP和UDP是FTP，HTTP和SMTP之类使用的传输层协议。虽然TCP和UDP都是用来传输其他协议的，它们却有一个显著的不同：TCP提供有保证的数据传输，而UDP不提供。这意味着TCP有一个特殊的机制来确保数据安全的不出错的从一个端点传到另一个端点，而UDP不提供任何这样的保证。

##### (2.)HTTP
HTTP(超文本传输协议)是利用TCP在两台电脑(通常是Web服务器和客户端)之间传输信息的协议。客户端使用Web浏览器发起HTTP请求给Web服务器，Web服务器发送被请求的信息给客户端。
需要IP协议来连接网络;TCP是一种允许我们安全传输数据的机制，，使用TCP协议来传输数据的HTTP是Web服务器和客户端使用的特殊协议。
Socket 接口是TCP/IP网络的API，Socket接口定义了许多函数或例程，用以开发TCP/IP网络上的应用程序。

##### (3.)socket
Socket 其实是对 TCP/IP 进行了高度封装，屏蔽了很多网络细节。这样可以使开发者更好地进行网络编程。其实就是我们写个高度封装内部细节的函数，通过传参来完成指定的行为。
可以这么说，所有的 TCP/UDP 等编程，基本都是按照 Socket 协议标准来进行编程的，换句话说，Socket 是一套标准，就好比 DOM ，所有语言都可以按照 DOM 的接口标准来实现自己的逻辑。
Socket 有自己的原语，开发者可以按照 Socket 的原语在不同语言下的实现方式来进行网络编程。

##### (4.)总结
IP 地址 + 端口 + 协议 组成一个唯一标识，用来标识一个通信链路。
http协议：处于互联网协议的应用层，角色是规定数据传输的格式。
socket: socket称之为套接字，这里的socket指的是http socket， 由主机+端口组成，是一个通信链的句柄，可以用来实现不同虚拟机或不同计算机之间的通信，也可以实现相同主机内的不同进程之间的通讯。
主机：对应了网络层，涉及ip协议，通过ip确定主机所在位置，主机到主机
端口：涉及互联网协议的传输层，涉及TCP（带有确认机制的UDP协议）/UDP协议，通过端口确认对应的进程，端口其实就是进程使用网卡的编号，端口到端口
整个互联网协议从应用层到实体层，从上到下，越上越接近用户，越下越接近硬件；http是建立在socket之上的

### 5.Socket和WebSocket的关系
首先需要指出这个 WebSocket 本身就是 TCP 长连接应用的一种，你应该想要问的是 WebSocket 和普通的 Socket 优势区别在哪。最大的却别就是普通的 Socket 就是基础的 Socket，没有规定传输协议，
只是提供了最基本的数据传输功能，而 WebSocket 既是一种技术，更是一个 Socket 的应用层协议，它规定了两端之间数据传输的编码和解码方案，有了这个现有的方案，开发者只需要根据其设计出对应的实现，
而不再需要自己去搞一套另外的协议。至于浏览器那个 WebSocket 对象，就是一个 WebSocket 协议的实现，使用者只需要调用它的 API 就可以使用 WebSocket 协议进行通讯。
WebSocket 不止可以在浏览器上使用，在服务器或者其他类型的客户端也同样可以使用，只要有实现的软件包即可。

- WebSocket 是应用层协议，tcp 是传输层协议。
- websocket 本身是基于 tcp 实现的。
- tcp 本身无所谓长短连接，理想状态下只要不 close，tcp 连接就一直存在（注意是理想）。
- 所谓的长连接本身是一条虚拟链路。

1. 应用程序写入数据的字节大小大于套接字发送缓冲区的大小
3. 以太网的payload大于MTU进行IP分片。MTU指：一种通信协议的某一层上面所能通过的最大数据包大小。如果IP层有一个数据包要传，而且数据的长度比链路层的MTU大，那么IP层就会进行分片，把数据包分成若干片，让每一片都不超过MTU。注意，IP分片可以发生在原始发送端主机上，也可以发生在中间路由器上。

>普通的 Socket 就是基础的 Socket，没有规定传输协议，只是提供了最基本的数据传输功能，而 WebSocket 既是一种技术，更是一个 Socket 的应用层协议 ，它规定了两端之间数据传输的编码和解码方案，有了这个现有的方案，开发者只需要根据其设计出对应的实现，而不再需要自己去搞一套另外的协议。

# 八.序列化协议(数据传输格式)
### 1.XML
##### (1.)定义
XML（Extensible Markup Language）是一种常用的序列化和反序列化协议， 它历史悠久，从1998年的1.0版本被广泛使用至今。

##### (2.)优点
- 人机可读性好。
- 可指定元素或特性的名称。

##### (3.)缺点
- 序列化数据只包含数据本身以及类的结构，不包括类型标识和程序集信息。
- 类必须有一个将由 XmlSerializer 序列化的默认构造函数。
- 只能序列化公共属性和字段。
- 不能序列化方法。
- 文件庞大，文件格式复杂，传输占带宽。

##### (4.)使用场景
- 当做配置文件存储数据。
- 实时数据转换。

### 2.JSON
##### (1.)定义
JSON(JavaScript Object Notation， JS 对象标记) 是一种轻量级的数据交换格式。它基于 ECMAScript (w3c制定的js规范)的一个子集， JSON采用与编程语言无关的文本格式，
但是也使用了类C语言（包括C， C++， C#， Java， JavaScript， Perl， Python等）的习惯，简洁和清晰的层次结构使得 JSON 成为理想的数据交换语言。
##### (2.)优点
- 前后兼容性高
- 数据格式比较简单，易于读写
- 序列化后数据较小，可扩展性好，兼容性好
- 与XML相比，其协议比较简单，解析速度比较快
##### (3.)缺点
- 数据的描述性比XML差
- 不适合性能要求为ms级别的情况
- 额外空间开销比较大
##### (4.)适用场景（可替代ＸＭＬ）
- 跨防火墙访问
- 可调式性要求高的情况
- 基于Web browser的Ajax请求
>传输数据量相对小，实时性要求相对低（例如秒级别）的服务

### 3.PROTOBUF
##### (1.)定义
protocol buffers 由谷歌开源而来，在谷歌内部久经考验。它将数据结构以.proto文件进行描述，通过代码生成工具可以生成对应数据结构的POJO对象和Protobuf相关的方法和属性。

##### (2.)优点
- 序列化后码流小，性能高
- 结构化数据存储格式（XML JSON等）
- 通过标识字段的顺序，可以实现协议的前向兼容
- 结构化的文档更容易管理和维护

##### (3.)缺点
- 需要依赖于工具生成代码
- 支持的语言相对较少，官方只支持Java 、C++ 、Python

##### (4.)适用场景
- 对性能要求高的RPC调用
- 具有良好的跨防火墙的访问属性
- 适合应用层对象的持久化

### 4.XMPP
XMPP是一种基于标准通用标记语言的子集XML的协议，它继承了在XML环境中灵活的发展性。因此，基于XMPP的应用具有超强的可扩展性。
经过扩展以后的XMPP可以通过发送扩展的信息来处理用户的需求，以及在XMPP的顶端建立如内容发布系统和基于地址的服务等应用程 序。
而且，XMPP包含了针对服务器端的软件协议，使之能与另一个进行通话，这使得开发者更容易建立客户应用程序或给一个配好系统添加功能。

# 九.网络编程总结
如果只是满足你的这个要求：传输简单文本，tcp/udp socket足够了。 但是互联网应用何其之多，当然这些应用都可以基于tcp/udp去传输。不过这么多应用，也并不是毫无规律可循。 我们完全可以根据特定场景，总结出一些规律，提炼出一些相同的东西，这个东西就是一个基于传输层的上层协议，也就是应用层协议。
有了应用层协议，我们传输特定应用的数据，直接采用与之对应的应用层协议即可，没必要再把应用层协议实现一遍，交给传输层传输。
而是把数据给到应用层协议，应用层自己会调用传输层完成数据的传输。对于我们设计的应用程序而言，只要产生数据，然后交给应用层协议去传输，然后从应用层协议接收对端发来的数据，直接处理就好。拿你熟悉的HTTP协议举例，假设让你用TCP/UDP Socket实现浏览器和Web服务器之间的数据传输。你除了传输真正的数据外，是否有一些其他的必要的问题需要考虑，比如：
数据的类型，你客户端发送了一个JSON文本，服务器怎么知道是JSON，而不是其他类型数据？
数据的长度，假设你数据量很大，一次性根本传输不完，什么时候能传输完成呢？客户端自己肯定知道，因为是它要传输数据，但是服务器呢？它只知道每隔一次发来一份数据，什么时候能完呢？
数据的压缩方式，同样地假设你数据量很大，是不是要考虑压缩，这时候一个新的问题来了，服务器怎么知道客户端的数据是压缩的，并且压缩算法是啥？以上仅仅说了三点，但远远不止这三点。像这种问题，是不是每次传输数据都需要考虑？既然如此，何不把这些通用性的问题，提取出来，重新在TCP/UDP基础上，再设计一个新的协议呢？
像上面的三点，HTTP给出了自己的解决办法
数据的类型，HTTP Header： Content-Type
数据的长度，HTTP Header： Content-Length
数据的压缩方式，HTTP Header： Accept-Encoding当然针对浏览器和Web服务器这种特定场景，还有一些通用问题要考虑，比如
浏览器是IE、Chrome、Firefox哪一个？版本是多少？
服务器是Apache、Nginx、IIS哪一个？版本多少？
数据收发时的时间是多少？上面的情形，一般是Web数据传输时需要考虑的，对于其他场景要考虑的通用性问题，又不一样，因此才有了那么多的应用层协议。正如360行，每行都有每行的术语一样。

>一个形象的比喻：TCP/IP是由SOCKET修建公路，HTTP是公路上跑的车，XML或JSON是车装载的货物。
如果TCP是高速公路，那么UDP可以是水路。其中，HTTP可以是小轿车；FTP可以是大货车；Telnet可以是皮卡；SMTP可以是SUV……这些都各自平稳可靠地跑在TCP这条高速公路上。
同时，NTP可以是小汽艇；SNMP可以是普通轮船；TFTP可以是大邮轮；这些都在UDP这条水路上跑，只是路线和到达时间可能要任性一些。当然也有DNS这种水陆两栖车，在哪都能跑。
你可能会有一些个性化的需求，那么你还可以自己去制造一辆房车，只要设计可靠，审核通过了就可以上高速了。 不过你需要遵循同样的一套高速公路行车章程，还有你的这辆车分类（端口号）可能不像那些经典的车型那样大众和著名。






参考资料:
[太厉害了，终于有人能把TCP/IP 协议讲的明明白白了](https://zhuanlan.zhihu.com/p/147370653)

[Http、Socket、WebSocket之间联系与区别](https://www.cnblogs.com/aspirant/p/11334957.html)

[TCP粘包拆包及解决方法](https://juejin.cn/post/6844904083430572046)

[关于iOS socket都在这里了](http://www.cocoachina.com/articles/16572)

[一图说明http和socket关系](https://blog.csdn.net/honghailiang888/article/details/51121257)

[实现即时通讯的几种方式之 socket.io 方式详解](https://blog.csdn.net/Charissa2017/article/details/105191235)

[Android使用protobuf与服务器进行一次数据交互](https://blog.csdn.net/u013762572/article/details/89208570)

[怎么解决TCP网络传输「粘包」问题？](https://www.zhihu.com/question/20210025)

[UDP 和 TCP 的 socket 分别一般用在什么地方？](https://www.zhihu.com/question/20060141)

[xml、json、protobuf序列化协议](https://zhuanlan.zhihu.com/p/91313277)

[如何选择即时通讯应用的数据传输格式](https://zhuanlan.zhihu.com/p/21868901)

[Android Socket使用详解](https://juejin.cn/post/6844903567799631879#heading-9)

[TCP粘包，难道说这是一个伪命题？？](https://mp.weixin.qq.com/s?__biz=MzI4MDYzNDc1Mg==&mid=2247484019&idx=1&sn=c8e0b7c7c5095c52481a6474d326172d&source=41#wechat_redirect)

[序列化和反序列化](https://tech.meituan.com/2015/02/26/serialization-vs-deserialization.html)

[几种流行的序列化协议比较](https://blog.csdn.net/weixin_37830196/article/details/83552450)

[在建立TCP/IP连接之后，可以发送json的数据吗？](https://www.zhihu.com/question/332072139)
