<!DOCTYPE html><html lang="zh-CN" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Web前端后端渲染 | 鹏哥的Blog</title><meta name="author" content="peng"><meta name="copyright" content="peng"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#0d0d0d"><meta name="description" content="渲染以Jade,YAML为代表的模板渲染引擎一般作用于服务器作为后端的视图部分。互联网早期，用户使用浏览器浏览的都是一些没有复杂逻辑的、简单的页面，这些页面都是在后端将html拼接好的然后将之返回给前端完整的html文件，浏览器拿到这个html文件之后就可以直接解析展示了，而这也就是所谓的服务器端渲染了。因为后端拼接完了html，浏览器只需要直接渲染出来。 1、为什么会有服务端渲染和客户端渲染？">
<meta property="og:type" content="article">
<meta property="og:title" content="Web前端后端渲染">
<meta property="og:url" content="https://lxlfpeng.github.io/2021/08/20/Web%E5%89%8D%E7%AB%AF%E5%90%8E%E7%AB%AF%E6%B8%B2%E6%9F%93/index.html">
<meta property="og:site_name" content="鹏哥的Blog">
<meta property="og:description" content="渲染以Jade,YAML为代表的模板渲染引擎一般作用于服务器作为后端的视图部分。互联网早期，用户使用浏览器浏览的都是一些没有复杂逻辑的、简单的页面，这些页面都是在后端将html拼接好的然后将之返回给前端完整的html文件，浏览器拿到这个html文件之后就可以直接解析展示了，而这也就是所谓的服务器端渲染了。因为后端拼接完了html，浏览器只需要直接渲染出来。 1、为什么会有服务端渲染和客户端渲染？">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://lxlfpeng.github.io/images/about_avatar.webp">
<meta property="article:published_time" content="2021-08-19T16:00:00.000Z">
<meta property="article:modified_time" content="2025-04-12T15:02:01.855Z">
<meta property="article:author" content="peng">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://lxlfpeng.github.io/images/about_avatar.webp"><link rel="shortcut icon" href="/images/favicon.webp"><link rel="canonical" href="https://lxlfpeng.github.io/2021/08/20/Web%E5%89%8D%E7%AB%AF%E5%90%8E%E7%AB%AF%E6%B8%B2%E6%9F%93/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Web前端后端渲染',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  isShuoshuo: false
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/images/about_avatar.webp" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">127</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">59</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">24</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/categories"><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background: linear-gradient(20deg, #0062be, #925696, #cc426e, #fb0347);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src="/images/nav_logo.webp" alt="Logo"><span class="site-name">鹏哥的Blog</span></a><a class="nav-page-title" href="/"><span class="site-name">Web前端后端渲染</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/categories"><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Web前端后端渲染</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2021-08-19T16:00:00.000Z" title="发表于 2021-08-20 00:00:00">2021-08-20</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Web%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/">Web前端开发</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">10.6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>31分钟</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="渲染"><a href="#渲染" class="headerlink" title="渲染"></a>渲染</h1><p>以Jade,YAML为代表的模板渲染引擎一般作用于服务器作为后端的视图部分。互联网早期，用户使用浏览器浏览的都是一些没有复杂逻辑的、简单的页面，<br>这些页面都是在后端将html拼接好的然后将之返回给前端完整的html文件，浏览器拿到这个html文件之后就可以直接解析展示了，而这也就是所谓的服务器端渲染了。因为后端拼接完了html，浏览器只需要直接渲染出来。</p>
<p>1、为什么会有服务端渲染和客户端渲染？</p>
<p>越来越复杂的 UI 意味着越来越多的渲染工作。目前，通常有两种选择：服务端渲染和客户端渲染。</p>
<p>以 Jade 和 YAML 为代表的模板渲染引擎一般作为后端视图部分作用于服务器。</p>
<p>使用直接处理HTML DOM 作用于前端，本质是客户端进行渲染。</p>
<p>最终用户看到的效果在两者之间是相同的。</p>
<p>最后，Web App 必须在 HTML 和 CSS 中实现，然后才能反映在用户界面中。</p>
<p>后端渲染归根结底就是将一些模板规范语言翻译成以上三种语言，传回给前端；而前端渲染则是将生成的整个逻辑代码传回前端，再由客户端生成用户界面。</p>
<p>一开始，Web App直接由几个HTML、CSS、JS组成，每个页面都需要特殊的逻辑，所以随着App规模的扩大，后端网站目录下的代码文件越来越多。没有同步，例如，您更改站点的布局样式。那么您可能需要修改数百个 HTML 文件。这谁能受得了？</p>
<p>聪明的工程师想，既然这么多的HTML都有一定的逻辑联系，为什么不用代码来生成代码呢？于是后端模板语言诞生了，这是前端狗的一大痛点，于是人们开始广泛使用模板语言，而不是手写的HTML。我认为模板语言的成功源于它成功地减少了前端工程师的工作量。</p>
<p>后端模板渲染的想法应该来源于“如何管理后端存储的数千个一致版本的前端页面？”的问题。通过代码生成代码本质上是一种编译。他们在HTML等基础语言的基础上做了更高层次的抽象包装，增强了易用性。各种模板语言大同小异，但大多都具备模板中模板的属性，完成继承等面向对象的特性。</p>
<p>大概，工程师当时没有考虑前端渲染的原因之一，就是他们认为的前端技术还没有兴起。现在CSS3和JS越来越流行，大大提高了前端的可操作性，尤其是Node.js出现之后，大大降低了JS工程师维护后端的成本。</p>
<p>从一些用户的角度来看，JS生成前端无非就是这个</p>
<p>var e &#x3D; document.createElement(&#39;div&#39;);$(&#39;#container&#39;).append(e);<br>您需要先生成 DOM，然后再将其插入到其他 DOM 中。纯JS处理DOM确实比较麻烦，这可能也是客户端渲染没有发展起来的原因之一。</p>
<p>想想为什么后端模板语言方便简洁？因为它使用类似于 HTML 的语法。在 PHP 和 JSP 页面中，可以使用大量的 HTML 语法，并且只使用少量的变量注入和迭代注入。</p>
<p>使用 HTML 进行设计显然比纯 JS 更方便和直观。</p>
<p>那么我们可以借鉴一下，解决客户端渲染问题的最后一个技巧就是引入一个模板，这里我们称之为组件()。</p>
<p>Vue 对模板、新模板，甚至它们在 Web App 中的定位都有不同的看法。具体情况可以自行了解，这不是本文的重点。</p>
<p>由于前端也支持模板语言，也解决了之前的代码管理问题，而且之前的后端渲染引擎大部分也有基于JS的前端版本。</p>
<p>前端和后端真正解耦了。前端会专注于UI，后端会专注于数据处理，两端通过设计好的API进行交互。这将是一个趋势。</p>
<p>2、浏览器渲染和服务端渲染路由</p>
<p>在互联网的早期，用户使用浏览器浏览没有复杂逻辑的简单页面。这些页面都在后端与html拼接，然后在前端返回完整的html文件。浏览器得到了这个 html。之后就可以直接解析并显示文件了，这就是所谓的服务端渲染。随着前端页面复杂度的增加，前端不仅仅是一个普通的页面展示，还可能增加更多的功能组件，更加复杂。另外，当时ajax的兴起让业界开始佩服前后端开发模式分离，即后端不提供完整的html页面，而是提供了一些API，使得前端可以获取json数据，</p>
<p>客户端渲染和服务端渲染最重要的区别是谁来完成html文件的完整拼接。如果是在服务端做，然后返回给客户端，就是服务端渲染，如果是前端做的，还要多做一些工作来完成html的拼接，这就是客户端渲染。</p>
<p>客户端渲染路径：</p>
<ol>
<li>请求一个html -&gt; 2. 服务器返回一个html -&gt; 3. 浏览器下载html中的js&#x2F;css文件-&gt; 4. 等待js文件待下载-&gt; 5. 等待js加载完成初始化-&gt; 6. js代码终于可以运行了，js代码向后端请求数据（ajax&#x2F;）-&gt; 7. 等待后端数据返回-&gt; 8. 客户端将数据渲染为响应页面从无到有</li>
</ol>
<p>服务端渲染路线：</p>
<ol>
<li>请求一个html -&gt; 2. 服务器请求数据（快速内网请求） -&gt; 3. 服务器初始渲染（服务器性能好，速度更快） -&gt; 4. 服务器返回内容正确的页面-&gt; 5. 客户端请求js&#x2F;css文件-&gt; 6.等待js文件下载-&gt; 7.等待js加载和初始化完成-&gt; 8. 客户端完成剩余部分的渲染（小内容，快速渲染）</li>
</ol>
<p>3、从后端渲染到前端渲染有什么变化？</p>
<p>将原本由服务端执行的渲染任务转移到客户端，大大减轻了大量用户访问时后端的压力。让后端专注于后端应该做什么，性能会大大提升，因为服务器确实减少了东西，现在随着客户端软硬件的发展，它可以处理大部分的渲染工作.</p>
<p>整个UI逻辑交给客户端后，一些有经验、有能力的用户可能会劫持UI，让他们看到一些不该看到的界面。这似乎违反了安全原则。但是“前端讲安全都是流氓”，后端不能信任前端传来的所有数据，记得做好过滤和验证。只要使用SSL，屏蔽XSS，后端没有发现漏洞，伪造身份劫持App还是比较困难的。</p>
<p>4、服务端渲染的优缺点是什么？</p>
<p>前端耗时较少。因为后端是拼接html的，浏览器直接渲染就可以了。</p>
<p>有利于SEO（搜索引擎优化）。因为后台有完整的html页面，更容易让爬虫爬取获取信息，更有利于seo。</p>
<p>无需占用客户资源。也就是说解析模板的工作完全交给了后端，客户端只需要解析标准的html页面，这样对客户端尤其是移动端占用的资源更少，也可以节省更多的时间。</p>
<p>后端生成静态文件。即产生缓存碎片，可以减少数据库查询浪费的时间，对于数据变化不大的页面非常高效。</p>
<p>不利于前后端分离，开发效率低。如果使用服务端渲染，无法进行分工协作，对于前端复杂度高的项目，不利于项目的高效开发。另外，如果是服务端渲染，一般是前端写一个静态的html文件，然后后端修改成模板，效率很低，经常需要前后端共同完成修改；或者前端直接完成html模板，然后交给后端。另外，如果后端改变了模板，前端也需要根据改变的模板调整css，增加了前后端联调的时间。</p>
<p>占用服务器端资源。即服务端完成对html模板的解析。如果请求很多，就会对服务器造成一定的访问压力。如果使用前端渲染，这些解析的压力就分散到了前端，这里确实是完全交给了一个服务器。</p>
<p>5、客户端渲染的优缺点是什么？</p>
<p>前端和后端是分开的。前端专注于前端UI，后端专注于api开发，前端有更多选择，无需遵循后端特定模板。</p>
<p>体验更好。比如我们把网站做成一个单页的Web应用程序（page web，SPA，它是一个加载单个HTML页面并在用户与应用程序交互时动态更新页面的Web应用程序）或部分内容转化为一个SPA，所以，尤其是移动端可以让体验更接近原生app。</p>
<p>前端响应慢。如果是客户端渲染，前端还需要进行字符串拼接的过程，这需要额外的时间，并且没有服务端渲染那么快。</p>
<p>不利于SEO。目前百度和谷歌的爬虫不识别SPA，只记录一个页面，所以SEO很差。因为服务端可能不会保存完整的html，但是前端使用js拼接dom，那么爬虫就爬不出来信息了。除非搜索引擎的SEO能增加爬虫能力，这样才能保证SEO。</p>
<p>5、使用服务端渲染还是客户端渲染？</p>
<p>不管业务场景如何，盲目选择使用哪种渲染方式都是流氓。比如一个企业级网站，主要功能是展示，不需要复杂的交互，需要很好的SEO，那么就需要使用服务端渲染；和后端管理页面类似，交互性比较强，不需要SEO考虑，那么就可以使用客户端渲染了。</p>
<p>另外，具体使用的渲染方式也不是绝对的。比如现在有的网站采用首屏服务端渲染，即对用户第一次打开的页面采用服务端渲染，这样可以保证渲染速度。页面渲染在客户端，完成了前后端分离。</p>
<p>6、对于前后端分离，如何进行SEO优化？</p>
<p>如果前后端分离，那么前端就是通过js修改dom，让html拼接完成，然后展示，或者用SPA，这样就几乎没有SEO了。那么这种情况下如何做SEO优化呢？</p>
<p>我们可以自己提交，让蜘蛛主动抓取，但是遇到中间的url，如果到达指定页面后只有meta js怎么办？这里我们可以用进行简单的优化，比如打印出当前页面信息的一些关键信息点，但是普通用户不需要这些，会造成额外的负担，前端可以判断是否支持，但后半部分不能。我们不得不借助百度的UA（用户代理）判断、使用或代理，对访问过的页面进行特殊处理，以达到被收录的效果。但是这个效果还是不好。. .</p>
<p>目前Vue和Vue都提供了SSR，即服务端渲染，是针对seo不好的解决方案。</p>
<p>7、前后端分离怎么理解？</p>
<p>其实在今天，前后端分离一定是必然或趋势，因为web1.0时代的早期网页都是简单的网页，但现在网页越来越向app移动，而前后端分离是实现app的必然结果。所以，我们可以把html、css、app组合起来，然后浏览器充当虚拟机来运行这些程序，即浏览器成为了app和客户端的运行环境。总的来说，目前的前端在增加。越往桌面应用或者手机端应用发展，比如电脑端的QQ可以在服务器端渲染吗？当然不是！因此，前后端分离成为必然。</p>
<h3 id="如何判断网页是不是服务端渲染"><a href="#如何判断网页是不是服务端渲染" class="headerlink" title="如何判断网页是不是服务端渲染"></a>如何判断网页是不是服务端渲染</h3><p>看网页刷新后第一个请求（type为document），如果返回内容是包含有真实数据的html格式文本，就是服务端渲染，否则是客户端渲染<br>大厂的网站基本都是两者结合，如b站首页，搜索页面采用服务端渲染提升SEO，个人空间这种不需要的就直接客户端渲染</p>
<p>二、客户端渲染与服务端渲染本质的区别：</p>
<p>2.1、传输数据不同  （Chrome &gt; 控制台 &gt; Network &gt; Preview &gt; 查看传输内容）</p>
<p>客户端渲染：传递JSON对象、由浏览器渲染视图；</p>
<p>服务端渲染：传递完整HTML返回给浏览器渲染；</p>
<p>2.2、SEO优化问题（Chrome &gt; 右击  &gt; 检查网页源代码）</p>
<p>单页面应用：客户端渲染、源代码中无法获取到动态渲染的数据、不利于SEO爬虫</p>
<p>服务端渲染：首次渲染的html中携带所有服务器端返回的数据，原代码中包含所有数据，利于SEO优化；</p>
<p>如何在页面中快速的判断出来？<br>1、鼠标右键查看源代码，在页面中看到的内容在源代码中也可以查看到，则是服务端渲染得到的</p>
<p>2、鼠标右键查看源代码，页面中看到的内容在源代码中不可以查看到，则是客户端渲染得到的</p>
<p>方法一<br>若页面做整体的刷新，即网址发生改变，就是服务器渲染<br>若页面做了局部刷新，即网址没发生改变，就是客户端渲染</p>
<h2 id="前端渲染和后端渲染的区别"><a href="#前端渲染和后端渲染的区别" class="headerlink" title="前端渲染和后端渲染的区别"></a>前端渲染和后端渲染的区别</h2><p>服务端渲染是通过后端模板引擎编译成html,css,js,然后回传给前端来进行显示；而前端渲染则是将整个生成逻辑代码全部回传前端，再由客户端生成用户界面。<br>客户端渲染和服务器端渲染的最重要的区别就是究竟是谁来完成html文件的完整拼接，如果是在服务器端完成的，然后返回给客户端，就是服务器端渲染，而如果是前端做了更多的工作完成了html的拼接，则就是客户端渲染。</p>
<h3 id="快速判断是前端渲染还是后端渲染"><a href="#快速判断是前端渲染还是后端渲染" class="headerlink" title="快速判断是前端渲染还是后端渲染"></a>快速判断是前端渲染还是后端渲染</h3><ol>
<li>鼠标右键查看源代码，在页面中看到的内容在源代码中也<code>可以</code>查看到，则是<code>服务端渲染</code>得到的<br> 这说明页面中的内容是通过服务器渲染返回得到的，这样做的目的有利于seo</li>
<li>鼠标右键查看源代码，页面中看到的内容在源代码中<code>不可以</code>查看到，则是<code>客户端渲染</code>得到的<br> 说明页面中的内容是通过客户端发送请求得到的，即这种情况就是通过客户端渲染的</li>
</ol>
<h3 id="前端渲染-客户端渲染"><a href="#前端渲染-客户端渲染" class="headerlink" title="前端渲染 客户端渲染"></a>前端渲染 客户端渲染</h3><ul>
<li><p>ajax请求到的数据再渲染到页面上</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">查看原网页 ctrl+f找不到的都是前端渲染</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<ul>
<li>好处：html写的页面一般都是前端渲染</li>
<li>缺点：不利于seo优化，不利于搜索引擎爬虫到当前项目</li>
</ul>
</li>
</ul>
<h3 id="后端渲染-服务器端渲染"><a href="#后端渲染-服务器端渲染" class="headerlink" title="后端渲染 服务器端渲染"></a>后端渲染 服务器端渲染</h3><ul>
<li>后端数据和模板相结合后发送到前端<ul>
<li>缺点： 耗费服务器性能</li>
<li>好处：利于seo优化 利于搜索引擎爬虫到当前项目</li>
</ul>
</li>
</ul>
<h3 id="前后端渲染对比"><a href="#前后端渲染对比" class="headerlink" title="前后端渲染对比"></a>前后端渲染对比</h3><table>
<thead>
<tr>
<th>~</th>
<th>后端渲染</th>
<th>前端渲染</th>
</tr>
</thead>
<tbody><tr>
<td>页面呈现速度</td>
<td>快，受限于用户的带宽</td>
<td>主要受限于带宽和客户端机器的好坏，优化的好，可以逐步动态展开内容，感觉上会更快一点。</td>
</tr>
<tr>
<td>流量消耗：</td>
<td>少一点点（可以省去前端框架部分的代码）</td>
<td>多一点点（一个前端框架大概50KB）当然，有的用后端渲染的项目前端部分也有在用框架。</td>
</tr>
<tr>
<td>可维护性：</td>
<td>差（前后端东西放一起，掐架多年，早就在闹分手啦）</td>
<td>好，前后端分离，各施其职，代码一目明了。</td>
</tr>
<tr>
<td>seo友好度：</td>
<td>好</td>
<td>差，大量使用ajax，多数浏览器不能抓取ajax数据。</td>
</tr>
<tr>
<td>编码效率</td>
<td>低（这个跟不同的团队不同，可能不对）</td>
<td>高，前后端各自只做自己擅长的东西，后端最后只输出接口，不用管页面呈现，只要前后端人员能力不错，效率不会低。</td>
</tr>
</tbody></table>
<p>早期，页面都是直接由html，css，js实现的，每一个页面彼此之间相当于是独立的，当网站应用足够大的时候，需要修改网站的内容时，我们需要更改很多的代码，非常麻烦，不变维护。</p>
<p>后来，程序员使用代码生成代码，就是后端的<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E&spm=1001.2101.3001.7020">模板引擎</a>，人们开始广泛使用模板代替手写html，大大减少的前端的工作量。通过代码生成代码，其实就是编译，基于html等基础语言，做出了更高层次的抽象封装，增加了易用性。</p>
<p>再后来h5,c3崛起，再加上客户端硬件性能的提升，我们开始通过前端模板引擎，来在客户端渲染页面。</p>
<p>对待模板，angular，vue，react的态度都不一样。</p>
<p><strong>前后端真正解耦，前端专注于UI视图,后台专注于数据处理，通过设计好的api交互，这是未来的趋势。</strong></p>
<h1 id="同构渲染"><a href="#同构渲染" class="headerlink" title="同构渲染"></a>同构渲染</h1><p>及解决什么问题？</p>
<ol>
<li>要解决的问题：</li>
</ol>
<p>首屏渲染慢、不利于seo问题，当搜索引擎爬取html的时候是没内容的，因为要客户端js解析完生成html<br>为了解决以上问题，则提出了同构渲染，借鉴了传统的服务端渲染，称之为现代化的服务端渲染或同构渲染。</p>
<ol start="2">
<li>同构渲染：</li>
<li>基于React、Vue等框架，客户端渲染和服务器端渲染的结合</li>
<li>在服务器端执行一次，用于实现服务器端渲染（首屏直出）</li>
<li>在客户端再执行一次，用于接管页面交互</li>
<li>核心解决SEO和首屏渲染慢的问题</li>
<li>拥有传统服务端渲染的优点，也有客户端渲染的优点</li>
</ol>
<p>最后，提供给大家一个很好辨认页面中哪些是客户端渲染， 哪些是服务端渲染的方法： 打开页面的网络源代码， 能够搜到的就是服务端渲染，搜不到的就是客户端渲染。</p>
<h3 id="客户端渲染"><a href="#客户端渲染" class="headerlink" title="客户端渲染"></a>客户端渲染</h3><p>当此渲染为客户端渲染时，在客户端所进行的操作步骤如下所示：</p>
<ol>
<li>收到服务端响应的字符串。</li>
<li>从上到下依次进行相关的解析，在解析的过程中，如果发现ajax请求，则再次发起新的请求。</li>
<li>拿到ajax响应的结果。</li>
<li>使用模板引擎进行渲染。</li>
</ol>
<p>在客户端渲染中，其至少会发起两次请求。</p>
<ul>
<li>第一次请求拿到相关的页面。</li>
<li>第二次请求拿到相关的动态数据。</li>
</ul>
<p>优点：<br>页面显示速度比较快。</p>
<p>缺点：<br>内容的显示速度偏慢。</p>
<h3 id="服务端渲染"><a href="#服务端渲染" class="headerlink" title="服务端渲染"></a>服务端渲染</h3><p>在服务端读取相关所需渲染的页面文件，然后使用<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E&spm=1001.2101.3001.7020">模板引擎</a>渲染，在发送给客户端之前，服务端就已经将相关的页面进行了渲染处理了。</p>
<p>对于服务端渲染来说，只请求了一次。</p>
<p>缺点：<br>服务端压力变大，待需解析的内容越多，所进行解析的速度越慢。</p>
<h3 id="客户端渲染和服务端渲染的区别"><a href="#客户端渲染和服务端渲染的区别" class="headerlink" title="客户端渲染和服务端渲染的区别"></a>客户端渲染和服务端渲染的区别</h3><ol>
<li>服务端渲染比客户端渲染更快。</li>
<li>客户端渲染与服务端渲染相比，客户端渲染能够更快的看到相关的页面，但是会有一个等待过程；而服务端渲染所进行渲染的就是直接的结果，客户端不需要再做任何处理。</li>
<li>客户端异步渲染是很难被爬虫抓取到的，爬虫爬不到相关的数据信息，不利于SEO搜索引擎优化。</li>
<li>服务端渲染可以被爬虫抓取到，即服务端渲染利于SEO搜索引擎优化。</li>
</ol>
<h3 id="客户端渲染和服务端渲染的判别方法"><a href="#客户端渲染和服务端渲染的判别方法" class="headerlink" title="客户端渲染和服务端渲染的判别方法"></a>客户端渲染和服务端渲染的判别方法</h3><ol>
<li>查看相关的网页源代码，如果在源代码中能够看到相关的数据，则表明其为服务端渲染。</li>
<li>查看相关的网页源代码，如果在源代码中不能够看到相关的数据，则表明其为客户端渲染，即其是随后在客户端动态追加的。</li>
<li>当请求新的数据信息时，页面没有进行刷新，则表明其是客户端渲染。</li>
<li>当请求新的数据信息时，页面进行了刷新，则表明其是服务端渲染。</li>
<li>若相关的数据请求是异步的，则表明其为客户端渲染。</li>
</ol>
<h3 id="客户端渲染和服务端渲染使用场景"><a href="#客户端渲染和服务端渲染使用场景" class="headerlink" title="客户端渲染和服务端渲染使用场景"></a>客户端渲染和服务端渲染使用场景</h3><ul>
<li>需要考虑SEO搜索引擎优化，则使用服务端渲染。例如相关的商品希望被用户所搜索到。</li>
<li>不需要考虑到SEO搜索引擎优化，则使用客户端渲染。例如相关的评论为了用户体验，且不需要SEO优化。</li>
</ul>
<p>前端领域中，随着Vue，React，Angular等框架的流行，前端工程化、模块化成为了当下主流技术方案。这类框架构建的SPA单页应用具有用户体验好、渲染性能好、可维护性高等有点，但是也存在以下两个方面的问题：</p>
<ol>
<li>首屏加载时间长</li>
</ol>
<p>SPA应用采用客户端渲染，用户需要等待客户端js解析完成之后才能看到页面，这样会导致首屏加载时间变长，用户体验差。</p>
<ol>
<li>不利于SEO</li>
</ol>
<p>由于SPA应用采用客户端渲染，在js未完成解析之前，网站HTML是没有内容的，这样导致搜索引擎爬取站点HTML时获取不到内容。</p>
<p>为了解决这两个问题，业界提出了一种新的解决方案，如下图：<br><img src="/images/293cebdc2a1dfb59606031f96c85377f.webp" alt="image.png"></p>
<p>利用服务端渲染解决首屏加载慢和不利于SEO的缺陷，首屏渲染完成之后，客户端渲染接管页面重新成为单页应用以保证良好的用户体验。这种方式称为现代化服务端渲染方式或者同构渲染。</p>
<h2 id="与传统服务端渲染区别"><a href="#与传统服务端渲染区别" class="headerlink" title="与传统服务端渲染区别"></a>与传统服务端渲染区别</h2><p>传统服务端渲染，如JSP可以总结为以下几步：</p>
<ol>
<li>客户端发送请求</li>
<li>服务端根据请求查找模板并获取数据。</li>
<li>执行渲染</li>
<li>生成html返回客户端展示</li>
</ol>
<p>这种传统服务端渲染方式，会存在以下缺点：</p>
<ol>
<li>前后端完全耦合，不利于开发维护。</li>
<li>前端发挥空间小。</li>
<li>服务端压力大。</li>
<li>用户体验一般。</li>
</ol>
<p>而同构渲染只是在首屏渲染的时候和传统服务端类似，都是返回渲染好的html页面，但是，同构渲染中，当客户端展示渲染好的html页面后，客户端渲染会接管页面的控制权，也就是后续的渲染都是由客户端进行的，这样可以保证良好的用户体验。</p>
<h2 id="同构渲染缺点"><a href="#同构渲染缺点" class="headerlink" title="同构渲染缺点"></a>同构渲染缺点</h2><p>与单页应用相比，由于首屏渲染采用的是服务端渲染，所以存在以下缺点：</p>
<ol>
<li>开发条件有限，开发有限制（服务端只能使用nodejs，而且并不是所有的工具包都能在服务端渲染中使用）。</li>
<li>涉及构建和部署的要求高（需要部署客户端和服务端，不能再和单页应用一样，部署静态站点即可）。</li>
<li>更多的服务端负载。</li>
</ol>
<h2 id="一-什么是渲染"><a href="#一-什么是渲染" class="headerlink" title="一. 什么是渲染"></a>一. 什么是渲染</h2><p>这里所说的渲染指的是<strong>把(数据</strong> <strong>+</strong> <strong>模板)拼接到一起</strong>的这个事儿。</p>
<p>例如对于我们<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91&spm=1001.2101.3001.7020">前端开发</a>者来说最常见的一种场景就是:请求后端接口数据，然后将数据通过模板绑定语法绑定到页面中，最终呈现给用户。这个过程就是我们这里所指的渲染。</p>
<p>渲染本质其实就是<code>字符串的解析替换</code>，实现方式有很多种;但是我们这里要关注的并不是如何渲染，而是在哪里渲染的问题</p>
<h2 id="二-客户端渲染"><a href="#二-客户端渲染" class="headerlink" title="二. 客户端渲染"></a>二. 客户端渲染</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>随着前端<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E6%8A%80%E6%9C%AF%E6%A0%88&spm=1001.2101.3001.7020">技术栈</a>和工具链的迭代成熟，前端工程化、模块化也已成为了当下的主流技术方案，在这波前端技术浪潮中，涌现了诸如 React、Vue、Angular 等基于客户端渲染的前端框架，这类框架所构建的项目就是<code>单页应用(SPA)</code>，他们属于客户端渲染。</p>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p><code>用户体验好</code>、<code>渲染性能好</code>、<code>可维护性高</code>等。</p>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ol>
<li><code>首屏加载时间过长</code><br>与传统服务端渲染直接获取服务端渲染好的 HTML 不同，单页应用使用 JavaScript 在客户端生成 HTML 来呈现内容， <strong>用户需要等待客户端JS 解析执行完成才能看到页面</strong> ，这就使得首屏加载时间变长，从而影响用户体验。</li>
<li><code>不利于 SEO</code><br>当搜索引擎爬取网站 HTML 文件时， <strong>单页应用只有一些基本的html骨架和资源路径，它的 <code>HTML 没有内容</code>，因为他它需要通过客户端 JavaScript解析执行才能生成网页内容</strong> ，而目前的主流的搜索引擎对于这一部分内容的抓取还不是很好。</li>
</ol>
<h2 id="三-服务端渲染"><a href="#三-服务端渲染" class="headerlink" title="三. 服务端渲染"></a>三. 服务端渲染</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>最早期， <strong>Web 页面渲染都是在服务端完成的，即服务端运行过程中将所需的数据结合页面模板渲染为 HTML，响应给客户端浏览器</strong> 。 <strong>所以浏览器呈现出来的是直接包含内容的页面</strong> 。这种方式的代表性技术有:<code>ASP、PHP、JSP</code>，再到后来的一些相对高级一点的服务端框架配合一些模板 引擎。</p>
<h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h3><p><code>首屏加载时间短</code>、<code>利于 SEO</code>。</p>
<h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><ol>
<li>应用的<code>前后端</code>部分完全<code>耦合在一起</code>，在前后端协同开发方面会有非常大的阻力;</li>
<li><code>前端没有足够的发挥空间</code>，无法充分利用现在前端生态下的一些更优秀的方案;</li>
<li>由于内容都是在服务端动态生成的，所以<code>服务端的压力较大</code>;</li>
<li>相比目前流行的 SPA 应用来说，<code>用户体验一般</code>;</li>
</ol>
<p>但是不得不说，在网页应用并不复杂的情况下，这种方式也是可取的。</p>
<h2 id="四-同构渲染-现代化的服务端渲染"><a href="#四-同构渲染-现代化的服务端渲染" class="headerlink" title="四. 同构渲染(现代化的服务端渲染)"></a>四. 同构渲染(现代化的服务端渲染)</h2><h3 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h3><p><code>同构渲染 =【服务端渲染】 + 【客户端渲染】</code>。isomorphic web apps(<code>同构应用</code>):isomorphic&#x2F;universal，基于 <code>react、vue 框架，客户端渲染和服务器端渲染的结合，在服务器端执行一次，用于实现服务器端渲染(首屏直出)，在客户端再执行一 次，用于接管页面交互，核心解决 SEO 和首屏渲染慢的问题</code>。</p>
<h3 id="相关技术"><a href="#相关技术" class="headerlink" title="相关技术"></a>相关技术</h3><ol>
<li>React 生态中的 <code>Next.js</code></li>
<li>Vue 生态中的 <code>Nuxt.js</code></li>
<li>Angular 生态中的 <code>Angular Universal</code></li>
</ol>
<h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><ol>
<li>客户端发起请求</li>
<li>服务端渲染首屏内容 + 生成客户端 SPA 相关资源</li>
<li>服务端将生成的首屏资源发送给客户端</li>
<li>客户端直接展示服务端渲染好的首屏内容</li>
<li>首屏中的 SPA 相关资源执行之后会激活客户端 Vue</li>
<li>之后客户端所有的交互都由客户端 SPA 处理</li>
</ol>
<h3 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h3><p>首屏渲染速度快、有利于 SEO</p>
<h3 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h3><ol>
<li><code>开发成本高</code>。</li>
<li>涉及构建设置和部署的更多要求。与可以部署在任何静态文件服务器上的完全静态单页面应 用程序 (SPA) 不同，服务器渲染应用程序，<code>需要处于 Node.js server 运行环境</code>。</li>
<li><code>更多的服务器端负载</code>。在 Node.js 中渲染完整的应用程序，显然会比仅仅提供静态文件的 server 更加大量占用 CPU 资源 (CPU-intensive - CPU 密集)，因此如果你预料在高流量环境 (high traffic) 下使用，请准备相应的服务器负载，并明智地采用缓存策略</li>
</ol>
<h2 id="五-总结"><a href="#五-总结" class="headerlink" title="五. 总结"></a>五. 总结</h2><p>在对你的应用程序使用服务器端渲染 (SSR) 之前，你应该问的第一个问题是，是否真的需要它。这主要 取决于内容到达时间 (time-to-content) 对应用程序的重要程度。例如，如果你正在构建一个内部系统，初始加载时的额外几百毫秒并不重要，这种情况下去使用服务器端渲染 (SSR) 将是一个小题大作之 举。然而，内容到达时间 (time-to-content) 要求是绝对关键的指标，在这种情况下，服务器端渲染 (SSR) 可以帮助你实现最佳的初始加载性能。</p>
<p>事实上，很多网站是出于效益的考虑才启用服务端渲染，性能倒是在其次。 假设 A 网站页面中有一个 关键字叫“前端性能优化”，这个关键字是 JS 代码跑过一遍后添加到 HTML 页面中的。那么客户端渲染模 式下，我们在搜索引擎搜索这个关键字，是找不到 A 网站的——搜索引擎只会查找现成的内容，不会帮 你跑 JS 代码。A 网站的运营方见此情形，感到很头大:搜索引擎搜不出来，用户找不到我们，谁还会用我的网站呢?为了把“现成的内容”拿给搜索引擎看，A 网站不得不启用服务端渲染。 但性能在其次，不代表性能不重要。</p>
<h1 id="服务器端渲染和客户端渲染的区别？"><a href="#服务器端渲染和客户端渲染的区别？" class="headerlink" title="服务器端渲染和客户端渲染的区别？"></a>服务器端渲染和客户端渲染的区别？</h1><h4 id="什么是服务器端渲染和客户端渲染？"><a href="#什么是服务器端渲染和客户端渲染？" class="headerlink" title="什么是服务器端渲染和客户端渲染？"></a><strong>什么是服务器端渲染和客户端渲染？</strong></h4><p>互联网早期，用户使用浏览器浏览的都是一些没有复杂逻辑的、简单的页面，这些页面都是在后端将html拼接好的然后将之返回给前端完整的html文件，浏览器拿到这个html文件之后就可以直接解析展示了，而这也就是所谓的<strong>服务器端渲染</strong>了。而随着前端页面的复杂性提高，前端就不仅仅是普通的页面展示了，而可能添加了更多功能性的组件，复杂性更大，另外，彼时 <strong>ajax的兴起</strong> ，使得业界就开始推崇<strong>前后端分离</strong>的开发模式，即后端不提供完整的html页面，而是提供一些api使得前端可以获取到json数据，然后前端拿到json数据之后再在前端进行html页面的拼接，然后展示在浏览器上，这就是所谓的<strong>客户端渲染</strong>了，这样前端就可以专注UI的开发，后端专注于逻辑的开发。</p>
<h3 id="两者本质的区别是什么？"><a href="#两者本质的区别是什么？" class="headerlink" title="两者本质的区别是什么？"></a>两者本质的区别是什么？</h3><p>客户端渲染和服务器端渲染的最重要的区别就是<strong>究竟是谁来完成html文件的完整拼接，</strong> 如果是在服务器端完成的，然后返回给客户端，就是服务器端渲染，而如果是前端做了更多的工作完成了html的拼接，则就是客户端渲染。</p>
<h3 id="服务器端渲染的优缺点是怎样的？"><a href="#服务器端渲染的优缺点是怎样的？" class="headerlink" title="服务器端渲染的优缺点是怎样的？"></a>服务器端渲染的优缺点是怎样的？</h3><h4 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h4><ol>
<li><strong>前端耗时少。</strong> 因为后端拼接完了html，浏览器只需要直接渲染出来 <strong>。</strong></li>
<li><strong>有利于SEO。</strong> 因为在后端有完整的html页面，所以爬虫更容易爬取获得信息，更有利于seo。</li>
<li><strong>无需占用客户端资源</strong> 。即解析模板的工作完全交由后端来做，客户端只要解析标准的html页面即可，这样对于客户端的资源占用更少，尤其是移动端，也可以更省电。</li>
<li><strong>后端生成静态化文件</strong> 。即生成缓存片段，这样就可以减少数据库查询浪费的时间了，且对于数据变化不大的页面非常高效 。</li>
</ol>
<p><strong>缺点：</strong></p>
<ol>
<li><strong>不利于前后端分离，开发效率低。</strong> 使用服务器端渲染，则无法进行分工合作，则对于前端复杂度高的项目，不利于项目高效开发。另外，如果是服务器端渲染，则 <strong>前端一般就是写一个静态html文件</strong> ，然后 <strong>后端再修改为模板</strong> ，这样是非常低效的，并且还常常需要前后端共同完成修改的动作；  <strong>或者是前端直接完成html模板，然后交由后端</strong> 。另外，如果后端改了模板，前端还需要根据改动的模板再调节css，这样使得前后端联调的时间增加。</li>
<li><strong>占用服务器端资源</strong> 。即服务器端完成html模板的解析，如果请求较多，会对服务器造成一定的访问压力。而如果使用前端渲染，就是把这些解析的压力分摊了前端，而这里确实完全交给了一个服务器。</li>
</ol>
<h3 id="客户端渲染的优缺点是怎样的？"><a href="#客户端渲染的优缺点是怎样的？" class="headerlink" title="客户端渲染的优缺点是怎样的？"></a>客户端渲染的优缺点是怎样的？</h3><h4 id="优点：-1"><a href="#优点：-1" class="headerlink" title="优点："></a>优点：</h4><ol>
<li><strong>前后端分离</strong> 。前端专注于前端UI，后端专注于api开发，且前端有更多的选择性，而不需要遵循后端特定的模板。</li>
<li><strong>体验更好</strong> 。比如，我们将网站做成SPA或者部分内容做成SPA，这样，尤其是移动端，可以使体验更接近于原生app。</li>
</ol>
<h4 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h4><ol>
<li><strong>前端响应较慢</strong> 。如果是客户端渲染，前端还要进行拼接字符串的过程，需要耗费额外的时间，不如服务器端渲染速度快。</li>
<li><strong>不利于SEO</strong> 。目前比如百度、谷歌的爬虫对于SPA都是不认的，只是记录了一个页面，所以SEO很差。因为服务器端可能没有保存完整的html，而是前端通过js进行dom的拼接，那么爬虫无法爬取信息。 除非搜索引擎的seo可以增加对于JavaScript的爬取能力，这才能保证seo。</li>
</ol>
<h3 id="使用服务器端渲染还是客户端渲染？"><a href="#使用服务器端渲染还是客户端渲染？" class="headerlink" title="使用服务器端渲染还是客户端渲染？"></a>使用服务器端渲染还是客户端渲染？</h3><p><strong>不谈业务场景而盲目选择使用何种渲染方式都是耍流氓。</strong> 比如企业级网站，主要功能是<strong>展示</strong>而 <strong>没有复杂的交互</strong> ，并且需要 <strong>良好的SEO</strong> ，则这时我们就需要使用服务器端渲染；而类似后台管理页面，交互性比较强，不需要seo的考虑，那么就可以使用客户端渲染。</p>
<p>另外，具体使用何种渲染方法并不是绝对的，比如现在一些网站采用了 <strong>首屏服务器端渲染</strong> ，即对于用户最开始打开的那个页面采用的是服务器端渲染，这样就保证了渲染速度，而其他的页面采用客户端渲染，这样就完成了前后端分离。</p>
<h3 id="对于前后端分离，如果进行seo优化？"><a href="#对于前后端分离，如果进行seo优化？" class="headerlink" title="对于前后端分离，如果进行seo优化？"></a>对于前后端分离，如果进行seo优化？</h3><p>如果进行了前后端分离，那么前端就是通过js来修改dom使得html拼接完全，然后再显示，或者是使用SPA，这样，seo几乎没有。那么这种情况下如何做seo优化呢？</p>
<p>我们可以自行提交 <strong>sitemap</strong> ， <strong>让蜘蛛主动去爬取</strong> ，但是遇到了sitemap中的url，达到指定页面之后只有元js怎么办呢？这是我们可以使用标签来进行简单的优化，比如打印出当前页面信息的一些关键的信息点，但是正常用户并不需要这些，会造成额外的负担，且前端可以判断是否支持JavaScript，而后段不行，只好根据百度的spider做UA判断，使用phantomjs或者nginx代理，来对spider访问的页面进行特殊的处理，达到被收录的效果。但这种效果还是不好。。。</p>
<p>而目前的react和vue都提供了SSR，即服务器端渲染，这也就是提供seo不好的解决方式了。</p>
<h3 id="究竟如何理解前后端分离？"><a href="#究竟如何理解前后端分离？" class="headerlink" title="究竟如何理解前后端分离？"></a>究竟如何理解前后端分离？</h3><p>实际上，时至今日，前后端分离一定是必然或者趋势，因为早期在web1.0时代的网页就是简单的网页，而如今的网页越来越朝向app前进，而前后端分离就是实现app的必然的结果。所以，我们可以认为html、css、JavaScript组成了这个app，然后浏览器作为虚拟机来运行这些程序，即浏览器成为了app的运行环境，成了客户端，总的来说就是当前的前端越来越朝向桌面应用或者说是手机上的app发展了，而比如说电脑上的qq可以服务器端渲染吗？肯定不能！所以前后端分离也就成了必然。<strong>而我们目前接触额前端工程化、编译（转译）、各种MVC&#x2F;MVVM框架、依赖工具、npm、bable、webpack等等看似很新鲜、创新的东西实际上都是传动桌面开发所形成的概念，只是近年来前端发展较快而借鉴过来的，本质上就是开源社区东平西凑做出来的一个visual studio。</strong></p>
<h1 id="服务端渲染和客户端渲染的区别"><a href="#服务端渲染和客户端渲染的区别" class="headerlink" title="服务端渲染和客户端渲染的区别"></a>服务端渲染和客户端渲染的区别</h1><h2 id="客户端渲染-1"><a href="#客户端渲染-1" class="headerlink" title="客户端渲染"></a>客户端渲染</h2><p>就是我们的页面开始是没内容的，加载js后，js会生成和操纵dom，最后由浏览器渲染出页面，这一系列的操作都是在浏览器完成的。（前端去后端取数据生成DOM树。）<br><img src="/images/d720549a009f62efa75240905647176e.webp" alt="1.png"></p>
<p>加载出来的是一个空的页面，该页面加载了app.js这个文件，该js文件会产生和操作Dom，最终浏览器渲染和绘制页面。<br><strong>客户端渲染的优点：</strong><br>1、前后端分离，开发效率高。<br>2、用户体验更好，我们将网站做成SPA（单页面应用）或者部分内容做成SPA，当用户点击时，不会形成频繁的跳转。<br><strong>客户端渲染的缺点：</strong><br>1、前端响应速度慢，特别是首屏，这样用户是受不了的。<br>2、不利于SEO优化，因为爬虫不认识SPA，所以它只是记录了一个页面。</p>
<h2 id="Server-Side-Rendering（服务端渲染）"><a href="#Server-Side-Rendering（服务端渲染）" class="headerlink" title="Server Side Rendering（服务端渲染）"></a>Server Side Rendering（服务端渲染）</h2><p>SSR 目的是对搜索引擎更友好，客户端渲染搜索引擎无法抓取页面相关内容，也就是用户搜不到网站的相关信息，排名就会比较靠后。（DOM树在服务端生成，然后返回给前端。）<br><img src="/images/56ef75e01963265d1b13910adc380d31.webp" alt="2.png"></p>
<p>原理：将 html 在服务端渲染，合成完整的 html 文件再输出到浏览器。<br>适用场景：客户端的网络比较慢，客户端运行在老的或者直接没有 JavaScript 引擎上<br><strong>服务端渲染的优点：</strong><br>1、尽量不占用前端的资源，前端这块耗时少，速度快。<br>2、有利于SEO优化，因为在后端有完整的html页面，所以爬虫更容易爬取信息。<br><strong>服务端渲染的缺点：</strong><br>1、不利于前后端分离，开发的效率降低了。<br>2、对html的解析，对前端来说加快了速度，但是加大了服务器的压力。</p>
<p><strong>直观的区分服务端渲染和客户端渲染：</strong><br>源码里如果能找到前端页面中的内容文字，那就是在服务端构建的DOM，就是服务端渲染，反之是客户端渲染。</p>
<h1 id="客户端渲染与服务端渲染"><a href="#客户端渲染与服务端渲染" class="headerlink" title="客户端渲染与服务端渲染"></a>客户端渲染与服务端渲染</h1><h3 id="什么是服务器端渲染和客户端渲染？-1"><a href="#什么是服务器端渲染和客户端渲染？-1" class="headerlink" title="什么是服务器端渲染和客户端渲染？"></a>什么是服务器端渲染和客户端渲染？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">互联网早期，用户使用浏览器浏览的都是一些没有复杂逻辑的、简单的页面，这些页面都是在后端将html拼接好的然后将之返回给前端完整的html文件，浏览器拿到这个html文件之后就可以直接解析展示了，而这也就是所谓的服务器端渲染了。而随着前端页面的复杂性提高，前端就不仅仅是普通的页面展示了，而可能添加了更多功能性的组件，复杂性更大，另外，彼时ajax的兴起，使得业界就开始推崇前后端分离的开发模式，即后端不提供完整的html页面，而是提供一些api使得前端可以获取到json数据，然后前端拿到json数据之后再在前端进行html页面的拼接，然后展示在浏览器上，这就是所谓的客户端渲染了，这样前端就可以专注UI的开发，后端专注于逻辑的开发。</span><br></pre></td></tr></table></figure>

<h3 id="两者本质的区别是什么？-1"><a href="#两者本质的区别是什么？-1" class="headerlink" title="两者本质的区别是什么？"></a>两者本质的区别是什么？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">客户端渲染和服务器端渲染的最重要的区别就是究竟是谁来完成html文件的完整拼接，如果是在服务器端完成的，然后返回给客户端，就是服务器端渲染，而如果是前端做了更多的工作完成了html的拼接，则就是客户端渲染。</span><br></pre></td></tr></table></figure>

<h3 id="如何在页面中快速的判断出来？"><a href="#如何在页面中快速的判断出来？" class="headerlink" title="如何在页面中快速的判断出来？"></a>如何在页面中快速的判断出来？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1、鼠标右键查看源代码，在页面中看到的内容在源代码中也可以查看到，则是服务端渲染得到的</span><br><span class="line"></span><br><span class="line">2、鼠标右键查看源代码，页面中看到的内容在源代码中不可以查看到，则是客户端渲染得到的</span><br></pre></td></tr></table></figure>

<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料:"></a>参考资料:</h1><p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000040686503">CSR和SSR（更新中。。。）</a><br><a target="_blank" rel="noopener" href="https://github.com/yacan8/blog/issues/30">彻底理解服务端渲染 - SSR原理</a></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://lxlfpeng.github.io">peng</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://lxlfpeng.github.io/2021/08/20/Web%E5%89%8D%E7%AB%AF%E5%90%8E%E7%AB%AF%E6%B8%B2%E6%9F%93/">https://lxlfpeng.github.io/2021/08/20/Web%E5%89%8D%E7%AB%AF%E5%90%8E%E7%AB%AF%E6%B8%B2%E6%9F%93/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://lxlfpeng.github.io" target="_blank">鹏哥的Blog</a>！</span></div></div><div class="tag_share"><div class="post-share"><div class="social-share" data-image="/images/about_avatar.webp" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2021/09/02/AndroidJetpack%E5%88%86%E9%A1%B5%E7%BB%84%E4%BB%B6paging3/" title="AndroidJetpack分页组件paging3"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">AndroidJetpack分页组件paging3</div></div><div class="info-2"><div class="info-item-1">一.什么是pagingJetpack Paging提供了列表中分页数据加载的解决方案，已经被广泛熟知和使用，目前这个库升级到了3.0版本。Paging3 基于Kotlin协程进行了重写，兼容Flow、Rxjava、LiveData等多种API方式。  每一页的数据会缓存至内存中，以此保证处理分页数据时更有效的使用系统资源 内置请求重复数据删除功能，确保应用有效地使用网络带宽和系统资源 支持Kotlin协程、Flow、LiveData以及RxJava 内置错误处理支持，如刷新和重试功能。  二.引入依赖1234//javaimplementation &#x27;androidx.paging:paging-runtime:3.0.0-alpha07&#x27;//kotlinimplementation &#x27;androidx.paging:paging-runtime-ktx:3.0.0-alpha07&#x27; 三.初步使用1. 配置数据源12345678910111213141516171819202122232425262728class...</div></div></div></a><a class="pagination-related" href="/2021/08/13/Ubuntu%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98%E5%8F%8A%E5%A4%84%E7%90%86/" title="Ubuntu相关问题及处理"><img class="cover" src="/images/fb37ca12540fb58a6073b431b513a309.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Ubuntu相关问题及处理</div></div><div class="info-2"><div class="info-item-1">Ubuntu下root用户无法通过SSH登录？如果你的Ubuntu是新安装的，你会发现root用户无法通过SSH登录。这是因为root权限太高可以做任何事，安全起见Ubuntu下的SSH默认不让root登录。 假如一个普通用户有sudo权限，那就可以以普通用户先SSH登录，然后在‘sudo -s’切换成root。这样可行但不是很方便。为了方便起见，我们可以通过修改SSH配置文件让root用户可以直接SSH登录。  打开ssh配置文件*&#x2F;etc&#x2F;ssh&#x2F;sshd_config*  1vim /etc/ssh/sshd_config   找到下面这一行  1PermitRootLogin prohibit-password   将 上面的prohibit-password替换成yes  1PermitRootLogin yes   保存退出  重启sshd.service   1$ sudo systemctl restart sshd.service  完成后root就可以通过SSH登录了，当然需要输入root密码。 注：...</div></div></div></a></nav><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="giscus-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/images/about_avatar.webp" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">peng</div><div class="author-info-description">过往不恋 未来不迎 当下不负</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">127</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">59</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">24</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/lxlfpeng"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/lxlfpeng" target="_blank" title="Github"><i class="fab fa-github" style="color: #4a7dbe;"></i></a><a class="social-icon" href="mailto:565289282@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎来到我的博客!</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B8%B2%E6%9F%93"><span class="toc-number">1.</span> <span class="toc-text">渲染</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E7%BD%91%E9%A1%B5%E6%98%AF%E4%B8%8D%E6%98%AF%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93"><span class="toc-number">1.0.1.</span> <span class="toc-text">如何判断网页是不是服务端渲染</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E7%AB%AF%E6%B8%B2%E6%9F%93%E5%92%8C%E5%90%8E%E7%AB%AF%E6%B8%B2%E6%9F%93%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.1.</span> <span class="toc-text">前端渲染和后端渲染的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E5%88%A4%E6%96%AD%E6%98%AF%E5%89%8D%E7%AB%AF%E6%B8%B2%E6%9F%93%E8%BF%98%E6%98%AF%E5%90%8E%E7%AB%AF%E6%B8%B2%E6%9F%93"><span class="toc-number">1.1.1.</span> <span class="toc-text">快速判断是前端渲染还是后端渲染</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E7%AB%AF%E6%B8%B2%E6%9F%93-%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%B8%B2%E6%9F%93"><span class="toc-number">1.1.2.</span> <span class="toc-text">前端渲染 客户端渲染</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8E%E7%AB%AF%E6%B8%B2%E6%9F%93-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E6%B8%B2%E6%9F%93"><span class="toc-number">1.1.3.</span> <span class="toc-text">后端渲染 服务器端渲染</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E5%90%8E%E7%AB%AF%E6%B8%B2%E6%9F%93%E5%AF%B9%E6%AF%94"><span class="toc-number">1.1.4.</span> <span class="toc-text">前后端渲染对比</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%90%8C%E6%9E%84%E6%B8%B2%E6%9F%93"><span class="toc-number">2.</span> <span class="toc-text">同构渲染</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%B8%B2%E6%9F%93"><span class="toc-number">2.0.1.</span> <span class="toc-text">客户端渲染</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93"><span class="toc-number">2.0.2.</span> <span class="toc-text">服务端渲染</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%B8%B2%E6%9F%93%E5%92%8C%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.0.3.</span> <span class="toc-text">客户端渲染和服务端渲染的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%B8%B2%E6%9F%93%E5%92%8C%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93%E7%9A%84%E5%88%A4%E5%88%AB%E6%96%B9%E6%B3%95"><span class="toc-number">2.0.4.</span> <span class="toc-text">客户端渲染和服务端渲染的判别方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%B8%B2%E6%9F%93%E5%92%8C%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">2.0.5.</span> <span class="toc-text">客户端渲染和服务端渲染使用场景</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8E%E4%BC%A0%E7%BB%9F%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93%E5%8C%BA%E5%88%AB"><span class="toc-number">2.1.</span> <span class="toc-text">与传统服务端渲染区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%8C%E6%9E%84%E6%B8%B2%E6%9F%93%E7%BC%BA%E7%82%B9"><span class="toc-number">2.2.</span> <span class="toc-text">同构渲染缺点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80-%E4%BB%80%E4%B9%88%E6%98%AF%E6%B8%B2%E6%9F%93"><span class="toc-number">2.3.</span> <span class="toc-text">一. 什么是渲染</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C-%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%B8%B2%E6%9F%93"><span class="toc-number">2.4.</span> <span class="toc-text">二. 客户端渲染</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-number">2.4.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E7%82%B9"><span class="toc-number">2.4.2.</span> <span class="toc-text">优点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9"><span class="toc-number">2.4.3.</span> <span class="toc-text">缺点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93"><span class="toc-number">2.5.</span> <span class="toc-text">三. 服务端渲染</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-1"><span class="toc-number">2.5.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E7%82%B9-1"><span class="toc-number">2.5.2.</span> <span class="toc-text">优点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9-1"><span class="toc-number">2.5.3.</span> <span class="toc-text">缺点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B-%E5%90%8C%E6%9E%84%E6%B8%B2%E6%9F%93-%E7%8E%B0%E4%BB%A3%E5%8C%96%E7%9A%84%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93"><span class="toc-number">2.6.</span> <span class="toc-text">四. 同构渲染(现代化的服务端渲染)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-2"><span class="toc-number">2.6.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E6%8A%80%E6%9C%AF"><span class="toc-number">2.6.2.</span> <span class="toc-text">相关技术</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="toc-number">2.6.3.</span> <span class="toc-text">工作流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E7%82%B9-2"><span class="toc-number">2.6.4.</span> <span class="toc-text">优点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9-2"><span class="toc-number">2.6.5.</span> <span class="toc-text">缺点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94-%E6%80%BB%E7%BB%93"><span class="toc-number">2.7.</span> <span class="toc-text">五. 总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E6%B8%B2%E6%9F%93%E5%92%8C%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%B8%B2%E6%9F%93%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">3.</span> <span class="toc-text">服务器端渲染和客户端渲染的区别？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E6%B8%B2%E6%9F%93%E5%92%8C%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%B8%B2%E6%9F%93%EF%BC%9F"><span class="toc-number">3.0.0.1.</span> <span class="toc-text">什么是服务器端渲染和客户端渲染？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%A4%E8%80%85%E6%9C%AC%E8%B4%A8%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">3.0.1.</span> <span class="toc-text">两者本质的区别是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E6%B8%B2%E6%9F%93%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84%EF%BC%9F"><span class="toc-number">3.0.2.</span> <span class="toc-text">服务器端渲染的优缺点是怎样的？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E7%82%B9%EF%BC%9A"><span class="toc-number">3.0.2.1.</span> <span class="toc-text">优点：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%B8%B2%E6%9F%93%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84%EF%BC%9F"><span class="toc-number">3.0.3.</span> <span class="toc-text">客户端渲染的优缺点是怎样的？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E7%82%B9%EF%BC%9A-1"><span class="toc-number">3.0.3.1.</span> <span class="toc-text">优点：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9%EF%BC%9A"><span class="toc-number">3.0.3.2.</span> <span class="toc-text">缺点：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E6%B8%B2%E6%9F%93%E8%BF%98%E6%98%AF%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%B8%B2%E6%9F%93%EF%BC%9F"><span class="toc-number">3.0.4.</span> <span class="toc-text">使用服务器端渲染还是客户端渲染？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E4%BA%8E%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%EF%BC%8C%E5%A6%82%E6%9E%9C%E8%BF%9B%E8%A1%8Cseo%E4%BC%98%E5%8C%96%EF%BC%9F"><span class="toc-number">3.0.5.</span> <span class="toc-text">对于前后端分离，如果进行seo优化？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A9%B6%E7%AB%9F%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%EF%BC%9F"><span class="toc-number">3.0.6.</span> <span class="toc-text">究竟如何理解前后端分离？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93%E5%92%8C%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%B8%B2%E6%9F%93%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">4.</span> <span class="toc-text">服务端渲染和客户端渲染的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%B8%B2%E6%9F%93-1"><span class="toc-number">4.1.</span> <span class="toc-text">客户端渲染</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Server-Side-Rendering%EF%BC%88%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93%EF%BC%89"><span class="toc-number">4.2.</span> <span class="toc-text">Server Side Rendering（服务端渲染）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%B8%B2%E6%9F%93%E4%B8%8E%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93"><span class="toc-number">5.</span> <span class="toc-text">客户端渲染与服务端渲染</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E6%B8%B2%E6%9F%93%E5%92%8C%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%B8%B2%E6%9F%93%EF%BC%9F-1"><span class="toc-number">5.0.1.</span> <span class="toc-text">什么是服务器端渲染和客户端渲染？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%A4%E8%80%85%E6%9C%AC%E8%B4%A8%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F-1"><span class="toc-number">5.0.2.</span> <span class="toc-text">两者本质的区别是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%9C%A8%E9%A1%B5%E9%9D%A2%E4%B8%AD%E5%BF%AB%E9%80%9F%E7%9A%84%E5%88%A4%E6%96%AD%E5%87%BA%E6%9D%A5%EF%BC%9F"><span class="toc-number">5.0.3.</span> <span class="toc-text">如何在页面中快速的判断出来？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="toc-number">6.</span> <span class="toc-text">参考资料:</span></a></li></ol></div></div></div></div></main><footer id="footer" style="background: linear-gradient(20deg, #0062be, #925696, #cc426e, #fb0347);"><div id="footer-wrap"><div class="copyright">&copy;2015 - 2025 By peng</div><div class="footer_custom_text"> <a target="_blank" rel="nofollow noopener"><span>千里之行</span></a> <i class="iconfont icon-love"></i> <a target="_blank" rel="nofollow noopener"><span>始于足下</span></a> </div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.isShuoshuo
  const option = null

  const getGiscusTheme = theme => theme === 'dark' ? 'dark' : 'light'

  const createScriptElement = config => {
    const ele = document.createElement('script')
    Object.entries(config).forEach(([key, value]) => {
      ele.setAttribute(key, value)
    })
    return ele
  }

  const loadGiscus = (el = document, key) => {
    const mappingConfig = isShuoshuo
      ? { 'data-mapping': 'specific', 'data-term': key }
      : { 'data-mapping': (option && option['data-mapping']) || 'pathname' }

    const giscusConfig = {
      src: 'https://giscus.app/client.js',
      'data-repo': 'lxlfpeng/blog_comments',
      'data-repo-id': 'R_kgDONYoexA',
      'data-category-id': 'DIC_kwDONYoexM4Ck4JQ',
      'data-theme': getGiscusTheme(document.documentElement.getAttribute('data-theme')),
      'data-reactions-enabled': '1',
      crossorigin: 'anonymous',
      async: true,
      ...option,
      ...mappingConfig
    }

    const scriptElement = createScriptElement(giscusConfig)

    el.querySelector('#giscus-wrap').appendChild(scriptElement)

    if (isShuoshuo) {
      window.shuoshuoComment.destroyGiscus = () => {
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }
  }

  const changeGiscusTheme = theme => {
    const iframe = document.querySelector('#giscus-wrap iframe')
    if (iframe) {
      const message = {
        giscus: {
          setConfig: {
            theme: getGiscusTheme(theme)
          }
        }
      }
      iframe.contentWindow.postMessage(message, 'https://giscus.app')
    }
  }

  btf.addGlobalFn('themeChange', changeGiscusTheme, 'giscus')

  if (isShuoshuo) {
    'Giscus' === 'Giscus'
      ? window.shuoshuoComment = { loadComment: loadGiscus }
      : window.loadOtherComment = loadGiscus
    return
  }

  if ('Giscus' === 'Giscus' || !false) {
    if (false) btf.loadComment(document.getElementById('giscus-wrap'), loadGiscus)
    else loadGiscus()
  } else {
    window.loadOtherComment = loadGiscus
  }
})()</script></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="false"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>