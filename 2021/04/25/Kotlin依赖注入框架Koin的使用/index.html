<!DOCTYPE html><html lang="zh-CN" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Kotlin依赖注入框架Koin的使用 | 鹏哥的Blog</title><meta name="author" content="peng"><meta name="copyright" content="peng"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#0d0d0d"><meta name="description" content="一.引入Koin依赖Koin是一款轻量级的依赖注入框架，根据官方的描述，它无代理，无代码生成，无反射。 12345678def koinVersion &#x3D; &quot;2.2.2&quot;   &#x2F;&#x2F;Koin for android   implementation &quot;org.koin:koin-android:$koinVersion&quot;   &#x2F;&#x2F;Koin for scope">
<meta property="og:type" content="article">
<meta property="og:title" content="Kotlin依赖注入框架Koin的使用">
<meta property="og:url" content="https://lxlfpeng.github.io/2021/04/25/Kotlin%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E6%A1%86%E6%9E%B6Koin%E7%9A%84%E4%BD%BF%E7%94%A8/index.html">
<meta property="og:site_name" content="鹏哥的Blog">
<meta property="og:description" content="一.引入Koin依赖Koin是一款轻量级的依赖注入框架，根据官方的描述，它无代理，无代码生成，无反射。 12345678def koinVersion &#x3D; &quot;2.2.2&quot;   &#x2F;&#x2F;Koin for android   implementation &quot;org.koin:koin-android:$koinVersion&quot;   &#x2F;&#x2F;Koin for scope">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://lxlfpeng.github.io/images/about_avatar.webp">
<meta property="article:published_time" content="2021-04-24T16:00:00.000Z">
<meta property="article:modified_time" content="2025-04-12T15:02:01.844Z">
<meta property="article:author" content="peng">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://lxlfpeng.github.io/images/about_avatar.webp"><link rel="shortcut icon" href="/images/favicon.webp"><link rel="canonical" href="https://lxlfpeng.github.io/2021/04/25/Kotlin%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E6%A1%86%E6%9E%B6Koin%E7%9A%84%E4%BD%BF%E7%94%A8/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Kotlin依赖注入框架Koin的使用',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  isShuoshuo: false
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/images/about_avatar.webp" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">127</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">59</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">24</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/categories"><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background: linear-gradient(20deg, #0062be, #925696, #cc426e, #fb0347);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src="/images/nav_logo.webp" alt="Logo"><span class="site-name">鹏哥的Blog</span></a><a class="nav-page-title" href="/"><span class="site-name">Kotlin依赖注入框架Koin的使用</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/categories"><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Kotlin依赖注入框架Koin的使用</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2021-04-24T16:00:00.000Z" title="发表于 2021-04-25 00:00:00">2021-04-25</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Kotlin%E8%AF%AD%E8%A8%80/">Kotlin语言</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">2.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>9分钟</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="一-引入Koin依赖"><a href="#一-引入Koin依赖" class="headerlink" title="一.引入Koin依赖"></a>一.引入Koin依赖</h1><p>Koin是一款轻量级的依赖注入框架，根据官方的描述，它无代理，无代码生成，无反射。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def koinVersion = &quot;2.2.2&quot;</span><br><span class="line">   //Koin for android</span><br><span class="line">   implementation &quot;org.koin:koin-android:$koinVersion&quot;</span><br><span class="line">   //Koin for scope feature</span><br><span class="line">   implementation &quot;org.koin:koin-android-scope:$koinVersion&quot;</span><br><span class="line">   //Koin for viewModel feature</span><br><span class="line">   implementation &quot;org.koin:koin-android-viewmodel:$koinVersion&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="二-Koin基础使用"><a href="#二-Koin基础使用" class="headerlink" title="二.Koin基础使用"></a>二.Koin基础使用</h1><p>在application中来做startkoin初始化的动作</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class MyApp : Application() &#123;</span><br><span class="line">    override fun onCreate() &#123;</span><br><span class="line">        super.onCreate()</span><br><span class="line">        startKoin &#123;</span><br><span class="line">            //开始启动koin</span><br><span class="line">            androidContext(this@MyApp)//这边传Application对象,这样你注入的类中,需要app对象的时候,可以直接使用</span><br><span class="line">            modules(appModule)//这里面传各种被注入的模块对象,支持多模块注入</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    val appModule = module &#123;//里面添加各种注入对象</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-注入方式"><a href="#1-注入方式" class="headerlink" title="1.注入方式"></a>1.注入方式</h3><table>
<thead>
<tr>
<th>方法名</th>
<th>描述</th>
<th>使用</th>
</tr>
</thead>
<tbody><tr>
<td>single</td>
<td>生成单一对象</td>
<td>by inject()</td>
</tr>
<tr>
<td>factory</td>
<td>每次都会生成新的对象</td>
<td>by inject()</td>
</tr>
<tr>
<td>viewModel</td>
<td>用来创建ViewModel实例，默认生成的都是新对象</td>
<td>by viewModel(),通过get<T>()来获取的ViewModel是不同的对象</td>
</tr>
<tr>
<td>fragment</td>
<td>用来创建fragment</td>
<td>by inject()</td>
</tr>
</tbody></table>
<h5 id="1-普通注入"><a href="#1-普通注入" class="headerlink" title="(1.)普通注入"></a>(1.)普通注入</h5><p>使用方式–Factory注入<br>Factory注入方式跟普通new一个对象一样.factory就是获取的时候每次都生成一个新的实例.会创建多个对象</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建一个Person类,然后在我们的MyApp中的appModule中,将该Person类注入一下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class MyApp : Application() &#123;</span><br><span class="line">      ...</span><br><span class="line">        val appModule = module &#123;//里面添加各种注入对象</span><br><span class="line">        factory &#123;//普通的注入方式</span><br><span class="line">            Person()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在Activity中调用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class FactoryActivity : AppCompatActivity() &#123;</span><br><span class="line">    //调用方式有大致下面几种,后面会再说到</span><br><span class="line">    val person: Person by inject()//方法一</span><br><span class="line">    val person2 by inject&lt;Person&gt;()//方法二</span><br><span class="line">    override fun onCreate(savedInstanceState: Bundle?) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_factory)</span><br><span class="line">        val person3 = get&lt;Person&gt;()//方法三</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="2-单例注入"><a href="#2-单例注入" class="headerlink" title="(2.)单例注入"></a>(2.)单例注入</h5><p>Single用法<br>在MyApp中的appModule中,将该Person类使用方式为single注入一下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class MyApp : Application() &#123;</span><br><span class="line">      ...</span><br><span class="line">        val appModule = module &#123;//里面添加各种注入对象</span><br><span class="line">        single  &#123;//单例的注入方式</span><br><span class="line">            Person()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在Activity中调用生成的三个注入对象是同一个</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class FactoryActivity : AppCompatActivity() &#123;</span><br><span class="line">    //调用方式有大致下面几种,后面会再说到</span><br><span class="line">    val person: Person by inject()//方法一</span><br><span class="line">    val person2 by inject&lt;Person&gt;()//方法二</span><br><span class="line">    override fun onCreate(savedInstanceState: Bundle?) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_factory)</span><br><span class="line">        val person3 = get&lt;Person&gt;()//方法三</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="三-Koin注入带有参数的构造函数"><a href="#三-Koin注入带有参数的构造函数" class="headerlink" title="三.Koin注入带有参数的构造函数"></a>三.Koin注入带有参数的构造函数</h1><h3 id="1-单个构造参数"><a href="#1-单个构造参数" class="headerlink" title="1.单个构造参数"></a>1.单个构造参数</h3><p>修改Person类,使其构造函数带有参数.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class Person(var name:String) &#123;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>添加依赖时需要将构造参数传入</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class MyApp : Application() &#123;</span><br><span class="line">      ...</span><br><span class="line">        val appModule = module &#123;//里面添加各种注入对象</span><br><span class="line">        factory  &#123;</span><br><span class="line">            Person(&quot;张三&quot;)//构造对象的时候将构造参数传入</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-构造函数依赖于其他类"><a href="#2-构造函数依赖于其他类" class="headerlink" title="2. 构造函数依赖于其他类"></a>2. 构造函数依赖于其他类</h3><p>Person类构造时依赖于PersonInfo类</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class Person(var personInfo:PersonInfo) &#123;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class PersonInfo(var name:String) &#123;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>构造时可以通过get()来获取之前创建过的参数对象.</p>
<blockquote>
<p>get()会自动去寻找之前创建过的依赖,找到合适的依赖</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class MyApp : Application() &#123;</span><br><span class="line">      ...</span><br><span class="line">        val appModule = module &#123;//里面添加各种注入对象</span><br><span class="line">        factory  &#123;</span><br><span class="line">            PersonInfo(&quot;张三&quot;)//构造对象的时候将构造参数传入</span><br><span class="line">        &#125;</span><br><span class="line">        factory  &#123;</span><br><span class="line">            PersonInfo(get())//get()会自动去寻找之前创建过的依赖PersonInfo</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-多个构造函数"><a href="#3-多个构造函数" class="headerlink" title="3. 多个构造函数"></a>3. 多个构造函数</h3><p>通过限定符标记构造方法–qualifier<br>如果被依赖的类有多个构造函数,如何知道用哪个构造函数进行初始化.这里就需要用到限定符qualifier,如果不用就会造成依赖迷失引发报错<br>创建有多个构造函数的类:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class MultStructureHotPot constructor(var name: String) &#123;</span><br><span class="line"></span><br><span class="line">    //第二个构造方法</span><br><span class="line">    constructor(name: String, vegetables: Vegetables) : this(name)</span><br><span class="line"></span><br><span class="line">    //第三个构造方法</span><br><span class="line">    constructor(name: String, vegetables: Vegetables, meat: Meat) : this(name)</span><br><span class="line"></span><br><span class="line">    fun cook() &#123;</span><br><span class="line">        LogTest.d(&quot;开始制作$&#123;name&#125;火锅&quot;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>注入module</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class MyApp : Application() &#123;</span><br><span class="line">      ...</span><br><span class="line">  val hotPotModule = module &#123;//里面添加各种注入对象</span><br><span class="line">      factory &#123;</span><br><span class="line">          Vegetables(&quot;各种蔬菜&quot;)</span><br><span class="line">      &#125;</span><br><span class="line">      factory &#123;</span><br><span class="line">          Meat(&quot;各种肉类&quot;)</span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">      factory &#123;</span><br><span class="line">          MultStructureHotPot(&quot;空火锅&quot;)</span><br><span class="line">      &#125;</span><br><span class="line">      factory(named(&quot;vegetables&quot;)) &#123;</span><br><span class="line">          MultStructureHotPot(&quot;蔬菜火锅&quot;, get())</span><br><span class="line">      &#125;</span><br><span class="line">      factory(named(&quot;multi&quot;)) &#123;</span><br><span class="line">          MultStructureHotPot(&quot;荤素搭配火锅&quot;, get(), get())</span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">  &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class FactoryActivity : AppCompatActivity() &#123;</span><br><span class="line">       val mHotPot: MultStructureHotPot by inject()</span><br><span class="line">       val mVegetablesHotPot: MultStructureHotPot by inject(named(&quot;vegetables&quot;))</span><br><span class="line">       val mMutilHotPot: MultStructureHotPot by inject(named(&quot;multi&quot;))</span><br><span class="line">    override fun onCreate(savedInstanceState: Bundle?) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_factory)</span><br><span class="line">       </span><br><span class="line">        mHotPot.cook()</span><br><span class="line">        mVegetablesHotPot.cook()</span><br><span class="line">        mMutilHotPot.cook()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-构造函数从外部传入"><a href="#4-构造函数从外部传入" class="headerlink" title="4. 构造函数从外部传入"></a>4. 构造函数从外部传入</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">val hotPotModule = module &#123;//里面添加各种注入对象</span><br><span class="line">    factory &#123;</span><br><span class="line">        Vegetables(&quot;各种蔬菜&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    factory &#123;</span><br><span class="line">        Meat(&quot;各种肉类&quot;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    factory &#123;</span><br><span class="line">        MultStructureHotPot(&quot;空火锅&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    factory(named(&quot;vegetables&quot;)) &#123;</span><br><span class="line">        MultStructureHotPot(&quot;蔬菜火锅&quot;, get())</span><br><span class="line">    &#125;</span><br><span class="line">    factory(named(&quot;multi&quot;)) &#123;</span><br><span class="line">        MultStructureHotPot(&quot;荤素搭配火锅&quot;, get(), get())</span><br><span class="line">    &#125;</span><br><span class="line">    factory(named(&quot;external&quot;)) &#123; (meat: Meat) -&gt;</span><br><span class="line">        MultStructureHotPot(&quot;荤素搭配火锅&quot;, get(), meat)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过parametersOf()传递参数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class KoinSingleActivity : AppCompatActivity() &#123;</span><br><span class="line">    val mMutilHotPot2: MultStructureHotPot by inject(named(&quot;external&quot;)) &#123;</span><br><span class="line">        parametersOf(Meat(&quot;驴肉&quot;))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun onCreate(savedInstanceState: Bundle?) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.test_activity_koin_single)</span><br><span class="line">        mMutilHotPot2.cook()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="四-Koin中scope范围限定"><a href="#四-Koin中scope范围限定" class="headerlink" title="四.Koin中scope范围限定"></a>四.Koin中scope范围限定</h1><p>Scope 用于控制对象在 Koin 内的生命周期。事实上，前面所讲的 single 与 factory 都是 scope。single 创建的对象在整个容器的生命周期内都是存在的，因此任意地方注入都是同一实例。<br>factory 每次都创建新的对象，因此它不被保存，也不能共享实例。注入对象都是有作用范围的，如果没有指定scope的话,就是koin的一个rootScope，如果指定scope，注入时就会从该scope中去查找声明的对象<br>scope下的对象可以跟一个视图绑定起来,并且该被绑定的对象是单例的模式,其他界面通过scopeId可以获取这个对象.当该视图被销毁的时候,被绑定的对象也会被销毁.其他界面也就获取不到这个scope对象了.</p>
<blockquote>
<p>使用scope可以使对象可以跟一个界面绑定起来,并且该被绑定的对象是单例的模式,其他界面通过scopeId可以获取这个被绑定对象.当被绑定的界面被销毁的时候,被绑定的对象也会被销毁.其他界面通过scopeId就不能获取这个被绑定对象了.<br>之前我们学习的single只能创建一个单例对象，factroy每次都创建新的对象。Scope的出现能把不同作用域内的对象作为一个对象，比如说我们想在Activity1和Activity2中的person是一个单例，Activity3和activity4中的Person是一个单例。我们就可以使用Scope来实现</p>
</blockquote>
<p>定义 Scope 比较简单：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">val myModule = module&#123;</span><br><span class="line">    scope(named(&quot;MY_SCOPE&quot;))&#123;</span><br><span class="line">        scoped &#123;</span><br><span class="line">            Stove()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是使用起来就比较麻烦了，需要创建或关闭 scope，毕竟 Kolin 怎么会知道你究竟想实现怎样的生命周期呢？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// 如果存在则直接获取，否则创建 scope</span><br><span class="line">val scope = getKoin().getOrCreateScope(&quot;myScope&quot;, named(&quot;MY_SCOPE&quot;))</span><br><span class="line">val stove1: Stove = scope.get()</span><br><span class="line">val stove2: Stove = scope.get()</span><br><span class="line">scope.close()</span><br></pre></td></tr></table></figure>
<p>这里首先得到了一个 scope 实例，然后进行注入，最后关闭 scope。那么在同一个 scope 中注入的实例是相同的。例如 stove1 与 stove2 实际上是同一个实例。当 scope 被关闭时其缓存会被清空，自然下一次重新创建后会注入新的对象。<br>注意区分一点，定义 Scope 时使用的叫做 Qualifier，通过 named 可以用字符串包装。在创建 scope 时需要通过 Qualifier 关联到定义，并同时给一个字符串类型的 id，id 仅在运行时使用。可以类比成 Android 的布局文件的 View id 与实际变量名的关系。我们需要通过 View id 来获取实例并赋值给变量保存，变量名与 View id 没有必然的关系。<br>在 Android 中我们经常需要以 Activity 为单位创建 scope，为了简化使用，Koin 提供了 Android 扩展库。在 Activity 与 Fragment 中，可以直接使用 currentScope 变量来表示当前 scope，他会被自动创建，并绑定到 Android 组件的生命周期。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class LocalWatchFaceAty : AppCompatActivity() &#123;</span><br><span class="line">    private val stove: Stove by currentScope.inject()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除了之前使用的 get，还可以像这样使用 inject 实现懒加载。<br>定义 scope 也变得简单。之前我们使用字符串作为限定符定义了 scope，现在直接使用类作为限定符：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">val myModule = module&#123;</span><br><span class="line">    scope(named&lt;LocalWatchFaceAty&gt;())&#123;</span><br><span class="line">        scoped &#123;</span><br><span class="line">            Stove()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="五-普通类中使用Koin注解，需要实现KoinComponent接口"><a href="#五-普通类中使用Koin注解，需要实现KoinComponent接口" class="headerlink" title="五.普通类中使用Koin注解，需要实现KoinComponent接口"></a>五.普通类中使用Koin注解，需要实现KoinComponent接口</h1><p>创建一个类,该类实现了KoinComponent,在该类中,我们就可以通过by inject和get来过去被注入过的对象了.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//类实现了KoinComponent,在该类中,我们就可以通过by inject和get来过去被注入过的对象了.</span><br><span class="line">class InjectPerson : KoinComponent &#123;</span><br><span class="line">    val person = get&lt;KoinPerson&gt;()//非懒加载模式</span><br><span class="line">    val person2=inject&lt;KoinPerson&gt; ()//懒加载模式</span><br><span class="line">    fun speak()&#123;</span><br><span class="line">        person.speak()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以直接使用注解</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class KoinSingleActivity : AppCompatActivity() &#123;</span><br><span class="line">    </span><br><span class="line">    override fun onCreate(savedInstanceState: Bundle?) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.test_activity_koin_single)</span><br><span class="line">         //在第三方类中使用注解</span><br><span class="line">         InjectPerson().speak()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="六-Koin结合ViewModel使用"><a href="#六-Koin结合ViewModel使用" class="headerlink" title="六.Koin结合ViewModel使用"></a>六.Koin结合ViewModel使用</h1><p>ViewModel 可以说是 Android 架构组件发布后最流行的部分了，幸运的是 Kolin 对其做了非常方便的适配。对于 ViewModel 类直接使用 viewModel 来定义 Service：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">val localModule = module &#123;</span><br><span class="line">    viewModel &#123;</span><br><span class="line">        KitchenViewModel()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 Activity 或 Fragment 中直接使用 by viewModel() 或 getViewModel() 来注入。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class LocalWatchFaceAty : AppCompatActivity() &#123;</span><br><span class="line">    private val vm: KitchenViewModel by viewModel()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样一来得到的 ViewModel 可以自动与 UI 生命周期关联。而如果使用传统的 get 只能得到实例但没有任何关联，失去了 ViewModel 最重要的作用。</p>
<p>参考资料:<br><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903929117933576">使用Koin来完成Kotlin的依赖注入</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/Shaojihan/article/details/104349741">Koin–适用于Kotlin的超好用依赖注入框架</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_45365889/article/details/100566332">Android Koin2 基本使用那件事</a><br><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/8d78761f3c6f?utm_campaign=shakespeare">深入理解Koin框架之koin-core</a></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://lxlfpeng.github.io">peng</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://lxlfpeng.github.io/2021/04/25/Kotlin%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E6%A1%86%E6%9E%B6Koin%E7%9A%84%E4%BD%BF%E7%94%A8/">https://lxlfpeng.github.io/2021/04/25/Kotlin%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E6%A1%86%E6%9E%B6Koin%E7%9A%84%E4%BD%BF%E7%94%A8/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://lxlfpeng.github.io" target="_blank">鹏哥的Blog</a>！</span></div></div><div class="tag_share"><div class="post-share"><div class="social-share" data-image="/images/about_avatar.webp" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2021/05/13/Flutter%E4%B9%8B%E5%B8%B8%E8%A7%81%E6%8E%A7%E4%BB%B6/" title="Flutter之常见控件"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Flutter之常见控件</div></div><div class="info-2"><div class="info-item-1">Flutter列表控件在 Flutter 中，ListView 可以沿一个方向（垂直或水平方向）来排列其所有子 Widget，常被用于需要展示一组连续视图元素的场景。ListView 构造方法:  ListView：仅适用于列表中含有少量元素的场景 ListView.build：适用于子 Widget 比较多的场景 ListView.separated：适用于需要设置分割线的场景   构造方法名 特点 使用场景    ListView 一次性创建好所有子 Widget 适用于展示少量连续子 Widget 的场景。   ListView.build 提供了子 Widget 创建方法，仅在需要展示时才创建 适用于子 Widget 较多，且视觉效果呈现某种规律性的场景。   ListView.separated 提供了子 Widget 创建方法，仅在需要展示时才创建，且提供了自定义分割线的功能 适用于子 Widget 较多，且视觉效果呈现某种规律性、每个子 Widget 之间需要分割线的场景。     1.ListView可以通过设置 children 参数，将所有子 Widget...</div></div></div></a><a class="pagination-related" href="/2021/04/25/SpringBoot%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%B9%8B%E4%BA%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3/" title="SpringBoot学习总结之二数据库相关"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">SpringBoot学习总结之二数据库相关</div></div><div class="info-2"><div class="info-item-1">一.常见的数据库访问框架在Web项目开发中，数据库的访问是必不可少的。    ORM持久化技术 模板类    JDBC(JdbcTemplate) org.springframework.jdbc.core.JdbcTemplate   JPA org.springfrmaework.orm.jpa.JpaTemplate   IBatis(MyBatis) org.springframework.orm.ibatis.SqlMapClientTemplate   1.JdbcTemplateJdbcTemplate是Spring对JDBC的模板封装，提供了一套JDBC模板，能够让我们写持久层代码时减少冗余代码，简化JDBC代码，使代码更加简洁。Spring Boot默认支持JdbcTemplate（无需配置）。JdbcTemplate在实际开发中一般不会使用，通常都是使用MyBatis、Hibernate等更加成熟、优秀的数据持久层框架。 2.JPAJPA全称是Java Persistence...</div></div></div></a></nav><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="giscus-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/images/about_avatar.webp" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">peng</div><div class="author-info-description">过往不恋 未来不迎 当下不负</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">127</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">59</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">24</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/lxlfpeng"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/lxlfpeng" target="_blank" title="Github"><i class="fab fa-github" style="color: #4a7dbe;"></i></a><a class="social-icon" href="mailto:565289282@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎来到我的博客!</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80-%E5%BC%95%E5%85%A5Koin%E4%BE%9D%E8%B5%96"><span class="toc-number">1.</span> <span class="toc-text">一.引入Koin依赖</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C-Koin%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8"><span class="toc-number">2.</span> <span class="toc-text">二.Koin基础使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%B3%A8%E5%85%A5%E6%96%B9%E5%BC%8F"><span class="toc-number">2.0.1.</span> <span class="toc-text">1.注入方式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E6%99%AE%E9%80%9A%E6%B3%A8%E5%85%A5"><span class="toc-number">2.0.1.0.1.</span> <span class="toc-text">(1.)普通注入</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%8D%95%E4%BE%8B%E6%B3%A8%E5%85%A5"><span class="toc-number">2.0.1.0.2.</span> <span class="toc-text">(2.)单例注入</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89-Koin%E6%B3%A8%E5%85%A5%E5%B8%A6%E6%9C%89%E5%8F%82%E6%95%B0%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">3.</span> <span class="toc-text">三.Koin注入带有参数的构造函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%8D%95%E4%B8%AA%E6%9E%84%E9%80%A0%E5%8F%82%E6%95%B0"><span class="toc-number">3.0.1.</span> <span class="toc-text">1.单个构造参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%BE%9D%E8%B5%96%E4%BA%8E%E5%85%B6%E4%BB%96%E7%B1%BB"><span class="toc-number">3.0.2.</span> <span class="toc-text">2. 构造函数依赖于其他类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%A4%9A%E4%B8%AA%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">3.0.3.</span> <span class="toc-text">3. 多个构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%BB%8E%E5%A4%96%E9%83%A8%E4%BC%A0%E5%85%A5"><span class="toc-number">3.0.4.</span> <span class="toc-text">4. 构造函数从外部传入</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9B-Koin%E4%B8%ADscope%E8%8C%83%E5%9B%B4%E9%99%90%E5%AE%9A"><span class="toc-number">4.</span> <span class="toc-text">四.Koin中scope范围限定</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%94-%E6%99%AE%E9%80%9A%E7%B1%BB%E4%B8%AD%E4%BD%BF%E7%94%A8Koin%E6%B3%A8%E8%A7%A3%EF%BC%8C%E9%9C%80%E8%A6%81%E5%AE%9E%E7%8E%B0KoinComponent%E6%8E%A5%E5%8F%A3"><span class="toc-number">5.</span> <span class="toc-text">五.普通类中使用Koin注解，需要实现KoinComponent接口</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AD-Koin%E7%BB%93%E5%90%88ViewModel%E4%BD%BF%E7%94%A8"><span class="toc-number">6.</span> <span class="toc-text">六.Koin结合ViewModel使用</span></a></li></ol></div></div></div></div></main><footer id="footer" style="background: linear-gradient(20deg, #0062be, #925696, #cc426e, #fb0347);"><div id="footer-wrap"><div class="copyright">&copy;2015 - 2025 By peng</div><div class="footer_custom_text"> <a target="_blank" rel="nofollow noopener"><span>千里之行</span></a> <i class="iconfont icon-love"></i> <a target="_blank" rel="nofollow noopener"><span>始于足下</span></a> </div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.isShuoshuo
  const option = null

  const getGiscusTheme = theme => theme === 'dark' ? 'dark' : 'light'

  const createScriptElement = config => {
    const ele = document.createElement('script')
    Object.entries(config).forEach(([key, value]) => {
      ele.setAttribute(key, value)
    })
    return ele
  }

  const loadGiscus = (el = document, key) => {
    const mappingConfig = isShuoshuo
      ? { 'data-mapping': 'specific', 'data-term': key }
      : { 'data-mapping': (option && option['data-mapping']) || 'pathname' }

    const giscusConfig = {
      src: 'https://giscus.app/client.js',
      'data-repo': 'lxlfpeng/blog_comments',
      'data-repo-id': 'R_kgDONYoexA',
      'data-category-id': 'DIC_kwDONYoexM4Ck4JQ',
      'data-theme': getGiscusTheme(document.documentElement.getAttribute('data-theme')),
      'data-reactions-enabled': '1',
      crossorigin: 'anonymous',
      async: true,
      ...option,
      ...mappingConfig
    }

    const scriptElement = createScriptElement(giscusConfig)

    el.querySelector('#giscus-wrap').appendChild(scriptElement)

    if (isShuoshuo) {
      window.shuoshuoComment.destroyGiscus = () => {
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }
  }

  const changeGiscusTheme = theme => {
    const iframe = document.querySelector('#giscus-wrap iframe')
    if (iframe) {
      const message = {
        giscus: {
          setConfig: {
            theme: getGiscusTheme(theme)
          }
        }
      }
      iframe.contentWindow.postMessage(message, 'https://giscus.app')
    }
  }

  btf.addGlobalFn('themeChange', changeGiscusTheme, 'giscus')

  if (isShuoshuo) {
    'Giscus' === 'Giscus'
      ? window.shuoshuoComment = { loadComment: loadGiscus }
      : window.loadOtherComment = loadGiscus
    return
  }

  if ('Giscus' === 'Giscus' || !false) {
    if (false) btf.loadComment(document.getElementById('giscus-wrap'), loadGiscus)
    else loadGiscus()
  } else {
    window.loadOtherComment = loadGiscus
  }
})()</script></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="false"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>