<!DOCTYPE html><html lang="zh-CN" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Git命令及GIt Flow工作流 | 鹏哥的Blog</title><meta name="author" content="peng"><meta name="copyright" content="peng"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#0d0d0d"><meta name="description" content="一.Git简介Git是目前世界上最先进的分布式版本控制系统。它就没有中央服务器的，每个人的电脑就是一个完整的版本库，这样，工作的时候就不需要联网了，因为版本都是在自己的电脑上。完成开发以后再将各自的修改推送给对方，就可以互相看到对方的修改了(为了便于项目中的所有开发者分享代码，我们将代码存放远程 Git 仓库例如github)。与此对应的是SVN是集中式版本控制系统，版本库是集中放在中央服务器的，">
<meta property="og:type" content="article">
<meta property="og:title" content="Git命令及GIt Flow工作流">
<meta property="og:url" content="https://lxlfpeng.github.io/2015/10/31/Git%E5%91%BD%E4%BB%A4%E5%8F%8AGIt%20Flow%E5%B7%A5%E4%BD%9C%E6%B5%81/index.html">
<meta property="og:site_name" content="鹏哥的Blog">
<meta property="og:description" content="一.Git简介Git是目前世界上最先进的分布式版本控制系统。它就没有中央服务器的，每个人的电脑就是一个完整的版本库，这样，工作的时候就不需要联网了，因为版本都是在自己的电脑上。完成开发以后再将各自的修改推送给对方，就可以互相看到对方的修改了(为了便于项目中的所有开发者分享代码，我们将代码存放远程 Git 仓库例如github)。与此对应的是SVN是集中式版本控制系统，版本库是集中放在中央服务器的，">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://lxlfpeng.github.io/images/about_avatar.webp">
<meta property="article:published_time" content="2015-10-30T16:00:00.000Z">
<meta property="article:modified_time" content="2025-04-12T15:02:01.844Z">
<meta property="article:author" content="peng">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://lxlfpeng.github.io/images/about_avatar.webp"><link rel="shortcut icon" href="/images/favicon.webp"><link rel="canonical" href="https://lxlfpeng.github.io/2015/10/31/Git%E5%91%BD%E4%BB%A4%E5%8F%8AGIt%20Flow%E5%B7%A5%E4%BD%9C%E6%B5%81/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Git命令及GIt Flow工作流',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  isShuoshuo: false
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/images/about_avatar.webp" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">127</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">59</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">24</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/categories"><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background: linear-gradient(20deg, #0062be, #925696, #cc426e, #fb0347);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src="/images/nav_logo.webp" alt="Logo"><span class="site-name">鹏哥的Blog</span></a><a class="nav-page-title" href="/"><span class="site-name">Git命令及GIt Flow工作流</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/categories"><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Git命令及GIt Flow工作流</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2015-10-30T16:00:00.000Z" title="发表于 2015-10-31 00:00:00">2015-10-31</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Git/">Git</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">8.6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>29分钟</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="一-Git简介"><a href="#一-Git简介" class="headerlink" title="一.Git简介"></a>一.Git简介</h1><p>Git是目前世界上最先进的分布式版本控制系统。它就没有中央服务器的，每个人的电脑就是一个完整的版本库，这样，工作的时候就不需要联网了，因为版本都是在自己的电脑上。<br>完成开发以后再将各自的修改推送给对方，就可以互相看到对方的修改了(为了便于项目中的所有开发者分享代码，我们将代码存放远程 Git 仓库例如github)。与此对应的是SVN是集中式版本控制系统，<br>版本库是集中放在中央服务器的，而干活的时候，用的都是自己的电脑，所以首先要从中央服务器哪里得到最新的版本，然后干活，干完后，需要把自己做完的活推送到中央服务器。而且集中式版本控制系统是必须联网才能工作。</p>
<h1 id="二-Git文件状态"><a href="#二-Git文件状态" class="headerlink" title="二.Git文件状态"></a>二.Git文件状态</h1><ul>
<li><strong>Untracked</strong>: 未跟踪, 此文件在文件夹中, 但并没有加入到git库, 不参与版本控制. 通过<code>git add</code> 状态变为<code>Staged</code></li>
<li><strong>Unmodify</strong>: 文件已经入库, 未修改, 即版本库中的文件快照内容与文件夹中完全一致. 这种类型的文件有两种去处, 如果它被修改, 而变为<code>Modified</code>. 如果使用<code>git rm</code>移出版本库, 则成为<code>Untracked</code>文件</li>
<li><strong>Modified</strong>: 文件已修改, 仅仅是修改, 并没有进行其他的操作. 这个文件也有两个去处, 通过<code>git add</code>可进入暂存<code>staged</code>状态, 使用<code>git checkout</code> 则丢弃修改过, 返回到<code>unmodify</code>状态, 这个<code>git checkout</code>即从库中取出文件, 覆盖当前修改</li>
<li><strong>Staged</strong>: 暂存状态. 执行<code>git commit</code>则将修改同步到库中, 这时库中的文件和本地文件又变为一致, 文件为<code>Unmodify</code>状态. 执行<code>git reset HEAD filename</code>取消暂存, 文件状态为<code>Modified</code><br><img src="/images/343cb650fbda3c1cfa84ea20f54e5605.webp"></li>
</ul>
<h1 id="三-Git常见命令"><a href="#三-Git常见命令" class="headerlink" title="三.Git常见命令"></a>三.Git常见命令</h1><h3 id="1-设置相关"><a href="#1-设置相关" class="headerlink" title="1.设置相关"></a>1.设置相关</h3><ul>
<li><code>git config --list</code>查看配置</li>
<li><code>git config user.name</code>查看用户名</li>
<li><code>git config user.email</code>查看邮箱</li>
<li><code>git config --global user.name &quot;nameVal&quot;</code>配置全局用户名</li>
<li><code>git config --global user.email &quot;eamil@qq.com&quot;</code>配置全局邮箱</li>
<li><code>git config --global credential.helper store</code>全局缓存登录凭证</li>
<li><code>git config user.name “xxxx” </code>配置单个项目用户名(需进入到项目文件夹根目录里面)</li>
<li><code>git config user.email &quot;xxxx@xx.com&quot; </code>配置单个项目邮箱(需进入到项目文件夹根目录里面)</li>
<li><code>git config –global credential.helper cache</code> 设置记住密码（默认<strong>15分钟</strong>）</li>
<li><code>git config credential.helper ‘cache –timeout=3600’</code>设置记住密码自定义过期时间（这里设置一个小时之后失效）</li>
<li><code>git config –global credential.helper store</code>设置记住密码长期存储</li>
<li><code>git config --global credential.helper wincred</code>清除缓存登录凭证</li>
<li><code>git credential-manager uninstall</code>清除缓存在git中的用户名和密码</li>
<li><code>git version</code>查看git软件的版本号。</li>
</ul>
<h3 id="2-创建"><a href="#2-创建" class="headerlink" title="2.创建"></a>2.创建</h3><ul>
<li><code>git init</code>初始化</li>
<li><code>git clone git@git... .git</code>克隆项目(git:&#x2F;&#x2F; 协议)</li>
<li><code>git clone http://... .git</code>克隆项目(http(s):&#x2F;&#x2F;)</li>
<li><code>git clone http://邮箱（或用户名）:密码@仓库地址</code>指定邮箱或者用户名克隆项目,如果用户名或者邮箱及密码中包含了@符号，所以需要把@转码一下代替:@–&gt;%40</li>
<li><code>git clone -b  要clone的分支名  仓库地址</code>克隆指定分支的项目.</li>
</ul>
<h3 id="3-添加到暂存区及提交"><a href="#3-添加到暂存区及提交" class="headerlink" title="3.添加到暂存区及提交"></a>3.添加到暂存区及提交</h3><ul>
<li><code>git add readme.txt </code>将文件提交到暂存区</li>
<li><code>git add . </code>把工作区域内的所有变化提交到暂存区，包括文件内容修改(modified)以及新文件(new)，但不包括被删除的文件。</li>
<li><code>git add -u</code>仅监控已经被add的文件（即tracked file）将被修改的文件提交到暂存区。add -u 不会提交新文件（untracked file）。（git add –update的缩写）</li>
<li><code>git add -A</code>是上面两个的合集,提交所有变化。（git add –all的缩写）</li>
<li><code>git commit -m &quot;first&quot;</code>提交到版本库</li>
<li><code>git status</code>状态查看(查看工作目录中的状态例如:有没有没被提交的文件之类的)</li>
</ul>
<h3 id="4-删除"><a href="#4-删除" class="headerlink" title="4.删除"></a>4.删除</h3><ul>
<li><code>git rm 我的文件</code>在本地仓库删除文件</li>
<li><code>git rm -r 我的文件夹/</code>在本地仓库删除文件夹 此处-r表示递归所有子目录，如果你要删除的，是空的文件夹，此处可以不用带上-r。<blockquote>
<p>删除的文件可以通过 git reset head file 和git checkout file恢复.</p>
</blockquote>
</li>
</ul>
<h3 id="5-branch-分支"><a href="#5-branch-分支" class="headerlink" title="5.branch(分支)"></a>5.branch(分支)</h3><ul>
<li><code>git branch [branch-name]</code>新建一个分支，但依然停留在当前分支</li>
<li><code>git checkout -b [branch-name]</code>新建一个分支，并切换到该分支</li>
<li><code>git branch</code>    列出所有的分支(所有本地分支)</li>
<li><code>git branch -r</code> 列出所有的分支(所有远程分支)</li>
<li><code>git branch -a</code> 列出所有的分支(所有本地和远程分支)</li>
<li><code>git checkout [branchname]</code>切换到指定分支，并更新工作区</li>
<li><code>git branch -d [branchname]</code>删除本地分支</li>
<li><code>git push origin --delete [branchName]</code>删除远程分支</li>
<li><code>git branch -m [oldname] [newName]</code>分支重命名</li>
<li><code>git reflog --date=local | grep nikeglass</code>查看当前分支的父分支</li>
<li><code>git merge [branchname]</code>  将branchname分支上的修改合并到当前分支上</li>
<li><code>git rebase [branchname]</code> 对当前分支基于branchname进行变基操作</li>
</ul>
<h3 id="6-远程分支"><a href="#6-远程分支" class="headerlink" title="6.远程分支."></a>6.远程分支.</h3><ul>
<li><p><code>git checkout -b [分支名] [远程名]/[分支名]</code> 在本地建立分支并和远程分支同步</p>
</li>
<li><p><code>git remote add origin [远程git地址]本地项目关联远程仓库(origin 是默认的远程版本库名称,添加多个不同的远端需要不同的标识)</code></p>
</li>
<li><p><code>git remote</code>列出所有关联的远端仓库.</p>
</li>
<li><p><code>git remote update origin --prune</code>更新远程分支列表</p>
</li>
<li><p><code>git remote -v</code>列出所有关联的远端仓库(详细信息).</p>
</li>
<li><p><code>git remote rm origin:origin(远程关联仓库的别称)</code>删除关联的远程仓库。</p>
</li>
<li><p><code>fetch+merge</code> 拉取远程仓库与本地仓库进行合并(git fetch 相当于是从远程获取最新到本地，不会自动merge)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git fetch origin master //将远程仓库的master分支下载到本地当前branch中</span><br><span class="line">git log -p master...origin/master //比较本地的master分支和origin/master分支的差别</span><br><span class="line">git merge origin/master //进行合并</span><br></pre></td></tr></table></figure></li>
<li><p><code>git pull origin master</code>相当于是从远程获取最新版本并merge到本地。</p>
</li>
<li><p><code>git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;</code>推送到远程仓库.如果当前分支只有一个追踪分支，那么主机名和后面都都可以省略:<code>git push</code>。<br>如果当前分支与多个主机存在追踪关系，那么这个时候-u选项会指定一个默认主机，这样后面就可以不加任何参数使用git push:<code>git push -u origin(远程主机名) master:master(本地分支名:远程分支名)</code>。</p>
</li>
<li><p><code>git pull origin master --allow-unrelated-histories</code>分支进行强行合并</p>
</li>
</ul>
<blockquote>
<p>git fetch和git pull 区别: fetch 和 pull 的不同: fetch 相当于是从远程获取最新版本到本地，不会自动merge，所以本地仓库的代码还未被更新，<br>然后比较本地分支和远程分支的差别,最后通过 git merge origin&#x2F;master 来合并这两个版本，可以把它理解为合并分支一样的。 <br>pull 相当于是从远程获取最新版本并merge到本地(相当于git fetch 和 git merge)。如果想要更加可控一点的话推荐使用fetch + merge,因为<br>git fetch更安全一些,在merge前，我们可以查看更新情况，然后再决定是否合并</p>
</blockquote>
<h3 id="7-标签"><a href="#7-标签" class="headerlink" title="7.标签"></a>7.标签</h3><ul>
<li><code>git tag</code> 列出所有tag</li>
<li><code>git show [tag]</code>查看tag信息</li>
<li><code>git tag [tagname]</code>打轻量标签</li>
<li><code>git tag -a [tagname] -m [message]</code>打标签并附注标签(例如，打v1.0标签<code>git tag -a v1.0 -m &#39;v1.0 release&#39;</code>)</li>
<li><code>git tag -a [tagname] [commit_id]</code>对过去的提交打标签</li>
<li><code>git tag -d [tagname]</code>删除本地tag</li>
<li><code>git push origin --delete tag &lt;tagname&gt;</code>删除远程tag</li>
<li><code>git push [remote] [tag]</code>提交指定tag(例如，将v1.0标签推送到远程服务器上<code>git push origin v1.0</code>)</li>
<li><code> git push [remote] --tags</code>提交所有tag</li>
<li><code>git checkout [tagname]</code>切换到对应标签状态(这时候 git 可能会提示你当前处于一个“detached HEAD” 状态。 因为 tag 相当于是一个快照，是不能更改它的代码的。如果要在 tag 代码的基础上做修改，你需要一个分支：<code>git checkout -b [branchname] [tagname]</code>)</li>
</ul>
<h3 id="8-日志"><a href="#8-日志" class="headerlink" title="8.日志"></a>8.日志</h3><ul>
<li><code>git log</code>每一次操作记录</li>
<li><code>git reflog</code>可以查看所有分支的所有操作记录（包括（包括commit和reset的操作），包括已经被删除的commit记录，git log则不能察看已经删除了的commit记录，而且跟进结果可以回退到某一个修改。</li>
<li><code>git log --oneline --graph</code> 查看历史中什么时候出现了分支、合并</li>
<li><code>git diff</code>比较工作区和暂存区的所有文件差异变化</li>
<li><code>git diff &lt;file name&gt;</code>比较工作区和暂存区的指定文件的差异</li>
<li><code>git diff --stat</code>比较工作区和暂存区的所有文件变化列表</li>
<li><code>git shortlog -n-</code> 按每位作者的提交次数排序分组输出。</li>
<li><code>git show commit_id</code>查看某个提交的详细</li>
</ul>
<h3 id="8-撤销修改版本回溯"><a href="#8-撤销修改版本回溯" class="headerlink" title="8.撤销修改版本回溯"></a>8.撤销修改版本回溯</h3><ul>
<li><p><code>git checkout -- file</code>丢弃工作区内文件的修改(例如:git checkout – readme.md)</p>
</li>
<li><p><code>git checkout .  </code>放弃对工作区内所有的文件修改</p>
<blockquote>
<p>命令<code>git checkout -- readme.txt</code>意思就是，把<code>readme.txt</code>文件在工作区的修改全部撤销，这里有两种情况：一种是<code>readme.txt</code>自修改后还没有被add到暂存区，现在，撤销修改就回到和之前版本库一模一样的状态；<br>一种是<code>readme.txt</code>已经添加add到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。总之，就是让这个文件回到最近一次<code>git commit</code>或<code>git add</code>时的状态。</p>
</blockquote>
</li>
<li><p><code>git reset HEAD &lt;file&gt;</code>撤销已经add到暂存区的文件.</p>
</li>
<li><p><code>git reset HEAD .</code>撤销所有的已经add到暂存区的文件.</p>
<blockquote>
<p>如果文件已经被add到暂存区,再使用git checkout是没有用的.此时应该使用git reset HEAD将文件撤销添加到暂存区的操作,然后再使用git checkout操作让文件恢复到最近一次commit.</p>
</blockquote>
</li>
<li><p><code>git reset --hard HEAD^</code>        回退到上个版本</p>
</li>
<li><p><code>git reset --hard commit_id</code>    退到&#x2F;进到 指定commit_id</p>
</li>
</ul>
<h4 id="撤销修改分为三种情况"><a href="#撤销修改分为三种情况" class="headerlink" title="撤销修改分为三种情况"></a>撤销修改分为三种情况</h4><p><strong>情况一:未使用 git add 缓存代码时:</strong><br>放弃单个文件修改<code>git checkout -- filepathname</code>,注意不要忘记中间的”–”,不写就成了检出分支了! 放弃所有的文件修改<code>git checkout .  </code></p>
<p><strong>情况二:已经使用了  git add 缓存了代码:</strong><br>可以使用 <code>git reset HEAD filepathname</code> （比如： <code>git reset HEAD readme.md</code>）来放弃指定文件的缓存，放弃所有的缓存可以使用 <code>git reset HEAD .</code>**&#96;&#96; 命令。此命令用来清除 git对于文件修改的缓存。相当于撤销 git add 命令所在的工作。</p>
<p><strong>情况三:已经用 git commit  提交了代码:</strong><br>可以使用 <code>git reset --hard HEAD^ </code>来回退到上一次commit的状态。此命令可以用来回退到任意版本：<code>git reset --hard  commitid </code></p>
<h1 id="三-Git忽略"><a href="#三-Git忽略" class="headerlink" title="三.Git忽略"></a>三.Git忽略</h1><h3 id="1-使用-gitignore文件"><a href="#1-使用-gitignore文件" class="headerlink" title="1.使用.gitignore文件"></a>1.使用.gitignore文件</h3><p>在git中如果想忽略掉某个文件，不让这个文件提交到版本库中，可以使用修改根目录中 .gitignore 文件的方法（如无，则需自己手工建立此文件）。</p>
<h5 id="创建-gitignore"><a href="#创建-gitignore" class="headerlink" title="创建.gitignore"></a>创建.gitignore</h5><p><code>touch .gitignore</code>打开 Git Bash-&gt;导航到 Git 仓库的位置-&gt;为仓库创建.gitignore文件</p>
<h5 id="gitignore匹配规则"><a href="#gitignore匹配规则" class="headerlink" title=".gitignore匹配规则"></a>.gitignore匹配规则</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 此为注释 – 将被 Git 忽略</span><br><span class="line">*.a   # 忽略所有 .a 结尾的文件</span><br><span class="line">!lib.a# 但 lib.a 除外</span><br><span class="line">/TODO # 仅仅忽略项目根目录下的 TODO 文件，不包括 subdir/TODO</span><br><span class="line">build/# 忽略 build/ 目录下的所有文件</span><br><span class="line">doc/*.txt # 会忽略 doc/notes.txt 但不包括 doc/server/arch.txt </span><br></pre></td></tr></table></figure>

<h5 id="gitignore不生效问题"><a href="#gitignore不生效问题" class="headerlink" title=".gitignore不生效问题"></a>.gitignore不生效问题</h5><p>把某些目录或文件加入忽略规则，按照上述方法定义后发现并未生效，原因是**.gitignore只能忽略那些原来没有被追踪的文件**，如果某些文件已经被纳入了版本管理中，仅修改.gitignore是无效的。<br>所以如果需要忽略的文件已经提交到本地仓库，则需要从本地仓库中删除掉该文件，如果已经提交到远端仓库，则需要从远端仓库中删除该文件，.gitignore文件才能实际生效。<br>解决方法就是先把本地缓存删除（改变成未被追踪状态），然后再提交(push)，这样就不会出现忽略的文件了。<code>git</code>清除本地缓存命令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git rm -r --cached .              去掉已经托管的所有文件</span><br><span class="line">git add .                         添加文件 </span><br><span class="line">git commit -m &#x27;本地提交的comment&#x27;   提交</span><br></pre></td></tr></table></figure>

<h3 id="2-忽略本地修改"><a href="#2-忽略本地修改" class="headerlink" title="2.忽略本地修改"></a>2.忽略本地修改</h3><ul>
<li>本地开发中需要用的文件，不能提交到远程，但是还不能写入.gitignore文件。</li>
<li>远程仓库里已存在的文件,在本地进行修改了.但是不想提交到远程仓库里面去(例如一些编辑器的配置文件,不同版本的编辑器配置文件可能不同.但是初始化仓库时没有做好.gitignore的配置导致配置文件被添加到版本库里面了<br>此时,要么在.gitignore里面添加忽略规则再把缓存修改)。</li>
</ul>
<p><code>git update-index --assume-unchanged /XX/XX/XXX.file</code> 本地忽略单个文件</p>
<p><code>git ls-files -z | xargs -0 git update-index --assume-unchanged</code>进入文件夹中(忽略文件夹中所有的文件)</p>
<p><code>git ls-files -v | grep &#39;^h\ &#39;</code>找出所有被忽略的文件</p>
<p><code>git ls-files -v | grep &#39;^h\ &#39; | awk &#39;&#123;print $2&#125;&#39;</code>找出所有被忽略的文件路径</p>
<p><code>git update-index –no-assume-unchanged –path /XX/XX/XXX.file</code> 取消单个忽略文件</p>
<p><code>git ls-files -v | grep &#39;^h&#39; | awk &#39;&#123;print $2&#125;&#39; |xargs git update-index --no-assume-unchanged</code>取消所有被忽略的文件</p>
<blockquote>
<p>注意: 这种方式也有一个副作用，如果本地被忽略的该文件在本地被修改了，远程的该文件也被其他人修改了。那在拉取远程分支时，由于本地和远程文件存在不一致的更新，会导致拉取不成功的问题。此时应该先取消文件忽略，再进行拉取操作。</p>
</blockquote>
<h1 id="四-Git分支合并"><a href="#四-Git分支合并" class="headerlink" title="四.Git分支合并"></a>四.Git分支合并</h1><h3 id="merge两种模式"><a href="#merge两种模式" class="headerlink" title="merge两种模式"></a>merge两种模式</h3><p>merge一般有两种模式:</p>
<ul>
<li><p>Fast forward模式<br>通常，合并分支时，如果没有分歧解决，就会直接移动文件指针，这就是Fast forward模式，也是merge默认的模式。</p>
<blockquote>
<p>举例来说，开发一直在master分支进行，但忽然有一个新的想法，于是新建了一个dev的分支，并在其上进行一系列提交，完成时，回到master分支，<br>此时，master分支在创建dev分支之后并未产生任何新的commit。master分支合并dev分支并不会产生新的commit. 以后当合并分支被删除时，也就不知道对应的提交是来自于哪个分支。<br>此时的合并就叫fast forward。如果想在这样的的情况下也自动生成一个commit，记录此次合并就可以用：git merge –no-ff模式。</p>
</blockquote>
</li>
<li><p>–no-ff模式<br><code>git merge --no-ff -m &quot;merge with no-ff&quot; dev</code>因为本次合并要创建一个新的commit，所以加上-m参数，把commit描述写入。<br><img src="/images/ae00297981cd55708f131ccb73a8df56.webp"></p>
</li>
</ul>
<p>总结：fast forward能够保证不会强制覆盖别人的代码，确保了多人协同开发。尽量不要使用non fast forward方法提交代码。</p>
<h3 id="merge冲突问题"><a href="#merge冲突问题" class="headerlink" title="merge冲突问题"></a>merge冲突问题</h3><p>git冲突的场景:</p>
<ul>
<li>情景一：多个分支代码合并到一个分支时；</li>
<li>情景二：多个分支向同一个远端分支推送代码时；<br>实际上，push操作即是将本地代码merge到远端库分支上。push和pull其实就分别是用本地分支合并到远程分支 和 将远程分支合并到本地分支 所以这两个过程中也可能存在冲突。</li>
</ul>
<p>git的合并中产生冲突的具体情况：</p>
<ol>
<li>两个分支中修改了同一个文件（不管什么地方）</li>
<li>两个分支中修改了同一个文件的名称<br>两个分支中分别修改了不同文件中的部分，不会产生冲突，可以直接将两部分合并。</li>
</ol>
<h3 id="merge解决冲突"><a href="#merge解决冲突" class="headerlink" title="merge解决冲突"></a>merge解决冲突</h3><ol>
<li>先本地直接提交代码：git push origin master</li>
<li>如果别人在自己之前提交了修改，git会提示push失败，需要先pull远程代码：git pull origin&#x2F;master</li>
<li>（拉取远程仓库进行自动合并） 如果能自动合并，git会提示auto merge成功，这时可以直接git push origin master如果不能自动merge，git会提示auto merge失败，</li>
<li>需要手动解决冲突：git status  查看冲突情况修改冲突git status  查看冲突解决情况git add .git commit -m ‘解决冲突的注释说明’git push origin master</li>
</ol>
<h3 id="避免产生冲突"><a href="#避免产生冲突" class="headerlink" title="避免产生冲突"></a>避免产生冲突</h3><p>现代软件开发项目中，代码冲突是不可避免的，但我们应该尽量减少冲突的产生，避免不必要的冲突。下面列举一下实践经验：</p>
<ol>
<li>工作在不同的分支上，并经常性的同步主代码，如果由于项目要求，比如长期开发一个功能使得该功能代码在开发完成之前合并到主分支，此时我们虽然没有办法经常合并代码到主分支，也至少需要经常性的同步主分支代码到开发分支上<br>，避免在最终合并到主分支上时产生过多冲突。</li>
<li>尽量使用短生命周期分支而非长期分支。</li>
<li>除了技术层面的手段，也可以通过项目管理上的手段来尽量避免，例如：不要同时将相同组件开发的不同任务分给不同的开发者，否则在合并代码时该组件将会产生过多的冲突。<br>各组件开发小组之间经常性的沟通，互相了解各自的开发状态，在可能产生冲突的时候及时采取手段。</li>
</ol>
<h3 id="merge和rebase-变基"><a href="#merge和rebase-变基" class="headerlink" title="merge和rebase(变基)"></a>merge和rebase(变基)</h3><p>merge 会把公共分支和你当前的commit 合并在一起，形成一个新的 commit 提交:<br><img src="/images/5fd18eb90e17cebe03a2d2cda15f759a.webp"></p>
<p>rebase会把你当前分支的 commit 放到公共分支的最后面,所以叫变基。就好像你从公共分支又重新拉出来这个分支一样。<br>举例:如果你从 master 拉了个feature分支出来,然后你提交了几个 commit,这个时候刚好有人把他开发的东西合并到 master 了,<br>这个时候 master 就比你拉分支的时候多了几个 commit,如果这个时候你 rebase master 的话，就会把你当前的几个 commit，放到那个人 commit 的后面。此时切换到master分支再用merge进行合并即可.</p>
<p><strong>优点</strong></p>
<ul>
<li>rebase最大的好处是你的项目历史会非常整洁</li>
<li>rebase 导致最后的项目历史呈现出完美的线性——你可以从项目终点到起点浏览而不需要任何的 fork。这让你更容易使用 git log、git bisect 和 gitk 来查看项目历史<br><strong>缺点</strong></li>
<li>安全性，如果你违反了 rebase 黄金法则，重写项目历史可能会给你的协作工作流带来灾难性的影响</li>
<li>可跟踪性，rebase 不会有合并提交中附带的信息——你看不到 feature 分支中并入了上游的哪些更改<br><img src="/images/5dbacaeed9971409e0e1cf89bbdea58c.webp"></li>
</ul>
<ol>
<li>可以看出merge结果能够体现出时间线，但是rebase会打乱时间线。</li>
<li>而rebase看起来简洁，但是merge看起来不太简洁。</li>
<li>最终结果是都把代码合起来了，所以具体怎么使用这两个命令看项目需要。</li>
</ol>
<p>注意:</p>
<ol>
<li>不要在公共分支使用rebase</li>
<li>本地和远端对应同一条分支,优先使用rebase,而不是merge</li>
</ol>
<h1 id="五-Git暂存与恢复"><a href="#五-Git暂存与恢复" class="headerlink" title="五.Git暂存与恢复"></a>五.Git暂存与恢复</h1><h3 id="git-stash命令作用"><a href="#git-stash命令作用" class="headerlink" title="git stash命令作用"></a>git stash命令作用</h3><ol>
<li>当正在dev分支上开发某个项目，这时项目中出现一个bug，需要紧急修复，但是正在开发的内容只是完成一半，还不想提交，这时可以用git stash命令将修改的内容保存至堆栈区，<br>然后顺利切换到hotfix分支进行bug修复，修复完成后，再次切回到dev分支，从堆栈中恢复刚刚保存的内容。</li>
<li>由于疏忽，本应该在dev分支开发的内容，却在master上进行了开发，需要重新切回到dev分支上进行开发，可以用git stash将内容保存至堆栈中，切回到dev分支后，再次恢复内容即可。</li>
</ol>
<blockquote>
<p>git stash命令的作用就是将目前还不想提交的但是已经修改的内容进行保存至堆栈中，后续可以在某个分支上恢复出堆栈中的内容。这也就是说，stash中的内容不仅仅可以恢复到原先开发的分支，也可以恢复到其他任意指定的分支上。<br>git stash作用的范围包括工作区和暂存区中的内容，也就是说没有提交的内容都会保存至堆栈中。</p>
</blockquote>
<ul>
<li><code>git stash</code>能够将所有未提交的修改（工作区和暂存区）保存至堆栈中，用于后续恢复当前工作目录。</li>
<li><code>git stash save &quot;notes&quot;</code>作用等同于git stash，区别是可以加一些注释</li>
<li><code>git stash list </code>查看当前stash中的内容</li>
<li><code>git stash pop id</code>将当前stash中的内容弹出，并应用到当前分支对应的工作目录上,id是可选项，默认时上一次暂存,通过git stash list可查看具体值。只能恢复一次.</li>
<li><code>git stash apply id</code>将堆栈中的内容应用到当前目录，不同于git stash pop，该命令不会将内容从堆栈中删除，可以恢复多次.也就说该命令能够将堆栈的内容多次应用到工作目录中，适应于多个分支的情况。</li>
<li><code>git stash drop stash id</code> 删除某个保存，id是可选项，通过git stash list可查看具体值</li>
<li><code>git stash clear</code> 删除所有保存的快照</li>
</ul>
<h1 id="六-Git去除大文件"><a href="#六-Git去除大文件" class="headerlink" title="六.Git去除大文件"></a>六.Git去除大文件</h1><ol>
<li>首先找出git中前五大的文件： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git verify-pack -v .git/objects/pack/pack-*.idx | sort -k 3 -g | tail -5</span><br></pre></td></tr></table></figure>
或者:<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rev-list --objects --all | grep &quot;$(git verify-pack -v .git/objects/pack/*.idx | sort -k 3 -n | tail -5 | awk &#x27;&#123;print$1&#125;&#x27;)&quot;</span><br></pre></td></tr></table></figure>
或者:<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rev-list --all | xargs -rL1 git ls-tree -r --long | sort -uk3 | sort -rnk4 | head -10</span><br></pre></td></tr></table></figure></li>
<li>用第一步文件的id找出文件名： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rev-list --objects --all | grep fileId </span><br></pre></td></tr></table></figure></li>
<li>删除文件提交记录 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git filter-branch --index-filter &#x27;git rm --cached --ignore-unmatch &lt;your-file-name&gt;&#x27;</span><br><span class="line">rm -rf .git/refs/original/</span><br><span class="line">git reflog expire --expire=now --all</span><br><span class="line">git fsck --full --unreachable</span><br><span class="line">git repack -A -d</span><br><span class="line">git gc --aggressive --prune=now</span><br><span class="line">git push --force </span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="七-Git-Flow-版本管理工作流"><a href="#七-Git-Flow-版本管理工作流" class="headerlink" title="七. Git Flow(版本管理工作流)"></a>七. Git Flow(版本管理工作流)</h1><p>Git 作为一个源码管理系统，不可避免涉及到多人协作。为了避免协作过程中产生混乱，必须有一个规范的工作流程，让大家有效地合作，使得项目井井有条地发展下去。<br>Gitflow是基于Git的强大分支能力所构建的一套<em><strong>软件开发工作流</strong></em>，这些流程应被视作为指导方针，而非“铁律”。Gitflow使用<code>多个分支来记录项目开发的历史，而不是使用单一的master分支</code>。<br><img src="/images/401d6d180524cc88c189d8e565b7021d.webp"></p>
<h2 id="1-主要分支"><a href="#1-主要分支" class="headerlink" title="1. 主要分支"></a>1. 主要分支</h2><p>主要分支包括<code>Master</code>和<code>Develop(Dev)</code>，前者用于正式发布，后者用于日常开发。常设分支只需要这两条就够了，不需要其他的了。</p>
<p><strong>Master分支（主）:</strong><br>Git主分支的名字，默认叫做Master。该分支上的代码随时可以部署到生产环境， 这个分支只能从其他分支合并，并且不能在这个分支做任何直接修改。<br>每次版本封版后由主程序员合并<code>release</code>分支代码进来，发布完成以后打上tag，开发人员不可以随意操作。</p>
<p><strong>develop分支（开发）：</strong><br>用来开发的分支，通常可以直接在其上进行开发，在每次发布版本<code>（release）</code>和线上紧急<code>bug（hotfix）修复后</code>，需要同步到其上。理论上此版本只在开发阶段使用，提测时不可以直接修改，<br>而在测试结束后由<code>release</code>分支合并到其上。如果想正式对外发布，就在Master分支上，对Develop分支进行”合并”（merge）。</p>
<h2 id="2-临时性分支"><a href="#2-临时性分支" class="headerlink" title="2. 临时性分支"></a>2. 临时性分支</h2><p>除了常设分支以外，还有一些临时性分支，用于应对一些特定目的的版本开发。临时性分支主要有三种：<code>功能分支 （feature），预发布分支 (release)，修补bug分支 (fixbug)</code>，这三种分支都属于临时性需要，<br>使用完以后，应该删除，使得代码库的常设分支始终只有Master和Develop。</p>
<p><strong>release分支（预发布）：</strong><br>在发布正式版本之前（即develop合并到Master分支之前），我们可能需要有一个预发布的版本进行测试。预发布分支是从Develop分支上面分出来的，所有测试阶段的bug全部在此分支修复，测试结束后，必须合并进Develop和Master分支。<br>它的命名，可以采用release-xx的形式。</p>
<p><strong>feature分支（功能）：</strong><br>为了开发某种特定功能，从Develop分支上面分出来的。开发完成后，要再并入Develop。功能分支的名字，可以采用feature-XX的形式命名。如果在团队开发时，有一个功能的开发周期要长过本次版本开发周期，<br>建议开启一个 <code>feature</code> 进行单独开发，当需要此功能的时候，只需要将 <code>feature</code> 合并入 <code>develop</code> 分支，下次一并提测即可。<br>这样设计可以避免这个功能在尚未开发完成或者通过测试的时候混入发布的版本，而导致不可预知的不稳定。当然也可以同时开启多个 <code>feature</code> 分支进行不同新功能开发，在合适的时候合并提测即可。</p>
<p><strong>hotfix分支（bug修复）：</strong><br>软件正式发布以后，难免会出现bug。这时就需要创建一个分支，进行bug修补。修补bug分支是从Master分支上面分出来的。修补结束以后，再合并进Master和Develop分支。它的命名，可以采用fixbug-XX的形式。<br>线上bug修复的热补丁分支，应由 <code>master</code> 拉出，并在修复完成后合并入 <code>master</code> 和 <code>develop</code> 保证两分支的bug已修复。</p>
<h3 id="3-新功能开发中，各角色的工作流程"><a href="#3-新功能开发中，各角色的工作流程" class="headerlink" title="3. 新功能开发中，各角色的工作流程"></a>3. 新功能开发中，各角色的工作流程</h3><h5 id="1-前置阶段-新功能启动"><a href="#1-前置阶段-新功能启动" class="headerlink" title="(1.)前置阶段(新功能启动)"></a>(1.)前置阶段(新功能启动)</h5><ul>
<li>开发主管-&gt;基于<strong>master</strong>主干创建一个<strong>develop</strong>分支。</li>
</ul>
<p><strong>现有主干分支: master、develop</strong></p>
<h5 id="2-开发阶段-开始开发"><a href="#2-开发阶段-开始开发" class="headerlink" title="(2.)开发阶段(开始开发)"></a>(2.)开发阶段(开始开发)</h5><ul>
<li>功能开发人员-&gt;基于<strong>develop</strong>分支创建一个<strong>feature_XX</strong>分支。</li>
<li>功能开发人员-&gt;在<strong>feature_XX</strong>分支上开发新功能。</li>
<li>功能开发人员-&gt;新功能开发完成以后，在git上发起<strong>Pull request</strong>把代码合并到到<strong>develop</strong>分支上。</li>
<li>开发主管-&gt;确认代码没问题，通过该合并请求。</li>
</ul>
<p><strong>现有主干分支: master、develop、feature_XX</strong></p>
<h5 id="3-测试阶段-开发完毕"><a href="#3-测试阶段-开发完毕" class="headerlink" title="(3.)测试阶段(开发完毕)"></a>(3.)测试阶段(开发完毕)</h5><ul>
<li>开发主管-&gt;基于<strong>develop</strong>分支创建一个分支名为<strong>release-1.0.0</strong>的预发布版本。</li>
<li>测试人员-&gt;对<strong>release-1.0.0</strong>分支的代码进行测试，测试通过在git发起<strong>Pull request</strong>把<strong>release-1.0.0</strong>代码合并到到<strong>master</strong>分支上。</li>
</ul>
<p><strong>现有主干分支: master、develop、feature_XX、release-1.0.0</strong></p>
<h5 id="4-发布阶段-测试通过"><a href="#4-发布阶段-测试通过" class="headerlink" title="(4.)发布阶段(测试通过)"></a>(4.)发布阶段(测试通过)</h5><ul>
<li>开发主管-&gt;基于<strong>master</strong>分支创建一个里程碑版本(tag)名为<strong>1.0.0-Release</strong>。</li>
<li>删除完成使命的其他分支:<strong>feature_login</strong>、<strong>release-1.0.0</strong>。</li>
</ul>
<p><strong>现有主干分支: master、develop、1.0.0-Release(tag)</strong></p>
<h3 id="4-线上代码出现bug时，各角色的工作流程"><a href="#4-线上代码出现bug时，各角色的工作流程" class="headerlink" title="4.线上代码出现bug时，各角色的工作流程"></a>4.线上代码出现bug时，各角色的工作流程</h3><h5 id="1-前置阶段-提交bug"><a href="#1-前置阶段-提交bug" class="headerlink" title="(1.)前置阶段(提交bug)"></a>(1.)前置阶段(提交bug)</h5><ul>
<li>测试人员-&gt;发现问题，基于<strong>1.0.0-Release</strong>里程碑版本在git上新建一个issue。</li>
</ul>
<p><strong>现有主干分支: master、develop、1.0.0-Release(tag)</strong></p>
<h5 id="2-修复阶段-开始修复bug"><a href="#2-修复阶段-开始修复bug" class="headerlink" title="(2.)修复阶段(开始修复bug)"></a>(2.)修复阶段(开始修复bug)</h5><ul>
<li>功能开发人员-&gt;基于<strong>1.0.0-Release</strong>tag创建一个<strong>hotfix_XX</strong>(该issue序号)分支，开发人员在<strong>hotfix_XX</strong>分支上修复bug，修复完成后，在git上发起<strong>Pull request</strong>把代码合并到到<strong>master</strong>主干上。</li>
<li>开发主管-&gt;确认代码没问题，通过该合并请求。</li>
</ul>
<p><strong>现有主干分支: master、develop、1.0.0-Release(tag)、hotfix_0001</strong></p>
<h5 id="3-测试阶段-bug修复完毕"><a href="#3-测试阶段-bug修复完毕" class="headerlink" title="(3.)测试阶段(bug修复完毕)"></a>(3.)测试阶段(bug修复完毕)</h5><ul>
<li>测试人员-&gt;对<strong>master</strong>分支的代码进行测试。</li>
</ul>
<p><strong>现有主干分支: master、develop、1.0.0-Release(tag)、hotfix_0001</strong></p>
<h5 id="4-发布阶段-测试通过-1"><a href="#4-发布阶段-测试通过-1" class="headerlink" title="(4.)发布阶段(测试通过)"></a>(4.)发布阶段(测试通过)</h5><p>开发主管-&gt;基于<strong>master</strong>分支创建一个里程碑修复版本(tag)名为<strong>1.0.1-Release，</strong>删除完成使命的其他分支:<strong>hotfix_XX</strong>。</p>
<p><strong>现有主干分支: master、develop、1.0.0-Release(tag)、1.0.1-Release(tag)</strong></p>
<h1 id="八-常见问题"><a href="#八-常见问题" class="headerlink" title="八.常见问题."></a>八.常见问题.</h1><ol>
<li>第一次输入错误的gitlab用户名和密码，第二次clone不弹框提示输入用户名和密码的解决方案。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone remote: HTTP Basic: Access denied</span><br></pre></td></tr></table></figure>
<img src="/images/c965c4b3eb916df6443519b9e0c48b19.webp"></li>
</ol>
<h3 id="方式一-在控制面板里面将凭证删除"><a href="#方式一-在控制面板里面将凭证删除" class="headerlink" title="方式一:在控制面板里面将凭证删除."></a><strong>方式一:在控制面板里面将凭证删除.</strong></h3><p><img src="/images/cea03591b71baa3b9c26ae2eb30bb0b9.webp"></p>
<p><img src="/images/02df0dc3c6cf7e8cfaba30d394e89785.webp"></p>
<p><strong>方式二:使用git命令重置凭证.</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --system --unset credential.helper</span><br><span class="line">git config --global credential.helper store</span><br></pre></td></tr></table></figure>


<h1 id="Git子模块"><a href="#Git子模块" class="headerlink" title="Git子模块"></a>Git子模块</h1><p>1.1使用场景<br>某个工作中的项目需要包含并使用另一个项目。 也许是第三方库，或者你独立开发的，用于多个父项目的库。想要把它们当做两个独立的项目，同时又想在一个项目中使用另一个。</p>
<p>1.2 基本关系<br>首先明确，父项目和子项目没有实际关系，他们就是各自完全独立的两个git仓库而已。只是父项目中需要用到子项目。所以父项目和子项目的管理是分开进行的，即他们的代码拉取和提交都要分别进行。</p>
<p>默认情况下，父模块会将子项目放到一个与子仓库同名的目录中，可以在父项目中查看和修改子项目文件。每次更新子项目代码，子项目就会产生一个新的版本号。父项目中会记录所用子项目的版本号，如果子项目更新了版本号，而父项目不重新获取新版本的子项目，父项目就还是使用的旧版本的子项目代码。</p>
<h3 id="子模块的添加"><a href="#子模块的添加" class="headerlink" title="子模块的添加"></a>子模块的添加</h3><p>添加子模块非常简单，命令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git submodule add &lt;url&gt; &lt;path&gt;</span><br></pre></td></tr></table></figure>
<p>其中，url为子模块的路径，path为该子模块存储的目录路径。</p>
<p>执行成功后，git status会看到项目中修改了.gitmodules，并增加了一个新文件（为刚刚添加的路径）</p>
<p>git diff –cached查看修改内容可以看到增加了子模块，并且新文件下为子模块的提交hash摘要</p>
<p>git commit提交即完成子模块的添加</p>
<h3 id="子模块的使用"><a href="#子模块的使用" class="headerlink" title="子模块的使用"></a>子模块的使用</h3><p>克隆项目后，默认子模块目录下无任何内容。需要在项目根目录执行如下命令完成子模块的下载：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git submodule init</span><br><span class="line">git submodule update</span><br></pre></td></tr></table></figure>
<p>或：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git submodule update --init --recursive</span><br></pre></td></tr></table></figure>


<p>执行后，子模块目录下就有了源码，再执行相应的makefile即可。</p>
<h3 id="在父项目中修改并提交子项目代码"><a href="#在父项目中修改并提交子项目代码" class="headerlink" title="在父项目中修改并提交子项目代码"></a>在父项目中修改并提交子项目代码</h3><p>子项目中有三种状态，一是以版本编号命名的游离态，二是主分支master，三是自己创建的分支。一般是在自己的分支进行修改。</p>
<p>&#x2F;&#x2F;先cd到子项目的目录下，然后右键git bash here，执行以下语句：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git checkout &lt;分支名&gt;</span><br><span class="line">git add .</span><br><span class="line">git commit -m &quot;说明信息&quot;</span><br><span class="line">git push origin &lt;远程分支名&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可以看到，其操作流程是和普通项目的提交一样的。</p>
<h3 id="子模块的更新"><a href="#子模块的更新" class="headerlink" title="子模块的更新"></a>子模块的更新</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone &lt;repository&gt; --recursive 递归的方式克隆整个项目</span><br></pre></td></tr></table></figure>


<p>子模块的维护者提交了更新后，使用子模块的项目必须手动更新才能包含最新的提交。<br>在项目中，进入到子模块目录下，执行 git pull更新，查看git log查看相应提交。<br>完成后返回到项目目录，可以看到子模块有待提交的更新，使用git add，提交即可。</p>
<p>在父项目中执行以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git submodule update --init  //初始化版本</span><br><span class="line">git submodule update --remote  //更新到最新版本</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="删除子模块"><a href="#删除子模块" class="headerlink" title="删除子模块"></a>删除子模块</h3><p>有时子模块的项目维护地址发生了变化，或者需要替换子模块，就需要删除原有的子模块。</p>
<p>删除子模块较复杂，步骤如下：</p>
<p>rm -rf 子模块目录 删除子模块目录及源码<br>vi .gitmodules 删除项目目录下.gitmodules文件中子模块相关条目<br>vi .git&#x2F;config 删除配置项中子模块相关条目<br>rm .git&#x2F;module&#x2F;* 删除模块下的子模块目录，每个子模块对应一个目录，注意只删除对应的子模块目录即可<br>执行完成后，再执行添加子模块命令即可，如果仍然报错，执行如下：</p>
<p>git rm –cached 子模块名称</p>
<p>完成删除后，提交到仓库即可。</p>
<h3 id="在父项目中提交子项目版本"><a href="#在父项目中提交子项目版本" class="headerlink" title="在父项目中提交子项目版本"></a>在父项目中提交子项目版本</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git submodule update --init</span><br><span class="line">git submodule update --remote</span><br><span class="line">git add 子项目所在文件夹</span><br><span class="line">git commit -m &quot;说明信息&quot;</span><br><span class="line">git push</span><br></pre></td></tr></table></figure>
<p>这部分操作是为了提交父项目中子项目的版本号</p>
<h3 id="Git本地修改子模块URL"><a href="#Git本地修改子模块URL" class="headerlink" title="Git本地修改子模块URL"></a>Git本地修改子模块URL</h3><p>初始化模块<br>如果已经初始化过了，也不要慌。可以使用 git submodule deinit [moduleName] 来取消对某一个模块的初始化，或者使用 git submodule deinit –all 取消对所有模块的初始化</p>
<p><code>git submodule init</code><br>修改模块的 URL<br>修改名为 hello 子模块的 url 为 ssh:&#x2F;&#x2F;<a href="mailto:&#98;&#x61;&#105;&#x64;&#117;&#64;&#98;&#97;&#105;&#x64;&#117;&#46;&#99;&#111;&#109;">&#98;&#x61;&#105;&#x64;&#117;&#64;&#98;&#97;&#105;&#x64;&#117;&#46;&#99;&#111;&#109;</a>: git config submodule.hello.url ssh:&#x2F;&#x2F;<a href="mailto:&#98;&#x61;&#x69;&#100;&#x75;&#x40;&#x62;&#97;&#105;&#x64;&#x75;&#46;&#x63;&#x6f;&#109;">&#98;&#x61;&#x69;&#100;&#x75;&#x40;&#x62;&#97;&#105;&#x64;&#x75;&#46;&#x63;&#x6f;&#109;</a><br>当然在初始化子模块以后，也可以通过直接修改 .git&#x2F;config 文件来修改 url，但是 并不推荐<br><code>git config submodule.[moduleName].url ssh://user@server/path</code><br>更新模块<br><code>git submodule update --recursive --remote</code></p>
<h3 id="修改submodule的url"><a href="#修改submodule的url" class="headerlink" title="修改submodule的url"></a>修改submodule的url</h3><p>1.clone项目<br>2.将.gitmodules文件中的地址换成新的地址<br>3.删除原先的submodule文件夹<br>4. 执行<code>git submodule init </code>和<code>git submodule update --remote</code></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://lxlfpeng.github.io">peng</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://lxlfpeng.github.io/2015/10/31/Git%E5%91%BD%E4%BB%A4%E5%8F%8AGIt%20Flow%E5%B7%A5%E4%BD%9C%E6%B5%81/">https://lxlfpeng.github.io/2015/10/31/Git%E5%91%BD%E4%BB%A4%E5%8F%8AGIt%20Flow%E5%B7%A5%E4%BD%9C%E6%B5%81/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://lxlfpeng.github.io" target="_blank">鹏哥的Blog</a>！</span></div></div><div class="tag_share"><div class="post-share"><div class="social-share" data-image="/images/about_avatar.webp" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2016/06/09/Android%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B9%8BDalvik%E5%92%8CART/" title="Android虚拟机之Dalvik和ART"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Android虚拟机之Dalvik和ART</div></div><div class="info-2"><div class="info-item-1">一.Java平台的虚拟机Jvm1.Jvm的作用Java语言的一个非常重要的特点就是与平台的无关性(跨平台性)，经常会听到一句关于java特性的话：”一次编译到处执行”。由于机器只能识别机器码，所以需要通过Java 编译器将 .java 文件转换成 .class文件，也就是字节码文件，最后将字节码提供给 JVM，由 JVM 将它转换成机器码。 2.Jvm分析Jvm相关知识体系过于庞大，有兴趣可以看本人之前的文章:JAVA JVM详解 二.Dalvik虚拟机1.为什么Android平台不使用标准的Jvm虚拟机?由于 Androd 运行在移动设备上，内存以及电量等诸多方面跟一般的 PC 设备都有本质的区别 ，一般的 JVM 没法满足移动设备的要求，所以Android 团队一开始就打造了一个符合移动设备的可以执行 Java 代码的虚拟机，这就是说的 Dalvik 虚拟机 。 2....</div></div></div></a><a class="pagination-related" href="/2015/03/25/%E7%BC%96%E7%A8%8B%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/" title="编程算法基础总结"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">编程算法基础总结</div></div><div class="info-2"><div class="info-item-1">一.算法的优劣判断算法 (Algorithm)，是对特定问题求解步骤的一种描述。解决一个问题往往有不止一种方法，算法也是如此。那么解决特定问题的多个算法之间如何衡量它们的优劣呢？好的程序设计无外乎两点，”快”和”省”。”快”指程序执行速度快，高效，”省”指占用更小的内存空间。这两点其实就对应**”时间复杂度”和“空间复杂度”**。通过这两点就能衡量多个算法之间的优劣。 1.时间复杂度一个算法执行所花费的时间，需上机运行测试才能知道。但我们不可能对每个算法都上机测试，所以只需知道哪个算法花费的时间多，哪个算法花费的时间少就可以了。因为一个算法花费的时间与算法中的基本操作语句的执行次数成正比例，所以哪个算法中语句执行次数多，它花费时间就多。**一个算法中的语句执行次数称为语句频度，记为T(n)。n称为问题的规模，当n不断变化时，时间频度T(n)也会不断变化。为了知道变化时呈现什么规律，所以引入时间复杂度**。一般情况下，算法中的基本操作语句的重复执行次数是问题规模n的某个函数，用T(n)表示，若有某个辅助函数f(n)，使得当n趋近于无穷大时，T(n) &#x2F; f(n)...</div></div></div></a></nav><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="giscus-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/images/about_avatar.webp" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">peng</div><div class="author-info-description">过往不恋 未来不迎 当下不负</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">127</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">59</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">24</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/lxlfpeng"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/lxlfpeng" target="_blank" title="Github"><i class="fab fa-github" style="color: #4a7dbe;"></i></a><a class="social-icon" href="mailto:565289282@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎来到我的博客!</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80-Git%E7%AE%80%E4%BB%8B"><span class="toc-number">1.</span> <span class="toc-text">一.Git简介</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C-Git%E6%96%87%E4%BB%B6%E7%8A%B6%E6%80%81"><span class="toc-number">2.</span> <span class="toc-text">二.Git文件状态</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89-Git%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4"><span class="toc-number">3.</span> <span class="toc-text">三.Git常见命令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E8%AE%BE%E7%BD%AE%E7%9B%B8%E5%85%B3"><span class="toc-number">3.0.1.</span> <span class="toc-text">1.设置相关</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%88%9B%E5%BB%BA"><span class="toc-number">3.0.2.</span> <span class="toc-text">2.创建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%B7%BB%E5%8A%A0%E5%88%B0%E6%9A%82%E5%AD%98%E5%8C%BA%E5%8F%8A%E6%8F%90%E4%BA%A4"><span class="toc-number">3.0.3.</span> <span class="toc-text">3.添加到暂存区及提交</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%88%A0%E9%99%A4"><span class="toc-number">3.0.4.</span> <span class="toc-text">4.删除</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-branch-%E5%88%86%E6%94%AF"><span class="toc-number">3.0.5.</span> <span class="toc-text">5.branch(分支)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E8%BF%9C%E7%A8%8B%E5%88%86%E6%94%AF"><span class="toc-number">3.0.6.</span> <span class="toc-text">6.远程分支.</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E6%A0%87%E7%AD%BE"><span class="toc-number">3.0.7.</span> <span class="toc-text">7.标签</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E6%97%A5%E5%BF%97"><span class="toc-number">3.0.8.</span> <span class="toc-text">8.日志</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E6%92%A4%E9%94%80%E4%BF%AE%E6%94%B9%E7%89%88%E6%9C%AC%E5%9B%9E%E6%BA%AF"><span class="toc-number">3.0.9.</span> <span class="toc-text">8.撤销修改版本回溯</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%92%A4%E9%94%80%E4%BF%AE%E6%94%B9%E5%88%86%E4%B8%BA%E4%B8%89%E7%A7%8D%E6%83%85%E5%86%B5"><span class="toc-number">3.0.9.1.</span> <span class="toc-text">撤销修改分为三种情况</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89-Git%E5%BF%BD%E7%95%A5"><span class="toc-number">4.</span> <span class="toc-text">三.Git忽略</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BD%BF%E7%94%A8-gitignore%E6%96%87%E4%BB%B6"><span class="toc-number">4.0.1.</span> <span class="toc-text">1.使用.gitignore文件</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA-gitignore"><span class="toc-number">4.0.1.0.1.</span> <span class="toc-text">创建.gitignore</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#gitignore%E5%8C%B9%E9%85%8D%E8%A7%84%E5%88%99"><span class="toc-number">4.0.1.0.2.</span> <span class="toc-text">.gitignore匹配规则</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#gitignore%E4%B8%8D%E7%94%9F%E6%95%88%E9%97%AE%E9%A2%98"><span class="toc-number">4.0.1.0.3.</span> <span class="toc-text">.gitignore不生效问题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%BF%BD%E7%95%A5%E6%9C%AC%E5%9C%B0%E4%BF%AE%E6%94%B9"><span class="toc-number">4.0.2.</span> <span class="toc-text">2.忽略本地修改</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9B-Git%E5%88%86%E6%94%AF%E5%90%88%E5%B9%B6"><span class="toc-number">5.</span> <span class="toc-text">四.Git分支合并</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#merge%E4%B8%A4%E7%A7%8D%E6%A8%A1%E5%BC%8F"><span class="toc-number">5.0.1.</span> <span class="toc-text">merge两种模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#merge%E5%86%B2%E7%AA%81%E9%97%AE%E9%A2%98"><span class="toc-number">5.0.2.</span> <span class="toc-text">merge冲突问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#merge%E8%A7%A3%E5%86%B3%E5%86%B2%E7%AA%81"><span class="toc-number">5.0.3.</span> <span class="toc-text">merge解决冲突</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%81%BF%E5%85%8D%E4%BA%A7%E7%94%9F%E5%86%B2%E7%AA%81"><span class="toc-number">5.0.4.</span> <span class="toc-text">避免产生冲突</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#merge%E5%92%8Crebase-%E5%8F%98%E5%9F%BA"><span class="toc-number">5.0.5.</span> <span class="toc-text">merge和rebase(变基)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%94-Git%E6%9A%82%E5%AD%98%E4%B8%8E%E6%81%A2%E5%A4%8D"><span class="toc-number">6.</span> <span class="toc-text">五.Git暂存与恢复</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#git-stash%E5%91%BD%E4%BB%A4%E4%BD%9C%E7%94%A8"><span class="toc-number">6.0.1.</span> <span class="toc-text">git stash命令作用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AD-Git%E5%8E%BB%E9%99%A4%E5%A4%A7%E6%96%87%E4%BB%B6"><span class="toc-number">7.</span> <span class="toc-text">六.Git去除大文件</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%83-Git-Flow-%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86%E5%B7%A5%E4%BD%9C%E6%B5%81"><span class="toc-number">8.</span> <span class="toc-text">七. Git Flow(版本管理工作流)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E4%B8%BB%E8%A6%81%E5%88%86%E6%94%AF"><span class="toc-number">8.1.</span> <span class="toc-text">1. 主要分支</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E4%B8%B4%E6%97%B6%E6%80%A7%E5%88%86%E6%94%AF"><span class="toc-number">8.2.</span> <span class="toc-text">2. 临时性分支</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%96%B0%E5%8A%9F%E8%83%BD%E5%BC%80%E5%8F%91%E4%B8%AD%EF%BC%8C%E5%90%84%E8%A7%92%E8%89%B2%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="toc-number">8.2.1.</span> <span class="toc-text">3. 新功能开发中，各角色的工作流程</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%89%8D%E7%BD%AE%E9%98%B6%E6%AE%B5-%E6%96%B0%E5%8A%9F%E8%83%BD%E5%90%AF%E5%8A%A8"><span class="toc-number">8.2.1.0.1.</span> <span class="toc-text">(1.)前置阶段(新功能启动)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%BC%80%E5%8F%91%E9%98%B6%E6%AE%B5-%E5%BC%80%E5%A7%8B%E5%BC%80%E5%8F%91"><span class="toc-number">8.2.1.0.2.</span> <span class="toc-text">(2.)开发阶段(开始开发)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E6%B5%8B%E8%AF%95%E9%98%B6%E6%AE%B5-%E5%BC%80%E5%8F%91%E5%AE%8C%E6%AF%95"><span class="toc-number">8.2.1.0.3.</span> <span class="toc-text">(3.)测试阶段(开发完毕)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E5%8F%91%E5%B8%83%E9%98%B6%E6%AE%B5-%E6%B5%8B%E8%AF%95%E9%80%9A%E8%BF%87"><span class="toc-number">8.2.1.0.4.</span> <span class="toc-text">(4.)发布阶段(测试通过)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E7%BA%BF%E4%B8%8A%E4%BB%A3%E7%A0%81%E5%87%BA%E7%8E%B0bug%E6%97%B6%EF%BC%8C%E5%90%84%E8%A7%92%E8%89%B2%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="toc-number">8.2.2.</span> <span class="toc-text">4.线上代码出现bug时，各角色的工作流程</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%89%8D%E7%BD%AE%E9%98%B6%E6%AE%B5-%E6%8F%90%E4%BA%A4bug"><span class="toc-number">8.2.2.0.1.</span> <span class="toc-text">(1.)前置阶段(提交bug)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E4%BF%AE%E5%A4%8D%E9%98%B6%E6%AE%B5-%E5%BC%80%E5%A7%8B%E4%BF%AE%E5%A4%8Dbug"><span class="toc-number">8.2.2.0.2.</span> <span class="toc-text">(2.)修复阶段(开始修复bug)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E6%B5%8B%E8%AF%95%E9%98%B6%E6%AE%B5-bug%E4%BF%AE%E5%A4%8D%E5%AE%8C%E6%AF%95"><span class="toc-number">8.2.2.0.3.</span> <span class="toc-text">(3.)测试阶段(bug修复完毕)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E5%8F%91%E5%B8%83%E9%98%B6%E6%AE%B5-%E6%B5%8B%E8%AF%95%E9%80%9A%E8%BF%87-1"><span class="toc-number">8.2.2.0.4.</span> <span class="toc-text">(4.)发布阶段(测试通过)</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AB-%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98"><span class="toc-number">9.</span> <span class="toc-text">八.常见问题.</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E5%BC%8F%E4%B8%80-%E5%9C%A8%E6%8E%A7%E5%88%B6%E9%9D%A2%E6%9D%BF%E9%87%8C%E9%9D%A2%E5%B0%86%E5%87%AD%E8%AF%81%E5%88%A0%E9%99%A4"><span class="toc-number">9.0.1.</span> <span class="toc-text">方式一:在控制面板里面将凭证删除.</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Git%E5%AD%90%E6%A8%A1%E5%9D%97"><span class="toc-number">10.</span> <span class="toc-text">Git子模块</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%90%E6%A8%A1%E5%9D%97%E7%9A%84%E6%B7%BB%E5%8A%A0"><span class="toc-number">10.0.1.</span> <span class="toc-text">子模块的添加</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%90%E6%A8%A1%E5%9D%97%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">10.0.2.</span> <span class="toc-text">子模块的使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8%E7%88%B6%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%BF%AE%E6%94%B9%E5%B9%B6%E6%8F%90%E4%BA%A4%E5%AD%90%E9%A1%B9%E7%9B%AE%E4%BB%A3%E7%A0%81"><span class="toc-number">10.0.3.</span> <span class="toc-text">在父项目中修改并提交子项目代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%90%E6%A8%A1%E5%9D%97%E7%9A%84%E6%9B%B4%E6%96%B0"><span class="toc-number">10.0.4.</span> <span class="toc-text">子模块的更新</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E5%AD%90%E6%A8%A1%E5%9D%97"><span class="toc-number">10.0.5.</span> <span class="toc-text">删除子模块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8%E7%88%B6%E9%A1%B9%E7%9B%AE%E4%B8%AD%E6%8F%90%E4%BA%A4%E5%AD%90%E9%A1%B9%E7%9B%AE%E7%89%88%E6%9C%AC"><span class="toc-number">10.0.6.</span> <span class="toc-text">在父项目中提交子项目版本</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Git%E6%9C%AC%E5%9C%B0%E4%BF%AE%E6%94%B9%E5%AD%90%E6%A8%A1%E5%9D%97URL"><span class="toc-number">10.0.7.</span> <span class="toc-text">Git本地修改子模块URL</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9submodule%E7%9A%84url"><span class="toc-number">10.0.8.</span> <span class="toc-text">修改submodule的url</span></a></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer" style="background: linear-gradient(20deg, #0062be, #925696, #cc426e, #fb0347);"><div id="footer-wrap"><div class="copyright">&copy;2015 - 2025 By peng</div><div class="footer_custom_text"> <a target="_blank" rel="nofollow noopener"><span>千里之行</span></a> <i class="iconfont icon-love"></i> <a target="_blank" rel="nofollow noopener"><span>始于足下</span></a> </div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.isShuoshuo
  const option = null

  const getGiscusTheme = theme => theme === 'dark' ? 'dark' : 'light'

  const createScriptElement = config => {
    const ele = document.createElement('script')
    Object.entries(config).forEach(([key, value]) => {
      ele.setAttribute(key, value)
    })
    return ele
  }

  const loadGiscus = (el = document, key) => {
    const mappingConfig = isShuoshuo
      ? { 'data-mapping': 'specific', 'data-term': key }
      : { 'data-mapping': (option && option['data-mapping']) || 'pathname' }

    const giscusConfig = {
      src: 'https://giscus.app/client.js',
      'data-repo': 'lxlfpeng/blog_comments',
      'data-repo-id': 'R_kgDONYoexA',
      'data-category-id': 'DIC_kwDONYoexM4Ck4JQ',
      'data-theme': getGiscusTheme(document.documentElement.getAttribute('data-theme')),
      'data-reactions-enabled': '1',
      crossorigin: 'anonymous',
      async: true,
      ...option,
      ...mappingConfig
    }

    const scriptElement = createScriptElement(giscusConfig)

    el.querySelector('#giscus-wrap').appendChild(scriptElement)

    if (isShuoshuo) {
      window.shuoshuoComment.destroyGiscus = () => {
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }
  }

  const changeGiscusTheme = theme => {
    const iframe = document.querySelector('#giscus-wrap iframe')
    if (iframe) {
      const message = {
        giscus: {
          setConfig: {
            theme: getGiscusTheme(theme)
          }
        }
      }
      iframe.contentWindow.postMessage(message, 'https://giscus.app')
    }
  }

  btf.addGlobalFn('themeChange', changeGiscusTheme, 'giscus')

  if (isShuoshuo) {
    'Giscus' === 'Giscus'
      ? window.shuoshuoComment = { loadComment: loadGiscus }
      : window.loadOtherComment = loadGiscus
    return
  }

  if ('Giscus' === 'Giscus' || !false) {
    if (false) btf.loadComment(document.getElementById('giscus-wrap'), loadGiscus)
    else loadGiscus()
  } else {
    window.loadOtherComment = loadGiscus
  }
})()</script></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="false"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>