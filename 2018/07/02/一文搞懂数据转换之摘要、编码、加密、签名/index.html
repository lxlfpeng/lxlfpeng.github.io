<!DOCTYPE html><html lang="zh-CN" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>一文搞懂数据转换之摘要、编码、加密、签名 | 鹏哥的Blog</title><meta name="author" content="peng"><meta name="copyright" content="peng"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#0d0d0d"><meta name="description" content="一.转义转义的作用?转义通常有两种功能。第一种是如果不进行转义就可能与语法规定的某些内容产生混淆，所以这些内容都被设计为需要转义。 第二种也叫字符引用，用于表示无法在当前上下文中被键盘录入的字符（如字符串中的回车符）。 第一种作用以经典的JAVA语言中字符串中的字符转义为例。如果在一个字符串中存在一个”符号，那么就需要在”符号前添加\才能够正常的表示，比如下面这样: 1String content">
<meta property="og:type" content="article">
<meta property="og:title" content="一文搞懂数据转换之摘要、编码、加密、签名">
<meta property="og:url" content="https://lxlfpeng.github.io/2018/07/02/%E4%B8%80%E6%96%87%E6%90%9E%E6%87%82%E6%95%B0%E6%8D%AE%E8%BD%AC%E6%8D%A2%E4%B9%8B%E6%91%98%E8%A6%81%E3%80%81%E7%BC%96%E7%A0%81%E3%80%81%E5%8A%A0%E5%AF%86%E3%80%81%E7%AD%BE%E5%90%8D/index.html">
<meta property="og:site_name" content="鹏哥的Blog">
<meta property="og:description" content="一.转义转义的作用?转义通常有两种功能。第一种是如果不进行转义就可能与语法规定的某些内容产生混淆，所以这些内容都被设计为需要转义。 第二种也叫字符引用，用于表示无法在当前上下文中被键盘录入的字符（如字符串中的回车符）。 第一种作用以经典的JAVA语言中字符串中的字符转义为例。如果在一个字符串中存在一个”符号，那么就需要在”符号前添加\才能够正常的表示，比如下面这样: 1String content">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://lxlfpeng.github.io/images/about_avatar.webp">
<meta property="article:published_time" content="2018-07-01T16:00:00.000Z">
<meta property="article:modified_time" content="2025-04-12T15:02:01.855Z">
<meta property="article:author" content="peng">
<meta property="article:tag" content="加密解密">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://lxlfpeng.github.io/images/about_avatar.webp"><link rel="shortcut icon" href="/images/favicon.webp"><link rel="canonical" href="https://lxlfpeng.github.io/2018/07/02/%E4%B8%80%E6%96%87%E6%90%9E%E6%87%82%E6%95%B0%E6%8D%AE%E8%BD%AC%E6%8D%A2%E4%B9%8B%E6%91%98%E8%A6%81%E3%80%81%E7%BC%96%E7%A0%81%E3%80%81%E5%8A%A0%E5%AF%86%E3%80%81%E7%AD%BE%E5%90%8D/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '一文搞懂数据转换之摘要、编码、加密、签名',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  isShuoshuo: false
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/images/about_avatar.webp" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">127</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">59</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">24</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/categories"><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background: linear-gradient(20deg, #0062be, #925696, #cc426e, #fb0347);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src="/images/nav_logo.webp" alt="Logo"><span class="site-name">鹏哥的Blog</span></a><a class="nav-page-title" href="/"><span class="site-name">一文搞懂数据转换之摘要、编码、加密、签名</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/categories"><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">一文搞懂数据转换之摘要、编码、加密、签名</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2018-07-01T16:00:00.000Z" title="发表于 2018-07-02 00:00:00">2018-07-02</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/">编程基础</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">7.2k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>21分钟</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="一-转义"><a href="#一-转义" class="headerlink" title="一.转义"></a>一.转义</h1><h3 id="转义的作用"><a href="#转义的作用" class="headerlink" title="转义的作用?"></a>转义的作用?</h3><p>转义通常有两种功能。第一种是如果不进行转义就可能与语法规定的某些内容产生混淆，所以这些内容都被设计为需要转义。 第二种也叫字符引用，用于表示无法在当前上下文中被键盘录入的字符（如字符串中的回车符）。</p>
<h5 id="第一种作用"><a href="#第一种作用" class="headerlink" title="第一种作用"></a>第一种作用</h5><p>以经典的JAVA语言中字符串中的字符转义为例。如果在一个字符串中存在一个”符号，那么就需要在”符号前添加\才能够正常的表示，比如下面这样:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String content=&quot;他说\&quot;他需要休息\&quot;&quot;;</span><br></pre></td></tr></table></figure>
<p>之所以需要这样，是因为对于字符串来说，”本身就是表示一个字符串的起止符号。如果不进行转义，那么编译器将无法正确的识别其中的”哪些是分隔符，哪些是字符串内部的”。</p>
<h5 id="第二种作用"><a href="#第二种作用" class="headerlink" title="第二种作用"></a>第二种作用</h5><p>回车符和换行符，再正常情况下，这样的字符是不可见的，对于这种字符，不过不采用转义的形式进行表达那么会比较困难。如果在一个字符串中存在回车符，那么就需要用\r表示。如果在一个字符串中存在换行符，那么就需要用\n表示。比如下面这样:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String content=&quot;床前明月光，/r/n疑是地上霜&quot;;</span><br></pre></td></tr></table></figure>
<h1 id="二-编码解码"><a href="#二-编码解码" class="headerlink" title="二.编码解码"></a>二.编码解码</h1><h3 id="1-什么是编码解码"><a href="#1-什么是编码解码" class="headerlink" title="1. 什么是编码解码?"></a>1. 什么是编码解码?</h3><p>编码本质上采用一种新的载体来表示前一个载体所表达的信息。解码，是编码的逆过程。从概念上可以看出，编码本质上是信息形式的转化，没有保密的作用，因为编码和解码的算法是公开的，只要知道是什么编码的内容，任何人都可以轻松地解码。编码的目的不是为了加密信息，而是将信息转化成统一的格式，方便在不同系统之中传输。</p>
<p>信息-&gt;编码-&gt;二进制-&gt;解码-&gt;信息</p>
<h3 id="2-常见的编码方式"><a href="#2-常见的编码方式" class="headerlink" title="2. 常见的编码方式"></a>2. 常见的编码方式</h3><h5 id="文本文件编码"><a href="#文本文件编码" class="headerlink" title="文本文件编码"></a>文本文件编码</h5><p>将“文本数据”编码为“二进制数据”，以实现通过“二进制数据”进行存储或者传输的目的。文本文件在计算机中，最终的载体只能是二进制文件的形式存在。由于计算机诞生在美国，文本内容也只包含有英文内容。因此当时只要使用ASCII进行编码就可以了。但是后来随着计算机的普及，需要表达的信息越来越多了。因此诞生了UTF-8, UTF-16,UTF-32, Unicode, ISO8859-1, GBK, GB2312等等编码形式。在计算机领域，数据存储单位叫字节——byte，最小的存储单元的容量是1位-1bit。一个bit有两个状态 0 和 1。1byte &#x3D; 8bit。通常，一个英文字母占1字节，汉字采用GBK编码时，占用2字节。UTF-8是可变长度编码，一般用 0-4 字节表示。</p>
<blockquote>
<p>但不论如何，这些编码其实都是对文本信息的编码形式。</p>
</blockquote>
<h5 id="Base64编码"><a href="#Base64编码" class="headerlink" title="Base64编码"></a>Base64编码</h5><p>将“二进制数据”编码为“64个可打印字符的组合”，以实现通过“可打印字符的形式”进行存储或者传输的目的。公钥证书也好，电子邮件数据也好，经常要用到Base64编码，那么为什么要作一下这样的编码呢？因为在计算机中任何数据都是按ascii码存储的，而ascii码的128～255之间的值是不可见字符。 而在网络上交换数据时，比如说从A地传到B地，往往要经过多个路由设备， 由于不同的设备对字符的处理方式有一些不同，这样那些不可见字符就有可能被处理错误，这是不利于传输的。 所以就先把数据先做一个Base64编码，统统变成可见字符，这样出错的可能性就大降低了。<br>使用场景：</p>
<ul>
<li>在Web场景中，在有些地方限制了数据传输的方式。例如，在URL，只能传递文本。因此，如果想要传输一组二进制数据（例如图片）。那么可以选用Base64编码，将二进制数据编码为可打印的字符串。这样才能完成URL上二进制数据的传输。</li>
<li>对证书来说，特别是根证书，一般都是作Base64编码的，因为它要在网上被许多人下载。</li>
<li>电子邮件的附件一般也作Base64编码的，因为一个附件数据往往是有不可见字符的。 比如http协议当中的key value字段的值，必须进行URLEncode ， 因为一些特殊符号（等号或者空格）是有特殊含义的，造成混淆，解析失败，那么需要把这些值统一处理为可见字符，传输完再解析回来。</li>
</ul>
<h5 id="URL编码"><a href="#URL编码" class="headerlink" title="URL编码"></a>URL编码</h5><p> Url编码的原则就是使用安全的字符（没有特殊用途或者特殊意义的可打印字符）去表示那些不安全的字符从而达到适合传输的目的。由于url只能使用英文字母、数字和某些标点符号，不能使用其他文字和符号，如果需要在URL中传递中文作为参数，或者需要在URL中传递空格、&amp;、?、&#x3D;等等特殊符号。这个时候就需要进行URL编码。编码的目的HTTP协议的内在要求，通过这种形式，可以浏览器表单数据的打包。</p>
<h5 id="3-乱码"><a href="#3-乱码" class="headerlink" title="3. 乱码"></a>3. 乱码</h5><p>一般，如果解码之后无法正确还原原来所表达的信息，此时就出现了乱码。例如，使用GB2312的方式去解码一个UTF8编码的文件，那么就会出现乱码。总的来说，乱码通常来说只是因为选用的解码方式和编码方式不同，而导致信息失真的情况。选用正确的编码就能够解读出正确的信息。</p>
<blockquote>
<p>在编码或解码时，重点放在所有具有相同算法的人身上，并且该算法通常具有良好的文档记录、广泛的分布和相当容易实现的特点。任何人最终都能解码编码数据。</p>
</blockquote>
<h1 id="三-摘要-哈希"><a href="#三-摘要-哈希" class="headerlink" title="三.摘要(哈希)"></a>三.摘要(哈希)</h1><h4 id="1-什么是摘要"><a href="#1-什么是摘要" class="headerlink" title="1.什么是摘要"></a>1.什么是摘要</h4><p>摘要的目的是为了校验信息的完整性，保证信息在传输过程中不被篡改。例如我们下载该压缩包后可以查看压缩包的MD5值。对比下载的压缩包MD5值和网站提供的MD5值，如果两个MD5值不一致，那么说明该压缩包不是官方提供的那个压缩包，可能被替换成其他文件或被修改过。摘要只是用于验证数据完整性和唯一性的哈希值，不管原始数据是什么样的，得到的哈希值都是固定长度的。不管原始数据是什么样的，得到的哈希值都是固定长度的，也就是说摘要并不是原始数据加密后的密文，只是一个验证身份的令牌。所以我们无法通过摘要解密得到原始数据。</p>
<h4 id="2-哈希算法"><a href="#2-哈希算法" class="headerlink" title="2. 哈希算法"></a>2. 哈希算法</h4><p>散列函数（也叫哈希函数，哈希函数又称散列函数，杂凑函数，他是一个单向密码体制，即从明文到密文的不可逆映射，只有加密过程没有解密过程，哈希函数可以将任意长度的输入经过变化后得到固定长度的输出，这个固定长度的输出称为原消息的散列或消息映射。 理想的哈希函数可以针对不同的输入得到不同的输出，如果存在两个不同的消息得到了相同的哈希值，那我们称这是一个哈希碰撞），如果使用的是hash算法，在计算过程中原文的部分信息是丢失了的，所以不可逆。<br><code>hash算法的目的</code>：同样的一段数据通过hash函数总是得到相同的摘要，不同的数据通过md5总是应该得到不同的摘要.hash的目的是理想化的，不管什么hash算法实际上总有特别小的概率会出现不同的原始数据通过hash函数可能会得到相同的结果，所以：越好的hash算法会将这个概率降到越低这个概率越低，黑客要通过手段碰撞出相同摘要的难度就越大.常见的算法有md5, sha系列。</p>
<h5 id="MD5"><a href="#MD5" class="headerlink" title="MD5"></a>MD5</h5><p>哈希算法，即 hash，又叫散列算法，是一类把任意数据转换为定长（或限制长度）数据的算法统称。哈希算法通常用于制作数字指纹，数字指纹的意思就是「你看到这个东西就像看到原数据一样」，例如我们在一些网站下载大文件的时候，网站提供给我们验证文件完整性的 MD5 或者 SHA1 码，就是原文件的哈希值。优秀的哈希算法通常需要具有低碰撞概率（即不同数据的哈希值通常也不一样）。<br>加密算法的目的，在于别人无法成功查看加密后的数据，并且在需要的时候还可以对数据进行解密来重新查看数据。而 MD5 算法是一种哈希算法，哈希算法的设计目标本身就决定了，它在大多数时候都是不可逆的，即你经过哈希算法得出的数据，无法再经过任何算法还原回去。所以，既然不能将数据还原，也就不能称之为可以解密；既然不能解密，那么哈希的过程自然也就不能称作是「加密」了。</p>
<p><strong>使用场景</strong></p>
<p>出于这种特性，MD5常用来校验密码是否正确、校验下载文件是否完整无损。</p>
<ul>
<li>校验密码是否正确：将用户注册的密码MD5摘要后储存起来，待用户登录时将用户录入的密码MD5摘要，对比两次摘要后的信息是否相等，相等即密码正确。（一般会进行加盐处理）</li>
<li>校验下载文件是否完整无损：我们常下载开源文件资源包时，可以看到网站上提供的该资源包的MD5，下载文件完毕后，可通过自己的程序或直接去一些网站上计算其MD5码，如果与官网上提供的一致，则表示文件完整无损。</li>
</ul>
<h5 id="SHA系列"><a href="#SHA系列" class="headerlink" title="SHA系列"></a>SHA系列</h5><p>sha系列有SHA2、SHA256、SHA512等，这些算法的复杂度相对要高。</p>
<h4 id="3-破解"><a href="#3-破解" class="headerlink" title="3. 破解"></a>3. 破解</h4><p>MD5本质上不可逆，即不存在逆算法。MD5计算的过程中丢失了信息，一个MD5的值可以对应多个原文。一个MD5理论上的确是可能对应无数多个原文的，因为MD5是有限多个的而原文可以是无数多个。比如主流使用的MD5将任意长度的“字节串映射为一个128bit的大整数。也就是一共有2^128种可能，大概是3.4*10^38，这个数字是有限多个的，而但是世界上可以被用来加密的原文则会有无数的可能性。虽然MD5本质上不可逆但是大部分简单的字符串 通过MD5加密的话 某种程度上来说是”可逆”的。原因是因为很多简单字符串MD5计算后的值，实际上是可以通过查询等方式 得到MD5前的原始串。也就是说只能碰撞，无法真正破解。因为大量信息在hash过程中损失掉了。常用的密码攻击方式 常用的密码攻击方式有字典攻击、暴力破解、查表法、反向查表法、彩虹表等。</p>
<ul>
<li>暴力破解：按照一定的顺序一个一个的去试</li>
<li>字典攻击：把常用的密码做成字典，破解时先看字典里是否存在，有效加快破解速度</li>
<li>查表法：使用一个大型字典，把每个p和对应的q都记录下来，按q做一下索引，直接查找匹配。</li>
<li>彩虹表 ：对于HASH的传统做法是把H(X)的所有输出穷举，查找，得出。而彩虹表则是使用散列链的方式进行。<blockquote>
<p>说明： “散列链”是为了降低传统做法空间要求的技术，想法是定义一个衰减函数 R 把散列值变换成另一字符串。通过交替运算H函数和R函数，形成交替的密码和散列值链条。</p>
</blockquote>
</li>
</ul>
<h4 id="4-加盐（salt）"><a href="#4-加盐（salt）" class="headerlink" title="4. 加盐（salt）"></a>4. 加盐（salt）</h4><p>123456的MD5码为e10adc3949ba59abbe56e057f20f883e。一般来说，MD5摘要的结果是128位的摘要信息，然后每4位用一个16进制字符表示，所以，MD5摘要的结果一般显示为32位的16进制。如果你的系统用MD5摘要，并且无加盐，还经常使用123456为测试密码，对这一串MD5码一定很熟悉。这一些MD5码就静静地躺在DB中待校验。如果数据库被暴露（比如拖库），坏人得到了这些MD5码，就可以通过常用密码与其MD5码的映射关系，轻而易举地翻译出大多数密码。所以，一般来说，我们需要对原始密码进行加盐，所谓加盐，就是按照一定规则扰乱原有字符串，然后再进行MD5摘要。这个规则，自己定义，并且一定保密。</p>
<blockquote>
<p>为了防止被暴力破解，可以加个密码盐，这样的话暴力破解几乎是搞不定了，即使搞定了可能也因为过去太久时间而变的没有价值。</p>
</blockquote>
<h1 id="四-加密解密"><a href="#四-加密解密" class="headerlink" title="四.加密解密"></a>四.加密解密</h1><h3 id="1-加密的概念"><a href="#1-加密的概念" class="headerlink" title="1. 加密的概念"></a>1. 加密的概念</h3><p>数据加密 的基本过程，就是对原来为 明文 的文件或数据按 某种算法 进行处理，使其成为 不可读 的一段代码，通常称为 “密文”。通过这样的途径，来达到保护数据不被非法人窃取、阅读的目的。<br>对数据进行转换以后，数据变成了另一种格式，并且除了拿到解密方法的人，没人能把数据转换回来。维护数据机密性，即确保数据不会被预期收件人以外的任何人使用。<br>例如你想给某人发送一封密信，或通过互联网给人发送密码，这些对隐秘性要求比较强的事情，就需要对信息进行加密。<br>加密的本质是按照一定的算法，将需要表达的信息进行处理，以达到除了信息的发送者和接收者之外，其他人无法识别信息真实内容的目的。<br>因此，加密通常用于网络通信。因为网络上的通信数据，任何人都有可能会拿到，把数据加密后再传送，送达以后由对方解密后再查看，就可以防止网络上的偷窥。<br>加密是可逆的，明文 + 秘钥 &#x3D; 加密信息，加密信息能通过密钥被还原为原始信息。</p>
<h3 id="2-解密"><a href="#2-解密" class="headerlink" title="2. 解密"></a>2. 解密</h3><p>加密 的 逆过程 为 解密，即将该 编码信息 转化为其 原来数据 的过程。</p>
<h3 id="3-加密的种类"><a href="#3-加密的种类" class="headerlink" title="3. 加密的种类"></a>3. 加密的种类</h3><p>加密又分为对称加密和非对称加密，区别在于在加密和解密信息时秘钥是不是同一个。若加解密使用相同密钥，则称为对称密钥加密，否则称为非对称密钥加密。</p>
<h3 id="4-对称加密"><a href="#4-对称加密" class="headerlink" title="4. 对称加密"></a>4. 对称加密</h3><p>对称加密算法 是应用较早的加密算法，又称为 共享密钥加密算法。在 对称加密算法 中，使用的密钥只有一个，发送 和 接收 双方都使用这个密钥对数据进行 加密 和 解密。这就要求加密和解密方事先都必须知道加密的密钥。<br><img src="/images/ff4a5ac97e8c4499ee57875608d0065e.webp" alt="对称加密"></p>
<p>数据加密过程：在对称加密算法中，数据发送方 将 明文 (原始数据) 和 加密密钥 一起经过特殊 加密处理，生成复杂的 加密密文 进行发送。</p>
<p>数据解密过程：数据接收方 收到密文后，若想读取原数据，则需要使用 加密使用的密钥 及相同算法的 逆算法 对加密的密文进行解密，才能使其恢复成 可读明文。</p>
<p>对称加密算法的特点是算法公开、计算量小、加密速度快、加密效率高。对称加密有很多种算法，由于它效率很高，所以被广泛使用在很多加密协议的核心当中。</p>
<p>不足之处是，交易双方都使用同样钥匙，安全性得不到保证。</p>
<p>常见的对称加密有DES，3DES，AES，Blowfish，Twofish，IDEA，RC6，CAST5 等。</p>
<h5 id="DES加密"><a href="#DES加密" class="headerlink" title="DES加密"></a>DES加密</h5><p>Data Encryption Standard，数据加密标准，速度较快，适用于加密大量数据的场合。<br>DES 加密算法出自 IBM 的研究，后来被美国政府正式采用，之后开始广泛流传。<br>但近些年使用越来越少，因为 DES 使用 56 位密钥，以现代的计算能力，24 小时内即可被破解。</p>
<h5 id="AES加密"><a href="#AES加密" class="headerlink" title="AES加密"></a>AES加密</h5><p><img src="/images/e6e46be9509e597962e1de09e61dabf0.webp" alt="AES加密"><br>AES的全称是Advanced Encryption Standard，意思是高级加密标准。它的出现主要是为了取代DES加密算法的，<br>因为我们都知道DES算法的密钥长度是56Bit，因此算法的理论安全强度是2的56次方。比较容易被破解。<br>而AES可以使用128、192、和256位密钥，并且用128位分组加密和解密数据，相对来说安全很多。<br>。完善的加密算法在理论上是无法破解的，除非使用穷尽法。使用穷尽法破解密钥长度在128位以上的加密数据是不现实的，<br>仅存在理论上的可能性。统计显示，即使使用目前世界上运算速度最快的计算机，穷尽128位密钥也要花上几十亿年的时间，<br>更不用说去破解采用256位密钥长度的AES算法了。</p>
<p>AES为分组密码，分组密码也就是把明文分成一组一组的，每组长度相等，每次加密一组数据，直到加密完整个明文。<br>在AES标准规范中，分组长度只能是128位，也就是说，每个分组为16个字节（每个字节8位）。密钥的长度可以使用128位、192位或256位。</p>
<ol>
<li>填充：<br>要想了解填充的概念，我们先要了解AES的分组加密特性。</li>
</ol>
<p>什么是分组加密呢？我们来看看下面这张图：</p>
<p><img src="/images/959dc568d19ac6ba4ef989cb4224bffc.webp" alt="分组加密"></p>
<p>AES算法在对明文加密的时候，并不是把整个明文整个加密成一整段密文，而是把明文拆分成一个个独立的明文块，每一个明文块长度128bit。<br>这些明文块经过AES加密器的复杂处理，生成一个个独立的密文块，这些密文块拼接在一起，就是最终的AES加密结果。<br>但是这里涉及到一个问题：假如一段明文长度是192bit，如果按每128bit一个明文块来拆分的话，第二个明文块只有64bit，不足128bit。这时候怎么办呢？就需要对明文块进行填充（Padding）。<br>AES在不同的语言实现中有许多不同的填充算法，我们只举出集中典型的填充来介绍一下。</p>
<ul>
<li><p>NoPadding：<br>不做任何填充，但是要求明文必须是16字节的整数倍。</p>
</li>
<li><p>PKCS5Padding（默认）：<br>如果明文块少于16个字节（128bit），在明文块末尾补足相应数量的字符，且每个字节的值等于缺少的字符数。</p>
</li>
<li><p>ISO10126Padding：<br>如果明文块少于16个字节（128bit），在明文块末尾补足相应数量的字节，最后一个字符值等于缺少的字符数，其他字符填充随机数。</p>
</li>
</ul>
<blockquote>
<p>需要注意的是，如果在AES加密的时候使用了某一种填充方式，解密的时候也必须采用同样的填充方式。</p>
</blockquote>
<ol start="2">
<li>模式:<br>AES的工作模式，体现在把明文块加密成密文块的处理过程中。AES加密算法提供了五种不同的工作模式：ECB、CBC、CTR、CFB、OFB</li>
</ol>
<p>模式之间的主题思想是近似的，在处理细节上有一些差别。我们这一期只介绍各个模式的基本定义。</p>
<ul>
<li>ECB模式（默认）：电码本模式</li>
<li>CBC模式：密码分组链接模式</li>
<li>CTR模式：计算器模式</li>
<li>CFB模式：密码反馈模式</li>
<li>OFB模式：输出反馈模式</li>
</ul>
<blockquote>
<p>同样的，如果在AES加密的时候使用了某一种工作模式，解密的时候也必须采用同样的工作模式。<br>填充明文时，如果明文长度原本就是16字节的整数倍，那么除了NoPadding以外，其他的填充方式都会填充一组额外的16字节明文块。</p>
</blockquote>
<h3 id="5-非对称加密"><a href="#5-非对称加密" class="headerlink" title="5. 非对称加密"></a>5. 非对称加密</h3><p>非对称加密算法，又称为公开密钥加密算法。它需要两个密钥，一个称为 公开密钥 (public key)，即 公钥，另一个称为 私有密钥 (private key)，即 私钥。</p>
<p>因为 加密 和 解密 使用的是两个不同的密钥，所以这种算法称为 非对称加密算法。<br><img src="/images/c2b0b9fe6fef8903af8a71073f90894b.webp" alt="非对称加密"></p>
<p>如果使用 公钥 对数据 进行加密，只有用对应的 私钥 才能 进行解密。<br>如果使用 私钥 对数据 进行加密，只有用对应的 公钥 才能 进行解密。<br>密钥是成对出现。使用一对“私钥-公钥”，用私钥加密的内容只有对应公钥才能解开<br>常见的非对称加密有 RSA、ESA、ECC 等。</p>
<h4 id="RSA加密"><a href="#RSA加密" class="headerlink" title="RSA加密"></a>RSA加密</h4><p>RSA名称来源于发明这个算法的三个人的姓氏组成，算法大致内容就是对极大整数进行因式分解。<br>这种算法非常可靠，密钥越长，它就越难破解。根据已经披露的文献，目前被破解的最长 RSA密钥是768个二进制位。<br>也就是说，长度超过768位的密钥，还无法破解（至少没人公开宣布）。因此可以认为，1024位的RSA密钥基本安全，2048位的密钥极其安全。<br>目前主流的有 RSA-1024， RSA-2048，RSA-4096等，数字代表的是密钥长度，密钥长度越长，安全性越高，但相应的性能会下降。</p>
<h5 id="RSA算法优点"><a href="#RSA算法优点" class="headerlink" title="RSA算法优点"></a>RSA算法优点</h5><ul>
<li>不需要进行密钥传递，提高了安全性</li>
<li>可以进行数字签名认证</li>
</ul>
<h5 id="RSA算法缺点"><a href="#RSA算法缺点" class="headerlink" title="RSA算法缺点"></a>RSA算法缺点</h5><ul>
<li>加密解密效率不高，一般只适用于处理小量数据（如：密钥）</li>
<li>容易遭受小指数攻击</li>
</ul>
<p>RSA算法提供了生成公钥和私钥的方法，注意是成对生成的！一般将公钥保存在客户端、私钥保存在服务端。黑客反编译可能拿到公钥，但是因为私钥存储在服务器，所以不用太担心泄密。</p>
<p>RSA加解密中必须考虑到的密钥长度、明文长度和密文长度的问题。明文长度需要小于密钥长度，而密文长度则等于密钥长度。因此当加密内容长度大于密钥长度时，有效的RSA加解密就需要对内容进行分段。<br>这是因为，RSA算法本身要求加密内容也就是明文长度m必须0&lt;m&lt;密钥长度n。如果小于这个长度就需要进行padding，因为如果没有padding，就无法确定解密后内容的真实长度，字符串之类的内容问题还不大，<br>以0作为结束符，但对二进制数据就很难，因为不确定后面的0是内容还是内容结束符。而只要用到padding，那么就要占用实际的明文长度，于是实际明文长度需要减去padding字节长度。密钥默认是1024位，<br>即1024位&#x2F;8位-11&#x3D;128-11&#x3D;117字节。所以默认加密前的明文最大长度117字节，解密密文最大长度为128字。两者相差11字节是因为RSA加密使用到了填充模式（padding），即内容不足117字节时会自动填满，<br>用到填充模式自然会占用一定的字节，而且这部分字节也是参与加密的。我们一般使用的padding标准有NoPPadding、OAEPPadding、PKCS1Padding等。</p>
<p>如果加密的数据不是分组大小的整数倍，则会根据具体的应用方式增加额外的填充位。</p>
<h5 id="RSA加密中的Padding"><a href="#RSA加密中的Padding" class="headerlink" title="RSA加密中的Padding"></a>RSA加密中的Padding</h5><p>严格地说RSA也是一种“块”加密&#x2F;解密。加密前输入长度必须与“模”相同：不足需要补足(Padding)；输入长度大于“模”长度，则需要“分组”，最后一组同样需要Padding。<br>因此模的长度也大于加密明文的长度，因此RSA不适合加密大段文本，一般用来加密一个对称加密的密钥，然后再用此对称加密密钥对大段文本加密。</p>
<ol>
<li>RSA_PKCS1_PADDING 填充模式，<br>最常用的模式，当你选择 RSA_PKCS1_PADDING 填充模式时，如果你的明文不够 128 字节， 加密的时候会在你的明文中随机填充一些数据，<br>所以会导致对同样的明文每次加密后的结果都不一样。对加密后的密文，服务器使用相同的填充方式都能解密。解密后的明文也就是之前加密的明文。</li>
</ol>
<ul>
<li><p>输入：必须 比 RSA 钥模长(modulus) 短至少11个字节, 也就是　RSA_size(rsa) – 11 如果输入的明文过长，必须切割，然后填充。</p>
</li>
<li><p>输出：和modulus一样长。</p>
</li>
</ul>
<p>根据这个要求，对于512bit的密钥，　block length &#x3D; 512&#x2F;8 – 11 &#x3D; 53 字节</p>
<ol start="2">
<li>for RSA_NO_PADDING不填充模式，<br>当在客户端选择 RSA_NO_PADDING 填充模式时，如果你的明文不够 128 字节， 加密的时候会在你的明文前面，前向的填充零。<br>解密后的明文也会包括前面填充的零，这是服务器需要注意把解密后的字段前向填充的零去掉，才是真正之前加密的明文。</li>
</ol>
<ul>
<li><p>输入：可以和RSA钥模长一样长，如果输入的明文过长，必须切割，　然后填充</p>
</li>
<li><p>输出：和modulus一样长</p>
</li>
</ul>
<ol start="3">
<li>RSA_PKCS1_OAEP_PADDING填充模式，<br>是 PKCS#1 推出的新的填充方式，安全性是最高的，和前面 RSA_PKCS1_PADDING 的区别就是加密前的编码方式不一样</li>
</ol>
<ul>
<li>输入：RSA_size(rsa) – 41</li>
<li>输出：和modulus一样长</li>
</ul>
<blockquote>
<p>不同的填充方式加解密也是不同的，使用的时候要注意</p>
</blockquote>
<h1 id="五-数字签名和验签"><a href="#五-数字签名和验签" class="headerlink" title="五.数字签名和验签"></a>五.数字签名和验签</h1><h3 id="1-数字签名的原理是？"><a href="#1-数字签名的原理是？" class="headerlink" title="1. 数字签名的原理是？"></a>1. 数字签名的原理是？</h3><p>A：数字签名技术是将明文进行特定HASH函数得到的摘要信息（消息完整性），再将摘要信息用A的私钥加密（身份认证），得到数字签名，将密文和数字签名一块发给B。</p>
<p>B：收到A的消息后，先将密文用自己的私钥解密，得到明文。将数字签名用A的公钥进行解密后，得到正确的摘要（解密成功说明A的身份被认证了）。<br>对明文进行摘要运算，得到实际收到的摘要，将两份摘要进行对比，如果一致，说明消息没有被篡改（消息完整性）。</p>
<h3 id="2-数字签名的作用是？"><a href="#2-数字签名的作用是？" class="headerlink" title="2. 数字签名的作用是？"></a>2. 数字签名的作用是？</h3><ul>
<li>一是能确定消息的不可抵赖性，因为他人假冒不了发送方的私钥签名。发送方是用自己的私钥对信息进行加密的，只有使用发送方的公钥才能解密。</li>
<li>二是数字签名能保障消息的完整性。一次数字签名采用一个特定的哈希函数，它对不同文件产生的数字摘要的值也是不相同的。</li>
</ul>
<h3 id="3-数字证书"><a href="#3-数字证书" class="headerlink" title="3. 数字证书"></a>3. 数字证书</h3><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/101225145">转义、编码和加密</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/jimmyleeee/article/details/8777794">编码与加密</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/fengyenom1/article/details/80880808">Android网络请求加密机制详解</a></p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/cd69f9b031f2">Android网络请求加密机制</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903454364696589">Android 数据加密方案</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903839640846349">编码、摘要和加密（三）——数据加密</a></p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/d07ec9ea96d7?utm_campaign=maleskine&utm_content=note&utm_medium=seo_notes&utm_source=recommendation">转载）摘要与加密的区别（以MD5算法为例）</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/michaelwubo/article/details/105627403">哈希摘要、加密、编码的区别</a></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://lxlfpeng.github.io">peng</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://lxlfpeng.github.io/2018/07/02/%E4%B8%80%E6%96%87%E6%90%9E%E6%87%82%E6%95%B0%E6%8D%AE%E8%BD%AC%E6%8D%A2%E4%B9%8B%E6%91%98%E8%A6%81%E3%80%81%E7%BC%96%E7%A0%81%E3%80%81%E5%8A%A0%E5%AF%86%E3%80%81%E7%AD%BE%E5%90%8D/">https://lxlfpeng.github.io/2018/07/02/%E4%B8%80%E6%96%87%E6%90%9E%E6%87%82%E6%95%B0%E6%8D%AE%E8%BD%AC%E6%8D%A2%E4%B9%8B%E6%91%98%E8%A6%81%E3%80%81%E7%BC%96%E7%A0%81%E3%80%81%E5%8A%A0%E5%AF%86%E3%80%81%E7%AD%BE%E5%90%8D/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://lxlfpeng.github.io" target="_blank">鹏哥的Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86/">加密解密</a></div><div class="post-share"><div class="social-share" data-image="/images/about_avatar.webp" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2018/07/02/Android%E5%A4%9C%E9%97%B4%E6%A8%A1%E5%BC%8F(%E6%8D%A2%E8%82%A4)%E6%80%BB%E7%BB%93/" title="Android夜间模式(换肤)总结"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Android夜间模式(换肤)总结</div></div><div class="info-2"><div class="info-item-1">一.Android 平台常见的换肤方案Android 平台常见的额换肤方式总结起来有如下三种： 1.设置setTheme 主题来切换 原理：通过在values文件夹下的attrs.xml和style.xml文件中配置不同的风格的主题，在Activity中的onCreate()方法中，调用setContentView()方法前调用setTheme()方法来设置主题。 优点：利用系统自带的机制实现，根据标志位setTheme()即可。 缺点：在主题切换界面不重启的情况下，不能自动完成界面主题的刷新。笨重，灵活性较低，不易于扩展。 例如：android...</div></div></div></a><a class="pagination-related" href="/2017/11/19/Java%20IO%E4%B8%8ENIO%E5%8F%8ANetty%E6%A1%86%E6%9E%B6/" title="Java IO与NIO及Netty框架"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Java IO与NIO及Netty框架</div></div><div class="info-2"><div class="info-item-1">一.I&#x2F;O模型1.什么是IOIO在计算机中指Input&#x2F;Output，也就是输入和输出。由于程序和运行时数据是在内存中进行，比如，声明变量，创建数组，创建集合。如果需要与外部设备，比如键盘，显示器，硬盘等进行数据的交互，就需要用到IO。通过数据线、网线、NFC、蓝牙之类的东西将计算机与外部设备连接起来，连接起来之后，通过特定的比特流进行沟通。一个比特（bit）就表示一个二进制数，可以是0或者1。但是因为一个bit所表示的内容太有限了，所以计算机中更常见的基本单位是字节，一个字节由8个bit组成(设备上的数据无论是图片或者视频，文字，它们都以二进制存储的)。当足够多的字节连续地从外部设备传入计算机、或者从计算机传入外部设备，这种情况就是比特流或者叫字节流(Stream)，在IO编程中，Stream（流）是一个很重要的概念，可以把流想象成一个水管，数据就像是是水管里的水。Input Stream就是数据从外面（磁盘、网络）流进内存，Output Stream就是数据从内存流到外面去。 2. Liunx IO模型分类IO...</div></div></div></a></nav><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="giscus-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/images/about_avatar.webp" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">peng</div><div class="author-info-description">过往不恋 未来不迎 当下不负</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">127</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">59</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">24</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/lxlfpeng"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/lxlfpeng" target="_blank" title="Github"><i class="fab fa-github" style="color: #4a7dbe;"></i></a><a class="social-icon" href="mailto:565289282@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎来到我的博客!</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80-%E8%BD%AC%E4%B9%89"><span class="toc-number">1.</span> <span class="toc-text">一.转义</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AC%E4%B9%89%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">1.0.1.</span> <span class="toc-text">转义的作用?</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E7%A7%8D%E4%BD%9C%E7%94%A8"><span class="toc-number">1.0.1.0.1.</span> <span class="toc-text">第一种作用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E7%A7%8D%E4%BD%9C%E7%94%A8"><span class="toc-number">1.0.1.0.2.</span> <span class="toc-text">第二种作用</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C-%E7%BC%96%E7%A0%81%E8%A7%A3%E7%A0%81"><span class="toc-number">2.</span> <span class="toc-text">二.编码解码</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AF%E7%BC%96%E7%A0%81%E8%A7%A3%E7%A0%81"><span class="toc-number">2.0.1.</span> <span class="toc-text">1. 什么是编码解码?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%B8%B8%E8%A7%81%E7%9A%84%E7%BC%96%E7%A0%81%E6%96%B9%E5%BC%8F"><span class="toc-number">2.0.2.</span> <span class="toc-text">2. 常见的编码方式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6%E7%BC%96%E7%A0%81"><span class="toc-number">2.0.2.0.1.</span> <span class="toc-text">文本文件编码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Base64%E7%BC%96%E7%A0%81"><span class="toc-number">2.0.2.0.2.</span> <span class="toc-text">Base64编码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#URL%E7%BC%96%E7%A0%81"><span class="toc-number">2.0.2.0.3.</span> <span class="toc-text">URL编码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E4%B9%B1%E7%A0%81"><span class="toc-number">2.0.2.0.4.</span> <span class="toc-text">3. 乱码</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89-%E6%91%98%E8%A6%81-%E5%93%88%E5%B8%8C"><span class="toc-number">3.</span> <span class="toc-text">三.摘要(哈希)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AF%E6%91%98%E8%A6%81"><span class="toc-number">3.0.0.1.</span> <span class="toc-text">1.什么是摘要</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95"><span class="toc-number">3.0.0.2.</span> <span class="toc-text">2. 哈希算法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#MD5"><span class="toc-number">3.0.0.2.1.</span> <span class="toc-text">MD5</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#SHA%E7%B3%BB%E5%88%97"><span class="toc-number">3.0.0.2.2.</span> <span class="toc-text">SHA系列</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E7%A0%B4%E8%A7%A3"><span class="toc-number">3.0.0.3.</span> <span class="toc-text">3. 破解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%8A%A0%E7%9B%90%EF%BC%88salt%EF%BC%89"><span class="toc-number">3.0.0.4.</span> <span class="toc-text">4. 加盐（salt）</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9B-%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86"><span class="toc-number">4.</span> <span class="toc-text">四.加密解密</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%8A%A0%E5%AF%86%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">4.0.1.</span> <span class="toc-text">1. 加密的概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E8%A7%A3%E5%AF%86"><span class="toc-number">4.0.2.</span> <span class="toc-text">2. 解密</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%8A%A0%E5%AF%86%E7%9A%84%E7%A7%8D%E7%B1%BB"><span class="toc-number">4.0.3.</span> <span class="toc-text">3. 加密的种类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86"><span class="toc-number">4.0.4.</span> <span class="toc-text">4. 对称加密</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#DES%E5%8A%A0%E5%AF%86"><span class="toc-number">4.0.4.0.1.</span> <span class="toc-text">DES加密</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#AES%E5%8A%A0%E5%AF%86"><span class="toc-number">4.0.4.0.2.</span> <span class="toc-text">AES加密</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86"><span class="toc-number">4.0.5.</span> <span class="toc-text">5. 非对称加密</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#RSA%E5%8A%A0%E5%AF%86"><span class="toc-number">4.0.5.1.</span> <span class="toc-text">RSA加密</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#RSA%E7%AE%97%E6%B3%95%E4%BC%98%E7%82%B9"><span class="toc-number">4.0.5.1.1.</span> <span class="toc-text">RSA算法优点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#RSA%E7%AE%97%E6%B3%95%E7%BC%BA%E7%82%B9"><span class="toc-number">4.0.5.1.2.</span> <span class="toc-text">RSA算法缺点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#RSA%E5%8A%A0%E5%AF%86%E4%B8%AD%E7%9A%84Padding"><span class="toc-number">4.0.5.1.3.</span> <span class="toc-text">RSA加密中的Padding</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%94-%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D%E5%92%8C%E9%AA%8C%E7%AD%BE"><span class="toc-number">5.</span> <span class="toc-text">五.数字签名和验签</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D%E7%9A%84%E5%8E%9F%E7%90%86%E6%98%AF%EF%BC%9F"><span class="toc-number">5.0.1.</span> <span class="toc-text">1. 数字签名的原理是？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%EF%BC%9F"><span class="toc-number">5.0.2.</span> <span class="toc-text">2. 数字签名的作用是？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6"><span class="toc-number">5.0.3.</span> <span class="toc-text">3. 数字证书</span></a></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer" style="background: linear-gradient(20deg, #0062be, #925696, #cc426e, #fb0347);"><div id="footer-wrap"><div class="copyright">&copy;2015 - 2025 By peng</div><div class="footer_custom_text"> <a target="_blank" rel="nofollow noopener"><span>千里之行</span></a> <i class="iconfont icon-love"></i> <a target="_blank" rel="nofollow noopener"><span>始于足下</span></a> </div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.isShuoshuo
  const option = null

  const getGiscusTheme = theme => theme === 'dark' ? 'dark' : 'light'

  const createScriptElement = config => {
    const ele = document.createElement('script')
    Object.entries(config).forEach(([key, value]) => {
      ele.setAttribute(key, value)
    })
    return ele
  }

  const loadGiscus = (el = document, key) => {
    const mappingConfig = isShuoshuo
      ? { 'data-mapping': 'specific', 'data-term': key }
      : { 'data-mapping': (option && option['data-mapping']) || 'pathname' }

    const giscusConfig = {
      src: 'https://giscus.app/client.js',
      'data-repo': 'lxlfpeng/blog_comments',
      'data-repo-id': 'R_kgDONYoexA',
      'data-category-id': 'DIC_kwDONYoexM4Ck4JQ',
      'data-theme': getGiscusTheme(document.documentElement.getAttribute('data-theme')),
      'data-reactions-enabled': '1',
      crossorigin: 'anonymous',
      async: true,
      ...option,
      ...mappingConfig
    }

    const scriptElement = createScriptElement(giscusConfig)

    el.querySelector('#giscus-wrap').appendChild(scriptElement)

    if (isShuoshuo) {
      window.shuoshuoComment.destroyGiscus = () => {
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }
  }

  const changeGiscusTheme = theme => {
    const iframe = document.querySelector('#giscus-wrap iframe')
    if (iframe) {
      const message = {
        giscus: {
          setConfig: {
            theme: getGiscusTheme(theme)
          }
        }
      }
      iframe.contentWindow.postMessage(message, 'https://giscus.app')
    }
  }

  btf.addGlobalFn('themeChange', changeGiscusTheme, 'giscus')

  if (isShuoshuo) {
    'Giscus' === 'Giscus'
      ? window.shuoshuoComment = { loadComment: loadGiscus }
      : window.loadOtherComment = loadGiscus
    return
  }

  if ('Giscus' === 'Giscus' || !false) {
    if (false) btf.loadComment(document.getElementById('giscus-wrap'), loadGiscus)
    else loadGiscus()
  } else {
    window.loadOtherComment = loadGiscus
  }
})()</script></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="false"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>