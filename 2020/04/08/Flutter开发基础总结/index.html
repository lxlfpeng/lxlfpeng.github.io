<!DOCTYPE html><html lang="zh-CN" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Flutter开发基础总结 | 鹏哥的Blog</title><meta name="author" content="peng"><meta name="copyright" content="peng"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#0d0d0d"><meta name="description" content="一.命令式UI和声明式UI1. 命令式编程和声明式编程的区别命令式编程：命令“机器”如何去做事情(how)，这样不管你想要的是什么(what)，它都会按照你的命令实现。声明式编程：告诉“机器”你想要的是什么(what)，让机器想出如何去做(how)。 2. Flutter中命令式编程的应用在Flutter中每个组件，会有个build函数，这里会返回一个能够完整描述UI的对象结构。每当数据改变时，就">
<meta property="og:type" content="article">
<meta property="og:title" content="Flutter开发基础总结">
<meta property="og:url" content="https://lxlfpeng.github.io/2020/04/08/Flutter%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/index.html">
<meta property="og:site_name" content="鹏哥的Blog">
<meta property="og:description" content="一.命令式UI和声明式UI1. 命令式编程和声明式编程的区别命令式编程：命令“机器”如何去做事情(how)，这样不管你想要的是什么(what)，它都会按照你的命令实现。声明式编程：告诉“机器”你想要的是什么(what)，让机器想出如何去做(how)。 2. Flutter中命令式编程的应用在Flutter中每个组件，会有个build函数，这里会返回一个能够完整描述UI的对象结构。每当数据改变时，就">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://lxlfpeng.github.io/images/about_avatar.webp">
<meta property="article:published_time" content="2020-04-07T16:00:00.000Z">
<meta property="article:modified_time" content="2025-04-13T15:10:38.541Z">
<meta property="article:author" content="peng">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://lxlfpeng.github.io/images/about_avatar.webp"><link rel="shortcut icon" href="/images/favicon.webp"><link rel="canonical" href="https://lxlfpeng.github.io/2020/04/08/Flutter%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Flutter开发基础总结',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  isShuoshuo: false
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/images/about_avatar.webp" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">127</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">59</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">24</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/categories"><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background: linear-gradient(20deg, #0062be, #925696, #cc426e, #fb0347);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src="/images/nav_logo.webp" alt="Logo"><span class="site-name">鹏哥的Blog</span></a><a class="nav-page-title" href="/"><span class="site-name">Flutter开发基础总结</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/categories"><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Flutter开发基础总结</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2020-04-07T16:00:00.000Z" title="发表于 2020-04-08 00:00:00">2020-04-08</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Flutter%E5%BC%80%E5%8F%91/">Flutter开发</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">9.2k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>34分钟</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="一-命令式UI和声明式UI"><a href="#一-命令式UI和声明式UI" class="headerlink" title="一.命令式UI和声明式UI"></a>一.命令式UI和声明式UI</h1><h3 id="1-命令式编程和声明式编程的区别"><a href="#1-命令式编程和声明式编程的区别" class="headerlink" title="1. 命令式编程和声明式编程的区别"></a>1. 命令式编程和声明式编程的区别</h3><p>命令式编程：命令“机器”如何去做事情(how)，这样不管你想要的是什么(what)，它都会按照你的命令实现。<br>声明式编程：告诉“机器”你想要的是什么(what)，让机器想出如何去做(how)。</p>
<h3 id="2-Flutter中命令式编程的应用"><a href="#2-Flutter中命令式编程的应用" class="headerlink" title="2. Flutter中命令式编程的应用"></a>2. Flutter中命令式编程的应用</h3><p>在Flutter中每个组件，会有个build函数，这里会返回一个能够完整描述UI的对象结构。每当数据改变时，就重新调用build函数，返回新的结构。<br>如何高效渲染，就是框架去做的事情了。通过这种方式，不管是UI的初始布局结构，还是后面的修改，都是build函数返回的对象结构去声明的，完整的声明式UI由此而来。<br>所以Flutter是构建新的widget实例，而不是改变旧的实例。</p>
<h1 id="二-Flutter中的Widget"><a href="#二-Flutter中的Widget" class="headerlink" title="二.Flutter中的Widget"></a>二.Flutter中的Widget</h1><p>Flutter 中Widget 是一切的基础,一切的显示都是 Widget,利用响应式模式进行渲染。在 Flutter 中自定义组件就是一个类，这个类需要继承 <code>StatelessWidget\StatefulWidget</code>。<br>Widget 分为 <code>有状态(StatefulWidget)</code> 和 <code>无状态(StatelessWidget)</code> 两种，在 Flutter 中每个页面都是一帧，无状态就是保持在那一帧，而有状态的 Widget 当数据更新时，其实是创建了新的 Widget，<br>只是 State 实现了跨帧的数据同步保存。</p>
<h2 id="1-无状态StatelessWidget"><a href="#1-无状态StatelessWidget" class="headerlink" title="1. 无状态StatelessWidget"></a>1. 无状态StatelessWidget</h2><h3 id="1-定义"><a href="#1-定义" class="headerlink" title="(1.)定义"></a>(1.)定义</h3><p>如果一个控件的UI页是静态的，也就是一旦这些UI页被成功渲染之后就不需要也不可能去改变他的状态，例如纯展示页面。就使用StatelessWidget。在需要实现一个StatelessWidget组件的时候，<br>声明一个class类extends继承StatelessWidget，必须要重写 build 方法，这个 build 方法会携带一个 BuildContext 参数。另外 build 方法返回一个 Widget 值，也就是我们自定义的无状态的布局。<br>这样就可以创建一个无状态的Widget。StatelessWidget 的 构造方法 和 build 方法之会创建一次，不会随着子节点StatefulWidget 控件的状态改变而重构布局。所以它适合放在布局嵌入比较深的布局节点，<br>又因为StatelessWidget是静态的，所以性能比较好，建议多使用。</p>
<blockquote>
<p>注意： 如果无状态Widget里面有子Widget，并且子Widget是有状态的，则子Widget的内容是可以通过setState来更改的。无状态Widget影响的仅仅是自己是无状态的，不会影响他的父Widget和子Widget。</p>
</blockquote>
<h3 id="2-使用"><a href="#2-使用" class="headerlink" title="(2.)使用"></a>(2.)使用</h3><p>flutter系统中提供了许多的已经定义好的StatelessWidget，例如StatelessWidget：StatelessWidget、 Icon、 IconButton、Text等。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class CircleAvatar extends StatelessWidget &#123;&#125;</span><br><span class="line">class Icon extends StatelessWidget &#123;&#125;</span><br><span class="line">class Text extends StatelessWidget &#123;&#125;</span><br><span class="line">class IconButton extends StatelessWidget &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>Widget 和 Widget 之间通过 child: 进行嵌套。其中有的 Widget 只能有一个 child；有的 Widget 可以多个 child ，也就是children，比如&#96; Column 布局。</p>
<p>StatelessWidget 是不能调用setState函数的。<br>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class HomePage extends StatelessWidget &#123;</span><br><span class="line">  int countNum = 1; </span><br><span class="line">  @override</span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    return Column(</span><br><span class="line">      children: &lt;Widget&gt;[</span><br><span class="line">        SizedBox(height: 200),</span><br><span class="line">        Text(&quot;$&#123; this.countNum &#125;&quot;),</span><br><span class="line">        SizedBox(height: 20),</span><br><span class="line">        RaisedButton(</span><br><span class="line">          child: Text(&quot;按钮&quot;),</span><br><span class="line">          onPressed: ()&#123;</span><br><span class="line">            setState()   // 错误写法 没法改变页面里面的数据</span><br><span class="line">          this.countNum++;</span><br><span class="line">              print(this.countNum);</span><br><span class="line">          &#125;</span><br><span class="line">        )</span><br><span class="line">      ]</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-有状态StatefulWidget"><a href="#2-有状态StatefulWidget" class="headerlink" title="2.有状态StatefulWidget"></a>2.有状态StatefulWidget</h2><h3 id="1-定义-1"><a href="#1-定义-1" class="headerlink" title="(1.)定义"></a>(1.)定义</h3><p>StatefulWidget是可变状态的widget。StatefulWidget依赖的数据在Widget生命周期中可能会频繁的发生变化。当使用StatefulWidget依赖的数据发生变化时调用setState函数时，<br>会通知Flutter框架某个状态发生了变化，Flutter会重新运行build方法，应用程序变可以显示最新的状态，Widget只是视图的“配置信息”，是数据的映射。</p>
<h3 id="2-使用-1"><a href="#2-使用-1" class="headerlink" title="(2.)使用"></a>(2.)使用</h3><p>flutter系统中提供了许多的已经定义好的StatefulWidget，例如Checkbox, Radio, Slider, InkWell, Form, 和 TextField 都是有状态的widget，也是StatefulWidget的子类。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class Checkbox extends StatefulWidget &#123;&#125;</span><br><span class="line">class Radio&lt;T&gt; extends StatefulWidget &#123;&#125;</span><br><span class="line">class Slider extends StatefulWidget &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>自定义 StatefullWidget :</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class HomePage extends StatefulWidget &#123;</span><br><span class="line">  HomePage(&#123;Key key&#125;) : super(key: key);</span><br><span class="line">  _HomePageState createState() =&gt; _HomePageState();</span><br><span class="line">&#125;</span><br><span class="line">class _HomePageState extends State&lt;HomePage&gt; &#123;</span><br><span class="line">  int countNum = 0;</span><br><span class="line">  @override</span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    return Column(</span><br><span class="line">      children: &lt;Widget&gt;[</span><br><span class="line">        SizedBox(height: 200),</span><br><span class="line">        Chip(</span><br><span class="line">          label:Text(&#x27;$&#123;this.countNum&#125;&#x27;) ,</span><br><span class="line">        ),</span><br><span class="line">        SizedBox(height: 20),</span><br><span class="line">        RaisedButton(</span><br><span class="line">          child: Text(&#x27;按钮&#x27;),</span><br><span class="line">          onPressed: ()&#123;</span><br><span class="line">             setState(() &#123;   // 只有有状态组件里面才有</span><br><span class="line">                  this.countNum++;</span><br><span class="line">             &#125;);</span><br><span class="line">          &#125;</span><br><span class="line">        )</span><br><span class="line">      ]</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-State概念"><a href="#3-State概念" class="headerlink" title="(3.)State概念"></a>(3.)State概念</h3><p>每一个 StatefulWidget 类都会对应一个 State 类，State 表示与其对应的 StatefulWidget 要维护的状态，保存的状态信息可以在 build 时被获取，<br>同时，在 widget 生命周期中可以被改变，改变发生时，可以调用其 setState() 方法通知 framework 发生改变，framework 会重新调用 build 方法重构 widget 树，最终完成更新 UI 的目的。<br>state 中包含两个常用属性：<code>widget</code> 和 <code>context</code>。widget 属性表示当前正在关联的 widget 实例，但关联关系可能会在 widget 重构时发生变化（framework 会动态设置 widget 属性为最新的widget 对象）。context 属性是 buildContext 类的实例，表示构建 widget 的上下文，每个 widget 都有一个自己的 context 对象，<br>它包含了查找、遍历当前 widget 树的方法。</p>
<h3 id="3-State的生命周期"><a href="#3-State的生命周期" class="headerlink" title="(3.)State的生命周期"></a>(3.)State的生命周期</h3><p>如下代码:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class TestStateWidget extends StatefulWidget &#123;</span><br><span class="line">  @override</span><br><span class="line">  _TestStateWidgetState createState() =&gt; _TestStateWidgetState(text);</span><br><span class="line">&#125;</span><br><span class="line">class _TestStateWidgetState extends State&lt;TestStateWidget&gt; &#123;</span><br><span class="line">  _TestStateWidgetState(this.text);</span><br><span class="line">  @override</span><br><span class="line">  void initState() &#123;</span><br><span class="line">    ///初始化，这个函数在生命周期中只调用一次</span><br><span class="line">    super.initState();</span><br><span class="line">  &#125;</span><br><span class="line">  @override</span><br><span class="line">  void dispose() &#123;</span><br><span class="line">    ///销毁</span><br><span class="line">    super.dispose();</span><br><span class="line">  &#125;</span><br><span class="line">  @override</span><br><span class="line">  void didChangeDependencies() &#123;</span><br><span class="line">    ///在initState之后调 Called when a dependency of this [State] object changes.</span><br><span class="line">    super.didChangeDependencies();</span><br><span class="line">  &#125;</span><br><span class="line">  @override</span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    return Container(</span><br><span class="line">    ...</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>State 中主要的声明周期有 ：</p>
<ul>
<li>initState：初始化，理论上只有初始化一次。</li>
<li>didChangeDependencies：在 initState 之后调用，此时可以获取其他 State 。</li>
<li>dispose：销毁，只会调用一次。</li>
</ul>
<h3 id="3-Flutter自定义Widget"><a href="#3-Flutter自定义Widget" class="headerlink" title="3.Flutter自定义Widget"></a>3.Flutter自定义Widget</h3><p>上文也讲到了在Flutter开发中，可以继承自StatelessWidget或者StatefulWidget来创建自己的Widget类；</p>
<ul>
<li>StatelessWidget： 没有状态改变的Widget，通常这种Widget仅仅是做一些展示工作而已；</li>
<li>StatefulWidget： 需要保存状态，并且可能出现状态改变的Widget；</li>
</ul>
<p>build方法什么情况下被执行呢：</p>
<ol>
<li>当我们的StatelessWidget第一次被插入到Widget树中时（也就是第一次被创建时）；</li>
<li>当我们的父Widget（parent widget）发生改变时，子Widget会被重新构建；</li>
<li>如果我们的Widget依赖InheritedWidget的一些数据，InheritedWidget数据发生改变时；</li>
</ol>
<h1 id="三-StatefulWidget的状态管理"><a href="#三-StatefulWidget的状态管理" class="headerlink" title="三. StatefulWidget的状态管理"></a>三. StatefulWidget的状态管理</h1><h3 id="1-widget的状态"><a href="#1-widget的状态" class="headerlink" title="1.widget的状态"></a>1.widget的状态</h3><p>我们知道在Flutter 内一切皆 Widge。runApp函数接受给定的Widget并使其成为widget树的根。<br>Widget描述了他们的视图在给定其当前配置和状态时应该看起来像什么。widget 的主要工作是通过实现 build 函数 来构建自身。<br>当widget调用build 函数时就会绘制出一帧静止的画面.当需要widget进行改变的时候就要不断地调用widget的build 函数进行绘制.<br>我们将widget对应的每一帧画面称作为一个状态.当widget的状态发生变化时，widget会重新构建UI，Flutter会对比前后变化的不同以确定底层渲染树从一个状态转换到下一个状态所需的最小更改.</p>
<blockquote>
<p>注意:通常我们所说的StatefulWidget是有状态的组件，意思不是说StatefulWidget类本身是可变的，实际上StatefulWidget类本身也是不变的，StatefulWidget持有的state状态<br>是在该对应widget整个生命周期内一直存在的，<br>也是因为有了这个state状态，我们就可以通知Flutter框架某一个状态发生了变化，Flutter会重新运行build方法来重新绘制界面。这里的有状态指的是创建时需要指定一个 State ，<br>在需要更新 UI时调用 setState(VoidCallbackfn)，并在 VoidCallback 中改变一些些变量数值等，组件会重新 build 以达到数显状态&#x2F;UI的效果。</p>
</blockquote>
<h3 id="2-widget的状态改变的实现"><a href="#2-widget的状态改变的实现" class="headerlink" title="2.widget的状态改变的实现"></a>2.widget的状态改变的实现</h3><p>来看一下Widget的源码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@immutable</span><br><span class="line">abstract class Widget extends DiagnosticableTree &#123;</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>@immutable实际上是一个注解 被@immutable注解标明的类或者子类都必须是不可变的也就是说定义到Widget中的数据一定是不可变的，需要使用final来修饰.<br>StatelessWidget是没有状态得因此它里面的数据通常是直接定义完后就不修改的。StatefulWidget需要有状态（可以理解成变量）的改变,既然我们在上面源码里面分析了Widget是不可变，<br>那么StatefulWidget如何来存储可变的状态呢？Flutter是靠将StatefulWidget设计成了两个类来实现状态的变化的:</p>
<ul>
<li>一个类继承自StatefulWidget，作为Widget树的一部分；</li>
<li>一个类继承自State，用于记录StatefulWidget会变化的状态，并且根据状态的变化，构建出新的Widget；<br>这样设计的原因是因为在Flutter中，只要数据改变了Widget就需要重新构建（rebuild）</li>
</ul>
<h3 id="3-widget的状态管理的方式"><a href="#3-widget的状态管理的方式" class="headerlink" title="3.widget的状态管理的方式"></a>3.widget的状态管理的方式</h3><p>状态管理就是一些能够引发界面状态改变的变量进行管理.这些变量需要在多个组件或者是路由界面中使用，所以就有了状态管理。<br>目前状态管理的方式有三种:</p>
<ul>
<li>Widget管理自己的状态。</li>
<li>父Widget管理子Widget状态。</li>
<li>混合管理（父Widget和子Widget都管理状态）。<br>如果某些状态只需要在自己的Widget中使用即可,Widget树中的其它部分并不需要访问这个状态.那么我们可以通过widget 管理自己的 state.比如选择框的选中状态.<br>但是如果某些状态需要在多个部分进行共享,那我们只有通过父 widget 管理子 widget 状态或者混合管理来实现了.比如用户的登录状态信息.</li>
</ul>
<blockquote>
<p>一般的原则是：如果状态是组件私有的，则应该由组件自己管理；如果状态要跨组件共享，则该状态应该由各个组件共同的父元素来管理.</p>
</blockquote>
<h3 id="4-跨widget跨页面状态管理"><a href="#4-跨widget跨页面状态管理" class="headerlink" title="4. 跨widget跨页面状态管理"></a>4. 跨widget跨页面状态管理</h3><p>上面说到跨组件状态管理我们一般是通过父Widget管理子Widget状态来实现.例如A组件嵌套B,C两个兄弟组件,B组件有一个B1组件,C组件有一个C1组件.如果B1和C1组件需要共享一个状态,<br>那实现起来就非常麻烦,我们需要这个状态放到A组件中再通过B组件和C组件将整个状态传递到B1组件和C1组件组件中去.<br>通过这种方式我们可以发现B,C两个组件本身并不需要这个共享的状态,但是他们作为中转组件也必须要持有这个状态,如果随着层架的增加这种情况还会更加严重.我们如果在不同的Widget之间将状态传递来、传递去，<br>那么是无穷尽的，并且代码的耦合度会变得非常高，牵一发而动全身，无论是代码编写质量、后期维护、可扩展性都非常差。并且有的状态是需要跨页面共享的,例如登录状态.传递起来就更麻烦了.<br>这时，正确的做法是通过一个全局状态管理器来处理这种相距较远的组件之间的通信。目前主要有两种办法：</p>
<ul>
<li>实现一个全局的事件总线EventBus，需要这个状态的组件可以通过订阅这个状态的通知,在收到通知后调用setState(…)方法重新build一下自身即可。</li>
<li>使用一些专门用于状态管理的包，如Provider、GetX、Redux等专门管理状态的工具包进行管理.(后续我会讲解这些包的使用)</li>
</ul>
<h1 id="三-常见的Widget"><a href="#三-常见的Widget" class="headerlink" title="三.常见的Widget"></a>三.常见的Widget</h1><h3 id="1-容器"><a href="#1-容器" class="headerlink" title="1.容器"></a>1.容器</h3><p>Flutter 中拥有需要将近30种内置的 容器Widget，其中常用有 Container、Padding、Center、Flex、Stack、Row、Column、ListView 等.<br>例如:</p>
<ul>
<li>Row，是水平方向的线性布局（linearlayout）</li>
<li>Column，是垂直方向的线性布局（linearlayout）</li>
<li>Stack，可以理解成为相对布局。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class MyApp extends StatelessWidget&#123;</span><br><span class="line">  @override</span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    return new MaterialApp(</span><br><span class="line">      title: &#x27;Welcome to Flutter&#x27;,</span><br><span class="line">      home: new Scaffold(</span><br><span class="line">        appBar: new AppBar(</span><br><span class="line">          title: new Text(&#x27;Welcome to Flutter&#x27;),</span><br><span class="line">        ),</span><br><span class="line">        body: new Center(</span><br><span class="line">          child: new Column(</span><br><span class="line">            children: &lt;Widget&gt;[</span><br><span class="line">              new Text(&#x27;Text 1&#x27;),</span><br><span class="line">              new Text(&#x27;Text 2&#x27;),</span><br><span class="line">              new Text(&#x27;Text 3&#x27;)</span><br><span class="line">            ],),),),);&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-页面"><a href="#2-页面" class="headerlink" title="2.页面"></a>2.页面</h3><p>Flutter 中除了布局的 Widget，还有交互显示的 Widget 和完整页面呈现的Widget，其中常见的有Scaffold等.</p>
<h1 id="四-widget事件"><a href="#四-widget事件" class="headerlink" title="四. widget事件"></a>四. widget事件</h1><p>这里分两种情况,一种是widget 本身支持事件监测,另外一种是widget不支持事件检测.</p>
<h3 id="1-widget-本身支持事件"><a href="#1-widget-本身支持事件" class="headerlink" title="1.widget 本身支持事件,"></a>1.widget 本身支持事件,</h3><p>如果 widget 本身支持事件监测，直接传递给它一个函数，并在这个函数里实现响应方法。例如，RaisedButton、IconButton、OutlineButton、Checkbox、SnackBar、Switch等。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class SampleApp extends StatelessWidget &#123;</span><br><span class="line">  @override</span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    return Scaffold(</span><br><span class="line">    body:Center(</span><br><span class="line">      child: MaterialButton(</span><br><span class="line">        child: Text(&#x27;click me&#x27;),</span><br><span class="line">         onPressed: ()&#123;</span><br><span class="line">            print(&#x27;on click&#x27;)</span><br><span class="line">         );</span><br><span class="line">      &#125;),</span><br><span class="line">     ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="2-widget-本身不支持事件"><a href="#2-widget-本身不支持事件" class="headerlink" title="2. widget 本身不支持事件,"></a>2. widget 本身不支持事件,</h3><p>如果 widget 本身不支持事件监测，则在外面包裹一个 GestureDetector(或者支持事件的widget例如: InkWell)，并给它的属性传递一个onTap函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class SampleApp extends StatelessWidget &#123;</span><br><span class="line">  @override</span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    return Scaffold(</span><br><span class="line">      body: Center(</span><br><span class="line">        child: GestureDetector(</span><br><span class="line">          child: Text(&#x27;click me&#x27;),</span><br><span class="line">          onTap: () &#123;</span><br><span class="line">           print(&#x27;on click&#x27;)</span><br><span class="line">          &#125;,</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-widget-手势事件"><a href="#3-widget-手势事件" class="headerlink" title="3. widget 手势事件"></a>3. widget 手势事件</h3><table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>onTapDwon</td>
<td>当按下屏幕时触发</td>
</tr>
<tr>
<td>onTap</td>
<td>当与屏幕短暂地触碰时触发，最常用</td>
</tr>
<tr>
<td>onTapUp</td>
<td>当用户停止触碰屏幕时触发</td>
</tr>
<tr>
<td>onTapCancel</td>
<td>当用户触摸屏幕，但没有完成Tap事件时触发</td>
</tr>
<tr>
<td>onDoubleTap</td>
<td>快速双击屏幕时触发</td>
</tr>
<tr>
<td>onLongPress</td>
<td>当长按屏幕时触发（与屏幕接触事件必须超过500ms）</td>
</tr>
<tr>
<td>onPanUpdate</td>
<td>当在屏幕上移动时触发</td>
</tr>
<tr>
<td>onVerticalDragDown</td>
<td>当手指触碰屏幕且准备往屏幕垂直方向移动时触发</td>
</tr>
<tr>
<td>onVerticalDragStart</td>
<td>当手指触碰屏幕且开始往屏幕垂直方向移动时触发</td>
</tr>
<tr>
<td>onVerticalDragUpdate</td>
<td>当手指触碰屏幕且开始往屏幕垂直方向移动并发生位移时触发</td>
</tr>
<tr>
<td>onVerticalDragEnd</td>
<td>当用户完成垂直方向触摸屏幕时触发</td>
</tr>
<tr>
<td>onVerticalDragCancel</td>
<td>当用户中断了onVerticalDragDown时触发</td>
</tr>
<tr>
<td>onHorizontalDragDown</td>
<td>当手指触摸屏幕且准备往屏幕水平方向移动时触发</td>
</tr>
<tr>
<td>onHorizontalDragStart</td>
<td>当手指触摸屏幕且开始往屏幕水平方向移动时触发</td>
</tr>
<tr>
<td>onHorizontalDragUpdate</td>
<td>当手指触摸屏幕且开始往屏幕水平方向移动并发生位移时触发</td>
</tr>
<tr>
<td>onHorizontalDragEnd</td>
<td>当用户完成水平方向触摸屏幕时触发</td>
</tr>
<tr>
<td>onHorizontalDragCancel</td>
<td>当用户中断了onHorizontalDragDown时触发</td>
</tr>
<tr>
<td>onPanDown</td>
<td>当用户触摸屏幕时触发</td>
</tr>
<tr>
<td>onPanStart</td>
<td>当用户触摸屏幕并开始移动时触发</td>
</tr>
<tr>
<td>onPanUpdate</td>
<td>当用户触摸屏幕并产生移动时触发</td>
</tr>
<tr>
<td>onPanEnd</td>
<td>当用户完成触摸屏幕时触发</td>
</tr>
<tr>
<td>onScaleStart</td>
<td>当用户触摸屏幕并开始缩放时触发</td>
</tr>
<tr>
<td>onScaleUpdate</td>
<td>当用户触摸屏幕并产生缩放时触发</td>
</tr>
<tr>
<td>onScaleEnd</td>
<td>当用户完成缩放时触发</td>
</tr>
</tbody></table>
<h1 id="五-路由和导航"><a href="#五-路由和导航" class="headerlink" title="五.路由和导航"></a>五.路由和导航</h1><p>Flutter 中万物皆 Widget，页面自然也是一个 Widget。只不过是一个全屏的 Widget。在flutter中两种页面跳转方式:</p>
<ul>
<li>无名路由跳转(一种动态构建路由的方式)。</li>
<li>命名路由跳转(一种提前命名路由的方式)。</li>
</ul>
<h3 id="1-无名路由跳转"><a href="#1-无名路由跳转" class="headerlink" title="1.无名路由跳转"></a>1.无名路由跳转</h3><p>直接使用使用 Navigator 跳转页面，在 Flutter 中，使用 Navigator 来进行页面跳转。一个简单的跳转页面的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Navigator.push(</span><br><span class="line">  context,</span><br><span class="line">  MaterialPageRoute(</span><br><span class="line">  // 目标页面，一个 Widget</span><br><span class="line">    builder: (context) =&gt; PageA(),</span><br><span class="line">  ),</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Navigator.of(context).push(</span><br><span class="line">  MaterialPageRoute(</span><br><span class="line">    builder: (context) =&gt; PageA(),</span><br><span class="line">  ),</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>在A页面中关闭A页面返回到上一个页面:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Navigator.pop(context);</span><br></pre></td></tr></table></figure>
<p>或者:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Navigator.of(context).pop();</span><br></pre></td></tr></table></figure>
<h3 id="2-命名路由跳转"><a href="#2-命名路由跳转" class="headerlink" title="2.命名路由跳转"></a>2.命名路由跳转</h3><p>命名路由跳转需要先注册路由表,放在MaterialApp的 initialRoute 和 routes 中.命名路由路由存在的意义在于可以让我们更方便的导航到想要到达的页面，便于管理和维护。<br>要想使用命名路由，我们必须先提供并注册一个路由表（routing table），这样应用程序才知道哪个名字与哪个路由组件相对应。路由表的注册方式很简单，找到MaterialApp，添加routes属性，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">void main() =&gt; runApp(MyApp());//单行函数调用写法</span><br><span class="line">class MyApp extends StatelessWidget &#123;</span><br><span class="line">  @override</span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    return MaterialApp(</span><br><span class="line">      title: &quot;AppTitle&quot;,</span><br><span class="line">      theme: ThemeData(primaryColor: Colors.green),</span><br><span class="line">      initialRoute: &quot;first_page&quot;,//初始路由页面,作用是定义APP启动时第一个显示的页面</span><br><span class="line">      routes: &#123;</span><br><span class="line">        //路由注册表</span><br><span class="line">        &quot;first_page&quot;: (BuildContext context) =&gt; FirstPage(),  //当navigating到‘first_page’ route时，FirstPage widget</span><br><span class="line">        &quot;second_page&quot;: (BuildContext context) =&gt; SecondPage(), //当navigating到‘second_page’ route时，SecondPage widget</span><br><span class="line">      &#125;,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要通过路由名称来打开新路由，可以使用Navigator 的pushNamed方法：<br>Future pushNamed(BuildContext context, String routeName,{Object arguments})<br>Navigator 除了pushNamed方法，还有pushReplacementNamed等其他管理命名路由的方法，读者可以自行查看API文档。通过刚刚注册的页面名称来跳转一个页面：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Navigator.pushNamed(context, &#x27;first_page&#x27;);// one_page表示页面别名</span><br></pre></td></tr></table></figure>
<h3 id="3-界面之间传递参数"><a href="#3-界面之间传递参数" class="headerlink" title="3.界面之间传递参数"></a>3.界面之间传递参数</h3><p>传递的方式有两种:</p>
<ul>
<li>通过构造方法中传递数据。</li>
<li>在Route中传递数据给下一个页面。</li>
</ul>
<h5 id="1-通过构造方法中传递数据"><a href="#1-通过构造方法中传递数据" class="headerlink" title="(1. )通过构造方法中传递数据"></a>(1. )通过构造方法中传递数据</h5><p>需要在接收数据的页面事先定义好构造方法，构造方法中定义要接收的参数。例如：我们在SecondPage中定义一个构造方法，构造方法中可以定义我们要接收的数据:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class SecondPage extends StatelessWidget &#123;</span><br><span class="line">  String data;</span><br><span class="line">  PageB(&#123;this.data&#125;);</span><br><span class="line">  @override</span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    return Scaffold(</span><br><span class="line">      appBar: AppBar(</span><br><span class="line">        title: Text(&quot;Second页面&quot;),</span><br><span class="line">      ),</span><br><span class="line">      body: Center(</span><br><span class="line">        child: Text(data),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Frist页面跳转SecondPage页面时给传递数据：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Navigator.push(</span><br><span class="line">  context,</span><br><span class="line">  MaterialPageRoute(</span><br><span class="line">    builder: (context) =&gt; SecondPage(</span><br><span class="line">          data: &quot;数据&quot;,</span><br><span class="line">        ),</span><br><span class="line">  ),</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h5 id="2-将参数传递给指定路由"><a href="#2-将参数传递给指定路由" class="headerlink" title="(2.)将参数传递给指定路由"></a>(2.)将参数传递给指定路由</h5><p>构造方法参数参数的缺点不是太灵活。Flutter提供了把传递的参数放到Navigator中，然后传递给指定的路由，在接收的页面提取出需要的参数即可，这种方式更加灵活一些。</p>
<ol>
<li>首先要先定义好要传递的数据<br>例如：<br>我们先定义一个实体类：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class People &#123;</span><br><span class="line">  String name;</span><br><span class="line">  int age;</span><br><span class="line">  People(this.name, this.age);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>传递参数<br>将参数数据传递给SecondPage，可以有如下四种传参方式，效果都一样<br>第一种:<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Navigator.pushNamed(</span><br><span class="line">  context,</span><br><span class="line">  second_page,</span><br><span class="line">  arguments: People(&quot;张三&quot;, 30),//要传递的数据</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
第二种:<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Navigator.of(context).pushNamed(second_page, arguments: People(&quot;张三&quot;, 30));</span><br></pre></td></tr></table></figure>
第三种:<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Navigator.push(context,</span><br><span class="line">   MaterialPageRoute(</span><br><span class="line">     builder: (context) =&gt; SecondPage(),</span><br><span class="line">     settings: RouteSettings(</span><br><span class="line">       arguments: People(&quot;张三&quot;, 30),</span><br><span class="line">     ),</span><br><span class="line">   ),</span><br><span class="line"> );</span><br></pre></td></tr></table></figure>
第四种<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Navigator.of(context).push(</span><br><span class="line">  MaterialPageRoute(</span><br><span class="line">      builder: (context) =&gt; SecondPage(),</span><br><span class="line">      settings: RouteSettings(</span><br><span class="line">          arguments: People(&quot;张三&quot;, 30),</span><br><span class="line">      )</span><br><span class="line">  ),</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li>
<li>接收参数<br>在SecondPage接收数据时，数据要通过 ModalRoute.of 方法。此方法返回带有参数的当前路由。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class SecondPage extends StatelessWidget &#123;</span><br><span class="line">  @override</span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    /*获取传递过来的参数*/</span><br><span class="line">    People _people = ModalRoute.of(context).settings.arguments;</span><br><span class="line"></span><br><span class="line">    return Scaffold(</span><br><span class="line">      appBar: AppBar(</span><br><span class="line">        title: Text(&quot;SecondPage&quot;),</span><br><span class="line">      ),</span><br><span class="line">      body: Center(</span><br><span class="line">        child: Text(&quot;name：$&#123;_people.name&#125;,age：$&#123;_people.age&#125;&quot;),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="4-返回参数"><a href="#4-返回参数" class="headerlink" title="4.返回参数"></a>4.返回参数</h3><p>路由打开页面后可以通过await 关键字等待路由返回参数.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class FirstPage extends StatelessWidget &#123;</span><br><span class="line">  @override</span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    return Center(</span><br><span class="line">      child: RaisedButton(</span><br><span class="line">        onPressed: () async &#123;</span><br><span class="line">          // 打开`SecondPage`，并等待返回结果</span><br><span class="line">          var result = await Navigator.push(</span><br><span class="line">            context,</span><br><span class="line">            MaterialPageRoute(</span><br><span class="line">              builder: (context) &#123;</span><br><span class="line">                return SecondPage(</span><br><span class="line">                  // 路由参数</span><br><span class="line">                  text: &quot;xxxx&quot;,</span><br><span class="line">                );</span><br><span class="line">              &#125;,</span><br><span class="line">            ),</span><br><span class="line">          );</span><br><span class="line">          //输出路由返回结果</span><br><span class="line">          print(&quot;路由返回值: $result&quot;);</span><br><span class="line">        &#125;,</span><br><span class="line">        child: Text(&quot;open SecondPage&quot;),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过Navigator.pop返回数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class SecondPage extends StatelessWidget &#123;</span><br><span class="line">  TipRoute(&#123;</span><br><span class="line">    Key key,</span><br><span class="line">    @required this.text,  // 接收一个text参数</span><br><span class="line">  &#125;) : super(key: key);</span><br><span class="line">  final String text;</span><br><span class="line">  @override</span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    return Scaffold(</span><br><span class="line">      body: Padding(</span><br><span class="line">        padding: EdgeInsets.all(18),</span><br><span class="line">        child: Center(</span><br><span class="line">          child: Column(</span><br><span class="line">            children: &lt;Widget&gt;[</span><br><span class="line">              Text(text),</span><br><span class="line">              RaisedButton(</span><br><span class="line">                onPressed: () =&gt; Navigator.pop(context, &quot;我是返回值&quot;),</span><br><span class="line">                child: Text(&quot;返回&quot;),</span><br><span class="line">              )</span><br><span class="line">            ],</span><br><span class="line">          ),</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-路由拦截"><a href="#5-路由拦截" class="headerlink" title="5. 路由拦截"></a>5. 路由拦截</h3><p>我们开发App的时候,有的界面无需要登录就可以查看例如新闻,视频等功能,但是有的界面如我的,收藏列表等页面需要登录才能查看.为了实现上诉功能通常的做法是<br>在打开每一个路由页前判断用户登录状态,但是每次打开路由前我们都需要去判断一下将会非常麻烦，可以用Flutter提供路由拦截来解决这种问题.MaterialApp有一个onGenerateRoute属性，<br>当调用Navigator.pushNamed(…)打开命名路由时，如果指定的路由名在路由表中已注册，则会调用路由表中生成路由组件；<br>如果路由表中没有注册，才会调用onGenerateRoute来生成路由。要实现制页面权限的功能就非常容易：在onGenerateRoute中进行统一的权限控制判断，如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">MaterialApp(</span><br><span class="line">  ... </span><br><span class="line">   onGenerateRoute: (RouteSettings settings) &#123;</span><br><span class="line">        //isLogin 为登录逻辑的判断</span><br><span class="line">        String routeName = isLogin ? settings.name! : &quot;/login&quot;;</span><br><span class="line">        return MaterialPageRoute(builder: (context) &#123;</span><br><span class="line">          switch (routeName) &#123;</span><br><span class="line">            case &quot;/index&quot;:</span><br><span class="line">              return MyHomePage();</span><br><span class="line">            case &quot;/login&quot;:</span><br><span class="line">              return LoginScreen();</span><br><span class="line">            default:</span><br><span class="line">              return Scaffold(</span><br><span class="line">                body: Center(</span><br><span class="line">                  child: Text(&quot;页面不存在&quot;),</span><br><span class="line">                ),</span><br><span class="line">              );</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>onGenerateRoute只会对命名路由生效。</p>
</blockquote>
<h3 id="5-路由使用总结"><a href="#5-路由使用总结" class="headerlink" title="5.路由使用总结"></a>5.路由使用总结</h3><p>建议最好统一使用命名路由的管理方式好处有：</p>
<ul>
<li>语义化更明确。</li>
<li>代码更好维护；如果使用匿名路由，则必须在调用Navigator.push的地方创建新路由页，这样不仅需要import新路由页的dart文件，而且这样的代码将会非常分散。</li>
<li>可以通过onGenerateRoute做一些全局的路由跳转前置处理逻辑。</li>
</ul>
<h1 id="六-资源管理"><a href="#六-资源管理" class="headerlink" title="六. 资源管理"></a>六. 资源管理</h1><p>Flutter APP安装包中会包含代码和 assets（资源）两部分。Assets是会打包到程序安装包中的，可在运行时进行访问。常见类型的assets包括:</p>
<ul>
<li>图标和图片（JPEG，WebP，GIF，动画WebP &#x2F; GIF，PNG，BMP和WBMP） </li>
<li>字体</li>
<li>Json文件</li>
<li>静态数据(视频,声音)</li>
</ul>
<h3 id="1-加载图片"><a href="#1-加载图片" class="headerlink" title="1.加载图片"></a>1.加载图片</h3><p>类似于Android原生开发，Flutter也可以为当前设备加载适合其分辨率的图像。</p>
<table>
<thead>
<tr>
<th>dpi范围</th>
<th>密度</th>
</tr>
</thead>
<tbody><tr>
<td>0dpi ~ 120dpi</td>
<td>ldpi</td>
</tr>
<tr>
<td>120dpi ~ 160dpi</td>
<td>mdpi</td>
</tr>
<tr>
<td>160dpi ~ 240dpi</td>
<td>hdpi</td>
</tr>
<tr>
<td>240dpi ~ 320dpi</td>
<td>xhdpi</td>
</tr>
<tr>
<td>320dpi ~ 480dpi</td>
<td>xxhdpi</td>
</tr>
<tr>
<td>480dpi ~ 640dpi</td>
<td>xxxhdpi</td>
</tr>
</tbody></table>
<h5 id="1-声明分辨率相关的图片-assets"><a href="#1-声明分辨率相关的图片-assets" class="headerlink" title="(1.)声明分辨率相关的图片 assets"></a>(1.)声明分辨率相关的图片 assets</h5><p>pubspec.yaml中asset添加不同设备像素比例的图片。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">…/my_icon.png</span><br><span class="line">…/2.0x/my_icon.png</span><br><span class="line">…/3.0x/my_icon.png</span><br></pre></td></tr></table></figure>
<p>在设备像素比率为1.8的设备上，…&#x2F;2.0x&#x2F;my_icon.png 将被选择。对于2.7的设备像素比率，…&#x2F;3.0x&#x2F;my_icon.png将被选择。</p>
<p>如果没有在Image widget上指定渲染图像的宽度和高度，那么Image widget将占用与主资源相同的屏幕空间大小。<br>也就是说，如果是…&#x2F;my_icon.png是72px乘72px，如果是…&#x2F;3.0x&#x2F;my_icon.png应该是216px乘216px;<br>pubspec.yaml中asset部分中的每一项都应与实际文件相对应，但主资源项除外。当主资源缺少某个资源时，会按分辨率从低到高的顺序去选择，也就是说1x中没有的话会在2x中找，2x中还没有的话就在3x中找。</p>
<h3 id="2-特定平台-assets"><a href="#2-特定平台-assets" class="headerlink" title="2. 特定平台 assets"></a>2. 特定平台 assets</h3><p>上面的资源都是flutter应用中的，这些资源只有在Flutter框架运行之后才能使用，如果要给我们的应用设置APP图标或者添加启动图，那我们必须使用特定平台的assets。</p>
<h5 id="1-设置APP启动图标"><a href="#1-设置APP启动图标" class="headerlink" title="(1.)设置APP启动图标"></a>(1.)设置APP启动图标</h5><p><strong>Android</strong><br>在Flutter项目的根目录中，导航到…&#x2F;android&#x2F;app&#x2F;src&#x2F;main&#x2F;res目录，里面包含了各种资源文件夹（如mipmap-hdpi已包含占位符图像“ic_launcher.png”）。<br> 只需按照Android开发人员指南 (opens new window)中的说明， 将其替换为所需的资源，并遵守每种屏幕密度（dpi）的建议图标大小标准。</p>
<blockquote>
<p>注意: 如果您重命名.png文件，则还必须在您AndroidManifest.xml的<application>标签的android:icon属性中更新名称。</p>
</blockquote>
<p><strong>iOS</strong><br>在Flutter项目的根目录中，导航到…&#x2F;ios&#x2F;Runner。该目录中Assets.xcassets&#x2F;AppIcon.appiconset已经包含占位符图片， 只需将它们替换为适当大小的图片，保留原始文件名称。</p>
<h5 id="2-启动页"><a href="#2-启动页" class="headerlink" title="(2.)启动页"></a>(2.)启动页</h5><p><strong>Android</strong><br>要将启动屏幕（splash screen）添加到您的Flutter应用程序， 请导航至…&#x2F;android&#x2F;app&#x2F;src&#x2F;main。在res&#x2F;drawable&#x2F;launch_background.xml，通过自定义drawable来实现自定义启动界面<br>（你也可以直接换一张图片）。</p>
<p><strong>iOS</strong><br>要将图片添加到启动屏幕（splash screen）的中心，请导航至…&#x2F;ios&#x2F;Runner。在Assets.xcassets&#x2F;LaunchImage.imageset， 拖入图片，<br>并命名为LaunchImage.png、<a href="mailto:&#76;&#x61;&#117;&#x6e;&#99;&#104;&#x49;&#109;&#x61;&#103;&#x65;&#64;&#x32;&#x78;&#x2e;&#112;&#110;&#103;">&#76;&#x61;&#117;&#x6e;&#99;&#104;&#x49;&#109;&#x61;&#103;&#x65;&#64;&#x32;&#x78;&#x2e;&#112;&#110;&#103;</a>、<a href="mailto:&#x4c;&#x61;&#x75;&#110;&#99;&#104;&#73;&#109;&#x61;&#x67;&#x65;&#64;&#x33;&#120;&#46;&#112;&#x6e;&#103;">&#x4c;&#x61;&#x75;&#110;&#99;&#104;&#73;&#109;&#x61;&#x67;&#x65;&#64;&#x33;&#120;&#46;&#112;&#x6e;&#103;</a>。 如果你使用不同的文件名，那您还必须更新同一目录中的Contents.json文件，图片的具体尺寸可以查看苹果官方的标准。<br>您也可以通过打开Xcode完全自定义storyboard。在Project Navigator中导航到Runner&#x2F;Runner然后通过打开Assets.xcassets拖入图片，或者通过在LaunchScreen.storyboard中使用Interface Builder进行自定义。</p>
<h1 id="七-包管理与第三方库引入"><a href="#七-包管理与第三方库引入" class="headerlink" title="七.包管理与第三方库引入"></a>七.包管理与第三方库引入</h1><h3 id="1-YAML包管理"><a href="#1-YAML包管理" class="headerlink" title="1. YAML包管理"></a>1. YAML包管理</h3><p>Flutter使用配置文件pubspec.yaml（位于项目根目录）来管理第三方依赖包。<br>pubspec.yaml:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">name: flutter_in_action</span><br><span class="line">description: First Flutter application.</span><br><span class="line"></span><br><span class="line">version: 1.0.0+1</span><br><span class="line"></span><br><span class="line">dependencies:</span><br><span class="line">  flutter:</span><br><span class="line">    sdk: flutter</span><br><span class="line">  cupertino_icons: ^0.1.2</span><br><span class="line"></span><br><span class="line">dev_dependencies:</span><br><span class="line">  flutter_test:</span><br><span class="line">    sdk: flutter</span><br><span class="line">    </span><br><span class="line">flutter:</span><br><span class="line">  uses-material-design: true</span><br></pre></td></tr></table></figure>

<p>下面，我们逐一解释一下各个字段的意义：</p>
<ul>
<li>name：应用或包名称。</li>
<li>description: 应用或包的描述、简介。</li>
<li>version：应用或包的版本号。</li>
<li>dependencies：应用或包依赖的其它包或插件。</li>
<li>dev_dependencies：开发环境依赖的工具包（而不是flutter应用本身依赖的包）。</li>
<li>flutter：flutter相关的配置选项。<br>如果我们的Flutter应用本身依赖某个包，我们需要将所依赖的包添加到dependencies 下.<blockquote>
<p>需要注意dependencies和dev_dependencies的区别，前者的依赖包将作为APP的源码的一部分参与编译，生成最终的安装包。<br>而后者的依赖包只是作为开发阶段的一些工具包，主要是用于帮助我们提高开发、测试效率，比如flutter的自动化测试包等。</p>
</blockquote>
</li>
</ul>
<h3 id="2-依赖方式"><a href="#2-依赖方式" class="headerlink" title="2.依赖方式"></a>2.依赖方式</h3><p>有三种依赖方式:</p>
<h5 id="1-依赖Pub仓库"><a href="#1-依赖Pub仓库" class="headerlink" title="1. 依赖Pub仓库"></a>1. 依赖Pub仓库</h5><p><a target="_blank" rel="noopener" href="https://pub.dev/">Pub</a>是Google官方的Dart Packages仓库，类似于node中的npm仓库，android中的jcenter。我们可以在Pub上面查找我们需要的包和插件，也可以向Pub发布我们的包和插件。<br>我们也可以在控制台，定位到当前工程目录，然后手动运行flutter packages get 命令来下载依赖包。</p>
<h5 id="3-依赖本地包"><a href="#3-依赖本地包" class="headerlink" title="3. 依赖本地包"></a>3. 依赖本地包</h5><p>如果我们正在本地开发一个包，包名为pkgOne，我们可以通过下面方式依赖：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dependencies:</span><br><span class="line">	pkg1:</span><br><span class="line">        path: ../../code/pkgOne</span><br></pre></td></tr></table></figure>
<p>路径可以是相对的，也可以是绝对的。</p>
<h5 id="3依赖git仓库"><a href="#3依赖git仓库" class="headerlink" title="3依赖git仓库"></a>3依赖git仓库</h5><p>依赖Git：你也可以依赖存储在Git仓库中的包。如果软件包位于仓库的根目录中，请使用以下语法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dependencies:</span><br><span class="line">  pkg1:</span><br><span class="line">    git:</span><br><span class="line">      url: git://github.com/xxx/pkg1.git</span><br></pre></td></tr></table></figure>
<p>上面假定包位于Git存储库的根目录中。如果不是这种情况，可以使用path参数指定相对位置，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dependencies:</span><br><span class="line">  package1:</span><br><span class="line">    git:</span><br><span class="line">      url: git://github.com/flutter/packages.git</span><br><span class="line">      path: packages/package1        </span><br></pre></td></tr></table></figure>

<h1 id="八-Json解析"><a href="#八-Json解析" class="headerlink" title="八.Json解析"></a>八.Json解析</h1><p>由于Flutter禁用运行时反射，所以在Flutter中是没有GSON，Jackson这类解析JSON的库。</p>
<ul>
<li>方案一:手写实体类</li>
<li>方案二:json_ serializable库生成实体类</li>
<li>方案三:json-to-dart插件自动生成实体类</li>
</ul>
<h3 id="1-手动序列化JSON"><a href="#1-手动序列化JSON" class="headerlink" title="1. 手动序列化JSON"></a>1. 手动序列化JSON</h3><p>手动解析通常应用在一些基本简单的场合，即数据结构不是很复杂的场景，手动解析JSON是指使用Flutter提供的dart:convert中内置的JSON解码器。<br>它能够将原始JSON字符串传递给json.decode() 方法，该方法可以根据JSON字符串具体内容将其转为List或Map,然后在返回的Map&lt;String, dynamic&gt;或者List中查找所需的值。<br>它不需要依赖任何第三方库，对于小项目来说很方便。<br>例如:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, dynamic&gt; person = JSON.decode(jsonStr);</span><br><span class="line">print(&#x27;$&#123;person[&#x27;name&#x27;]&#125;&#x27;);</span><br><span class="line">print(&#x27;$&#123;person[&#x27;age&#x27;]&#x27;);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>JSON.decode()返回一个Map&lt;String, dynamic&gt;，这意味着我们直到运行时才知道值的类型。失去了静态类型语言特性，代码非常容易出错。非常不推荐。</p>
</blockquote>
<p>可以通过引入Model在模型类中序列化JSON来解决上述问题.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">  final String name;</span><br><span class="line">  final String age;</span><br><span class="line"></span><br><span class="line">  User(this.name, this.age);</span><br><span class="line"></span><br><span class="line">  User.fromJson(Map&lt;String, dynamic&gt; json)</span><br><span class="line">      : name = json[&#x27;name&#x27;],</span><br><span class="line">        age = json[&#x27;age&#x27;];</span><br><span class="line"></span><br><span class="line">  Map&lt;String, dynamic&gt; toJson() =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">      &#x27;name&#x27;: name,</span><br><span class="line">      &#x27;age&#x27;: age,</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用时</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Map personMap = JSON.decode(jsonStr);</span><br><span class="line">var person = Person.fromJson(personMap);</span><br><span class="line">print(&#x27;$&#123;person.name&#125;&#x27;);</span><br><span class="line">print(&#x27;$&#123;person.age&#125;&#x27;);</span><br></pre></td></tr></table></figure>
<p>通过Model调用代码可以具有类型安全、自动补全字段以及编译时异常等静态类型语言特性。如果拼写或者类型错误就不会通过编译，而不是在运行时崩溃。<br>不过在实际项目中JSON对象很少会这么简单，各种List和Map嵌套的JSON也是很常见的。如果每一个属性都通过手写来实现无疑是非常麻烦的。因此我们一般是不会手写的.</p>
<h3 id="2-通过使用-json-serializable生成JsonModel"><a href="#2-通过使用-json-serializable生成JsonModel" class="headerlink" title="2.通过使用 json_serializable生成JsonModel"></a>2.通过使用 json_serializable生成JsonModel</h3><p>json_serializable是Google提供的一个自动化的源代码生成器，可以为我们生成JSON序列化模板。这种方案易维护，由于序列化数据代码不再需要手动编写或者维护，可以将序列化 JSON 数据在运行时的异常风险降到最低；</p>
<h5 id="1-引入依赖"><a href="#1-引入依赖" class="headerlink" title="(1.)引入依赖"></a>(1.)引入依赖</h5><p>需要用到以下三个依赖包，通过代码自动生成的方式，生成模型。</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://pub.dev/packages/json_annotation">json_annotation </a></li>
<li><a target="_blank" rel="noopener" href="https://pub.dev/packages/json_serializable">json_serializable </a></li>
<li><a target="_blank" rel="noopener" href="https://pub.dev/packages/build_runner">build_runner</a><br>在pubspec.yaml中添加依赖并执行flutter pub get：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dependencies:</span><br><span class="line">  json_annotation: ^x.x.x</span><br><span class="line"></span><br><span class="line">dev_dependencies:</span><br><span class="line">  build_runner: ^1.0.0</span><br><span class="line">  json_serializable: x.x.x</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="2-生成模型类"><a href="#2-生成模型类" class="headerlink" title="(2.)生成模型类"></a>(2.)生成模型类</h5><p>例如Json有如下Json文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;name&quot;: &quot;张三&quot;,</span><br><span class="line">    &quot;age&quot;: &quot;20&quot;,</span><br><span class="line">    &quot;tele&quot;: &quot;13888888888&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编写生成模型类:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">import &#x27;package:json_annotation/json_annotation.dart&#x27;; </span><br><span class="line">part &#x27;person.g.dart&#x27;;// result.g.dart 将在我们运行生成命令后自动生成</span><br><span class="line">@JsonSerializable()</span><br><span class="line">  class Person extends Object &#123;</span><br><span class="line"></span><br><span class="line">  //定义字段</span><br><span class="line">  @JsonKey(name: &#x27;name&#x27;)</span><br><span class="line">  String name;</span><br><span class="line"></span><br><span class="line">  @JsonKey(name: &#x27;age&#x27;)</span><br><span class="line">  String age;</span><br><span class="line"></span><br><span class="line">  @JsonKey(name: &#x27;tele&#x27;)</span><br><span class="line">  String tele;</span><br><span class="line"></span><br><span class="line">  Person(this.name,this.age,this.tele,); //定义构造方法</span><br><span class="line"></span><br><span class="line">  factory Person.fromJson(Map&lt;String, dynamic&gt; srcJson) =&gt; _$PersonFromJson(srcJson); //固定格式，不同的类使用不同的mixin即可</span><br><span class="line"></span><br><span class="line">  Map&lt;String, dynamic&gt; toJson() =&gt; _$PersonToJson(this); //固定格式</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>初次创建 Person.dart 的时候，需要加入 part ‘Person.g.dart’;</li>
<li>在需要转换的实体 dart 类 前加入 @JsonSerializable(nullable: false) 注解，标识需要 json序列化处理</li>
<li>fromJson()、toJson() 方法的写法是固定模式，按模板修改即可</li>
<li>Person.g.dart 和 文件名 需要保持一致，否则执行以下命令无效</li>
</ul>
<p>因为实体类的生成代码还不存在,所以上代码会提示一-些错误是正常现象</p>
<p>当然如果我们不想手动编写这个生成类,也可以通过一些工具进行.<a target="_blank" rel="noopener" href="https://caijinglong.github.io/json2dart/index_ch.html">json2dart</a> 就是这样的一个工具.<br>工具使用很简单直接粘贴生成对应的类名称,此时我们将生成的代码copy出来创建一个文件在自己的工程中,或者直接下载文件放入工程中即可.</p>
<h5 id="3-执行命令根据模型类-生成模型类代码"><a href="#3-执行命令根据模型类-生成模型类代码" class="headerlink" title="(3.)执行命令根据模型类,生成模型类代码."></a>(3.)执行命令根据模型类,生成模型类代码.</h5><p>一次性生成:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter packages pub run build_runner build</span><br></pre></td></tr></table></figure>
<p>持续生成:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter packages pub run build_runner watch。</span><br></pre></td></tr></table></figure>
<h5 id="4-使用"><a href="#4-使用" class="headerlink" title="(4.)使用"></a>(4.)使用</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Map person = JSON.decode(json);</span><br><span class="line">var list = getPersonModel(person);</span><br></pre></td></tr></table></figure>
<h3 id="2-通过在线或者开发工具json-to-dart插件生成"><a href="#2-通过在线或者开发工具json-to-dart插件生成" class="headerlink" title="2.通过在线或者开发工具json-to-dart插件生成"></a>2.通过在线或者开发工具json-to-dart插件生成</h3><p>Json2Dart在线插件:<br><a target="_blank" rel="noopener" href="https://javiercbk.github.io/json_to_dart/">JSON to Dart</a><br><a target="_blank" rel="noopener" href="https://czero1995.github.io/json-to-model/">JSON To Model</a><br><a target="_blank" rel="noopener" href="https://app.quicktype.io/">quicktype</a><br>或者在Android Studio里面装一个Dart2Json插件.</p>
<table>
<thead>
<tr>
<th>方案</th>
<th>特点</th>
<th>适合场景</th>
</tr>
</thead>
<tbody><tr>
<td>手写实体类</td>
<td>耗时</td>
<td>小型项目且json不复杂</td>
</tr>
<tr>
<td>json_serializable</td>
<td>需要定义字段、易维护</td>
<td>中大型项目</td>
</tr>
<tr>
<td>json-to-dart插件</td>
<td>快速、易操作</td>
<td>任何类型的项目</td>
</tr>
</tbody></table>
<h1 id="九-网络请求"><a href="#九-网络请求" class="headerlink" title="九.网络请求"></a>九.网络请求</h1><p>flutter网络请求三种方式: </p>
<ul>
<li>flutter自带的HttpClient</li>
<li>第三方库http </li>
<li>第三方库Dio</li>
</ul>
<h3 id="1-原生方式-不建议使用"><a href="#1-原生方式-不建议使用" class="headerlink" title="1. 原生方式(不建议使用)"></a>1. 原生方式(不建议使用)</h3><p>1.1 get 请求</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void getNetData() async &#123;</span><br><span class="line">  var client = new HttpClient();</span><br><span class="line">  var request = await client.getUrl(Uri.parse(url));</span><br><span class="line">  var response = await request.close();</span><br><span class="line">  if (response.statusCode == HttpStatus.ok) &#123;</span><br><span class="line">    _content = await response.transform(Utf8Decoder()).join();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-库http-不建议使用"><a href="#2-库http-不建议使用" class="headerlink" title="2.库http(不建议使用)"></a>2.库http(不建议使用)</h3><h5 id="1-get-请求"><a href="#1-get-请求" class="headerlink" title="(1.)get 请求"></a>(1.)get 请求</h5><p>代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void getNet() async &#123;</span><br><span class="line">  var client = http.Client();</span><br><span class="line">  http.Response response = await client.get(url);</span><br><span class="line">  _content = response.body;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码量比原生的简洁很多，然而还可以更简洁</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void getNet() &#123;</span><br><span class="line">  http.Client()</span><br><span class="line">      .get(url)</span><br><span class="line">      .then((http.Response response) &#123;</span><br><span class="line">            _content = response.body;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="2-post-请求"><a href="#2-post-请求" class="headerlink" title="(2.)post 请求"></a>(2.)post 请求</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void postNet() async &#123;</span><br><span class="line">  var params = Map&lt;String, String&gt;();</span><br><span class="line">  params[&quot;username&quot;] = &quot;xxxx&quot;;</span><br><span class="line">  params[&quot;password&quot;] = &quot;xxxx&quot;;</span><br><span class="line"> </span><br><span class="line">  var client = http.Client();</span><br><span class="line">  var response = await client.post(url_post, body: params);</span><br><span class="line">  _content = response.body;</span><br></pre></td></tr></table></figure>

<h3 id="3-库-dio-推荐使用"><a href="#3-库-dio-推荐使用" class="headerlink" title="3. 库 dio(推荐使用)"></a>3. 库 dio(推荐使用)</h3><p>官方提供的HttpClient和http都可以正常的发送网络请求，但是对于现代的应用程序开发来说，通常要求的东西会更多：比如拦截器、取消请求、文件上传&#x2F;下载、超时设置等等；可以使用一个在Flutter中非常流行的三方库：<a target="_blank" rel="noopener" href="https://github.com/flutterchina/dio/blob/master/README-ZH.md">dio</a>；</p>
<blockquote>
<p>dio是一个强大的Dart Http请求库，支持Restful API、FormData、拦截器、请求取消、Cookie管理、文件上传&#x2F;下载、超时、自定义适配器等…<br>pubspec.yaml 添加依赖：</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dependencies:</span><br><span class="line">  ...  </span><br><span class="line">  dio: ^1.0.9</span><br></pre></td></tr></table></figure>
<h5 id="1-get-请求-1"><a href="#1-get-请求-1" class="headerlink" title="(1.)get 请求"></a>(1.)get 请求</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void getNet() async &#123;</span><br><span class="line">  Dio dio = new Dio();</span><br><span class="line">  var response = await dio.get(url);</span><br><span class="line">  _content = response.data.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-post-请求-1"><a href="#2-post-请求-1" class="headerlink" title="(2.)post 请求"></a>(2.)post 请求</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void postNet() async &#123;</span><br><span class="line">  FormData formData = new FormData.from(&#123;</span><br><span class="line">    &quot;username&quot;: &quot;xxxx&quot;,</span><br><span class="line">    &quot;password&quot;: xxxx,</span><br><span class="line">  &#125;);</span><br><span class="line">  var dio = new Dio();</span><br><span class="line">  var response = await dio.post(url_post, data: formData);</span><br><span class="line">  _content = response.data.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="十-弹窗Dialog"><a href="#十-弹窗Dialog" class="headerlink" title="十.弹窗Dialog"></a>十.弹窗Dialog</h1><p>Flutter中的操作提示主要有 <code>SnackBar、BottomSheet、Dialog</code><br>Flutter中也提供了很多Dialog 弹窗，如：<code>AboutDialog、AlertDialog、SimpleDialog、CupertinoAlertDialog、CupertinoFullscreenDialogTransition、BottomSheet</code>。<br>对话框本质上是属于一个路由的页面Route，由Navigator进行管理，所以控制对话框的显示和隐藏，也是调用Navigator.of(context)的push和pop方法。<br>在Flutter中，对话框会有两种风格，调用showDialog()方法展示的是material风格的对话框，调用showCupertinoDialog()方法展示的是ios风格的对话框。<br>而这两个方法其实都会去调用showGeneralDialog()方法，可以从源码中看到最后是利用Navigator.of(context, rootNavigator: true).push()一个页面。<br>基本要传的参数:context上下文,builder用于创建显示的widget,barrierDismissible可以控制点击对话框以外的区域是否隐藏对话框。<br>showDialog()方法返回的是一个Future对象,可以通过这个future对象来获取对话框所传递的数据。 比如我们想知道想知道用户是点击了对话框的确认按钮还是取消按钮,那就在退出对话框的时候，<br>利用<code>Navigator.of(context).pop(&quot;一些数据&quot;)</code>;</p>
<p>在 MaterialDesign下，<br>Dialog主要有 3 种：</p>
<ul>
<li>SimpleDialog</li>
<li>AlertDialog</li>
<li>BottomSheet</li>
</ul>
<h3 id="1-SimpleDialog"><a href="#1-SimpleDialog" class="headerlink" title="1. SimpleDialog"></a>1. SimpleDialog</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">void showMySimpleDialog(BuildContext context) &#123;</span><br><span class="line">    showDialog(</span><br><span class="line">        context: context,</span><br><span class="line">        builder: (context) &#123;</span><br><span class="line">          return new SimpleDialog(</span><br><span class="line">            title: new Text(&quot;SimpleDialog&quot;),</span><br><span class="line">            children: &lt;Widget&gt;[</span><br><span class="line">              new SimpleDialogOption(</span><br><span class="line">                child: new Text(&quot;SimpleDialogOption One&quot;),</span><br><span class="line">                onPressed: () &#123;</span><br><span class="line">                  Navigator.of(context).pop(&quot;SimpleDialogOption One&quot;);</span><br><span class="line">                &#125;,</span><br><span class="line">              ),</span><br><span class="line">              new SimpleDialogOption(</span><br><span class="line">                child: new Text(&quot;SimpleDialogOption Two&quot;),</span><br><span class="line">                onPressed: () &#123;</span><br><span class="line">                  Navigator.of(context).pop(&quot;SimpleDialogOption Two&quot;);</span><br><span class="line">                &#125;,</span><br><span class="line">              ),</span><br><span class="line">              new SimpleDialogOption(</span><br><span class="line">                child: new Text(&quot;SimpleDialogOption Three&quot;),</span><br><span class="line">                onPressed: () &#123;</span><br><span class="line">                  Navigator.of(context).pop(&quot;SimpleDialogOption Three&quot;);</span><br><span class="line">                &#125;,</span><br><span class="line">              ),</span><br><span class="line">            ],</span><br><span class="line">          );</span><br><span class="line">        &#125;);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-AlertDialog"><a href="#2-AlertDialog" class="headerlink" title="2. AlertDialog"></a>2. AlertDialog</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">void showMyMaterialDialog(BuildContext context) &#123;</span><br><span class="line">    showDialog(</span><br><span class="line">        context: context,</span><br><span class="line">        builder: (context) &#123;</span><br><span class="line">          return new AlertDialog(</span><br><span class="line">            title: new Text(&quot;title&quot;),</span><br><span class="line">            content: new Text(&quot;内容内容内容内容内容内容内容内容内容内容内容&quot;),</span><br><span class="line">            actions: &lt;Widget&gt;[</span><br><span class="line">              new FlatButton(</span><br><span class="line">                onPressed: () &#123;</span><br><span class="line">                  Navigator.of(context).pop();</span><br><span class="line">                &#125;,</span><br><span class="line">                child: new Text(&quot;确认&quot;),</span><br><span class="line">              ),</span><br><span class="line">              new FlatButton(</span><br><span class="line">                onPressed: () &#123;</span><br><span class="line">                  Navigator.of(context).pop();</span><br><span class="line">                &#125;,</span><br><span class="line">                child: new Text(&quot;取消&quot;),</span><br><span class="line">              ),</span><br><span class="line">            ],</span><br><span class="line">          );</span><br><span class="line">        &#125;);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-BottomSheet"><a href="#3-BottomSheet" class="headerlink" title="3. BottomSheet"></a>3. BottomSheet</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">showModalBottomSheet(</span><br><span class="line">     context: context,</span><br><span class="line">     backgroundColor: Colors.green,</span><br><span class="line">     shape: RoundedRectangleBorder(</span><br><span class="line">         borderRadius: BorderRadius.circular(10)),</span><br><span class="line">     enableDrag: false,</span><br><span class="line">     //设置不能拖拽关闭</span><br><span class="line">     isDismissible: false,</span><br><span class="line">     //设置不能点击消失</span><br><span class="line">     builder: (BuildContext context) &#123;</span><br><span class="line">       return new Container(</span><br><span class="line">           height: 300.0,</span><br><span class="line">           child: Column(</span><br><span class="line">             children: &lt;Widget&gt;[</span><br><span class="line">               RaisedButton(</span><br><span class="line">                 onPressed: () &#123;</span><br><span class="line">                   Navigator.of(context).pop();</span><br><span class="line">                 &#125;,</span><br><span class="line">                 child: Text(&quot;点击关闭&quot;),</span><br><span class="line">               ),</span><br><span class="line">             ],</span><br><span class="line">           ));</span><br><span class="line">     &#125;,</span><br><span class="line">   ).then((val) &#123;</span><br><span class="line">     print(val);</span><br><span class="line">   &#125;);</span><br></pre></td></tr></table></figure>

<h3 id="4-自定义弹窗"><a href="#4-自定义弹窗" class="headerlink" title="4. 自定义弹窗"></a>4. 自定义弹窗</h3><p>定义组件类来继承Dialog,添加build方法，return 自定义内容</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">class MyCustomLoadingDialog extends StatelessWidget &#123;</span><br><span class="line">  @override</span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    Duration insetAnimationDuration = const Duration(milliseconds: 100);</span><br><span class="line">    Curve insetAnimationCurve = Curves.decelerate;</span><br><span class="line"></span><br><span class="line">    RoundedRectangleBorder _defaultDialogShape = RoundedRectangleBorder(</span><br><span class="line">        borderRadius: BorderRadius.all(Radius.circular(2.0)));</span><br><span class="line"></span><br><span class="line">    return AnimatedPadding(</span><br><span class="line">      padding: MediaQuery.of(context).viewInsets +</span><br><span class="line">          const EdgeInsets.symmetric(horizontal: 40.0, vertical: 24.0),</span><br><span class="line">      duration: insetAnimationDuration,</span><br><span class="line">      curve: insetAnimationCurve,</span><br><span class="line">      child: MediaQuery.removeViewInsets(</span><br><span class="line">        removeLeft: true,</span><br><span class="line">        removeTop: true,</span><br><span class="line">        removeRight: true,</span><br><span class="line">        removeBottom: true,</span><br><span class="line">        context: context,</span><br><span class="line">        child: Center(</span><br><span class="line">          child: SizedBox(</span><br><span class="line">            width: 120,</span><br><span class="line">            height: 120,</span><br><span class="line">            child: Material(</span><br><span class="line">              elevation: 24.0,</span><br><span class="line">              color: Theme.of(context).dialogBackgroundColor,</span><br><span class="line">              type: MaterialType.card,</span><br><span class="line">              //在这里修改成我们想要显示的widget就行了，外部的属性跟其他Dialog保持一致</span><br><span class="line">              child: new Column(</span><br><span class="line">                mainAxisSize: MainAxisSize.min,</span><br><span class="line">                crossAxisAlignment: CrossAxisAlignment.center,</span><br><span class="line">                mainAxisAlignment: MainAxisAlignment.center,</span><br><span class="line">                children: &lt;Widget&gt;[</span><br><span class="line">                  new CircularProgressIndicator(),</span><br><span class="line">                  // Padding(</span><br><span class="line">                  //   padding: const EdgeInsets.only(top: 20),</span><br><span class="line">                  //   child: new Text(&quot;加载中&quot;),</span><br><span class="line">                  // ),</span><br><span class="line">                ],</span><br><span class="line">              ),</span><br><span class="line">              shape: _defaultDialogShape,</span><br><span class="line">            ),</span><br><span class="line">          ),</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>Flutter相关教程:<br><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/88c66747eec1">Flutter布局方式总</a><br><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/e889c5d407a9">Flutter 初尝试：入门教程</a><br><a target="_blank" rel="noopener" href="https://guoshuyu.cn/home/wx/">GSY Flutter 系列专栏</a><br><a target="_blank" rel="noopener" href="https://book.flutterchina.club/">flutter中文网</a><br><a target="_blank" rel="noopener" href="https://www.jianshu.com/u/794cff487721">Flutter入门进阶之旅</a><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/qianxiaox/p/14025615.html">Flutter基础–状态管理</a><br><a target="_blank" rel="noopener" href="https://juejin.cn/post/6932033252320346126">带你全面了解 Flutter，它好在哪里？它的坑在哪里？ 应该怎么学？</a><br><a target="_blank" rel="noopener" href="https://segmentfault.com/u/coderwhy">Flutter教程</a><br><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000022748118">Flutter State Management状态管理全面分析</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/sinat_17775997/article/details/106658143">Flutter 状态管理</a><br><a target="_blank" rel="noopener" href="https://juejin.cn/post/6998054516637745183">Flutter如何状态管理</a><br><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/3080e0b81cf4">Flutter 网络请求框架封装</a></p>
<p>Flutter综合教程:<br><a target="_blank" rel="noopener" href="https://guoshuyu.cn/home/wx/Flutter-1.html">Flutter教程</a><br><a target="_blank" rel="noopener" href="https://book.flutterchina.club/">《Flutter实战》电子书</a><br><a target="_blank" rel="noopener" href="https://www.w3cschool.cn/flutter_in_action/flutter_in_action-i7rc3ez6.html">w3c school</a><br><a target="_blank" rel="noopener" href="https://www.kancloud.cn/alex_wsc/flutter_demo/1559549">Flutter核心技术与实战</a><br><a target="_blank" rel="noopener" href="https://flutter.cn/docs/get-started/flutter-for/android-devs">给 Android 开发者的 Flutter 指南</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/yuzhiqiang_1993/article/details/89090742">Flutter页面跳转和传值传参，接收页面返回数据、以及解决返回（pop）页面时黑屏的问题</a></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://lxlfpeng.github.io">peng</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://lxlfpeng.github.io/2020/04/08/Flutter%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/">https://lxlfpeng.github.io/2020/04/08/Flutter%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://lxlfpeng.github.io" target="_blank">鹏哥的Blog</a>！</span></div></div><div class="tag_share"><div class="post-share"><div class="social-share" data-image="/images/about_avatar.webp" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2020/06/01/%E4%BD%BF%E7%94%A8Appuim+Python%E8%84%9A%E6%9C%AC%E5%AE%9E%E7%8E%B0Android%E5%BA%94%E7%94%A8%E8%87%AA%E5%8A%A8%E5%8C%96/" title="使用Appuim+Python脚本实现Android应用自动化"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">使用Appuim+Python脚本实现Android应用自动化</div></div><div class="info-2"><div class="info-item-1">一.引言众所周知在App应用开发时我们会有不同的服务器环境来进行开发调试，例如测试环境，预发布环境，正式服环境.由于环境众多所以在测试工程师反馈问题时总要不断的去登录不同的服务器环境进行验证和调试。流程如下:  打开应用 登录界面输入不同环境的账户密码 登录验证  通过这三部才能进入App中进行调试。这三部的过程的执行重复率非常高，作为程序与我们能不能通过程序简化人工的操作呢?笔者将在本文中通过分析和实践来实现这一功能。 二.Appuim的安装和配置对于Android手机屏幕的自动化控制有很多种方案。本文中将选择appuim来进行实现。 1.安装JDK环境和Android环境安装配置appuim首先需要配置好JDK环境和Android Sdk环境。这两点不必多说，网上面大把的相关教程。 2.安装appium环境下载appium-desktop文件，点击进行安装。 3.配置appium1。 安装好appium，打开程序，需要进行配置，host与port默认即可.2. 配置JDK环境和Android Sdk环境。填写Android_home及Java_home后，Save and...</div></div></div></a><a class="pagination-related" href="/2020/03/22/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B%E5%8F%8A%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/" title="Java多线程模型及线程安全问题总结"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Java多线程模型及线程安全问题总结</div></div><div class="info-2"><div class="info-item-1">一.线程和进程1.什么是进程进程是系统中正在运行的一个程序，程序一旦运行就是进程。进程可以看成程序执行的一个实例。进程是系统资源分配的独立实体，每个进程都拥有独立的地址空间。一个进程无法访问另一个进程的变量和数据结构，如果想让一个进程访问另一个进程的资源，需要使用进程间通信，比如管道，文件，套接字等。 2.什么是线程线程从属于进程，是程序的实际执行者。一个进程至少包含一个主线程，也可以有更多的子线程。 3.进程和线程的区别与联系 线程是进程的一部分，一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程。 资源分配给进程，同一进程的所有线程共享该进程的所有资源。 虚拟机分给线程，即真正在虚拟机上运行的是线程。 线程在执行过程中，需要协作同步。不同进程的线程间要利用消息通信的办法实现同步。  二.Java线程的创建Java中线程的创建常见有如下三种基本形式: 1.继承Thread类，重写该类的run()方法1234567891011121314public class MyThread extends Thread &#123;    @Override   ...</div></div></div></a></nav><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="giscus-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/images/about_avatar.webp" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">peng</div><div class="author-info-description">过往不恋 未来不迎 当下不负</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">127</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">59</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">24</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/lxlfpeng"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/lxlfpeng" target="_blank" title="Github"><i class="fab fa-github" style="color: #4a7dbe;"></i></a><a class="social-icon" href="mailto:565289282@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎来到我的博客!</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80-%E5%91%BD%E4%BB%A4%E5%BC%8FUI%E5%92%8C%E5%A3%B0%E6%98%8E%E5%BC%8FUI"><span class="toc-number">1.</span> <span class="toc-text">一.命令式UI和声明式UI</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%91%BD%E4%BB%A4%E5%BC%8F%E7%BC%96%E7%A8%8B%E5%92%8C%E5%A3%B0%E6%98%8E%E5%BC%8F%E7%BC%96%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.0.1.</span> <span class="toc-text">1. 命令式编程和声明式编程的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Flutter%E4%B8%AD%E5%91%BD%E4%BB%A4%E5%BC%8F%E7%BC%96%E7%A8%8B%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">1.0.2.</span> <span class="toc-text">2. Flutter中命令式编程的应用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C-Flutter%E4%B8%AD%E7%9A%84Widget"><span class="toc-number">2.</span> <span class="toc-text">二.Flutter中的Widget</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%97%A0%E7%8A%B6%E6%80%81StatelessWidget"><span class="toc-number">2.1.</span> <span class="toc-text">1. 无状态StatelessWidget</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%AE%9A%E4%B9%89"><span class="toc-number">2.1.1.</span> <span class="toc-text">(1.)定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%BD%BF%E7%94%A8"><span class="toc-number">2.1.2.</span> <span class="toc-text">(2.)使用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E6%9C%89%E7%8A%B6%E6%80%81StatefulWidget"><span class="toc-number">2.2.</span> <span class="toc-text">2.有状态StatefulWidget</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%AE%9A%E4%B9%89-1"><span class="toc-number">2.2.1.</span> <span class="toc-text">(1.)定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%BD%BF%E7%94%A8-1"><span class="toc-number">2.2.2.</span> <span class="toc-text">(2.)使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-State%E6%A6%82%E5%BF%B5"><span class="toc-number">2.2.3.</span> <span class="toc-text">(3.)State概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-State%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">2.2.4.</span> <span class="toc-text">(3.)State的生命周期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-Flutter%E8%87%AA%E5%AE%9A%E4%B9%89Widget"><span class="toc-number">2.2.5.</span> <span class="toc-text">3.Flutter自定义Widget</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89-StatefulWidget%E7%9A%84%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86"><span class="toc-number">3.</span> <span class="toc-text">三. StatefulWidget的状态管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-widget%E7%9A%84%E7%8A%B6%E6%80%81"><span class="toc-number">3.0.1.</span> <span class="toc-text">1.widget的状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-widget%E7%9A%84%E7%8A%B6%E6%80%81%E6%94%B9%E5%8F%98%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.0.2.</span> <span class="toc-text">2.widget的状态改变的实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-widget%E7%9A%84%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">3.0.3.</span> <span class="toc-text">3.widget的状态管理的方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E8%B7%A8widget%E8%B7%A8%E9%A1%B5%E9%9D%A2%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86"><span class="toc-number">3.0.4.</span> <span class="toc-text">4. 跨widget跨页面状态管理</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89-%E5%B8%B8%E8%A7%81%E7%9A%84Widget"><span class="toc-number">4.</span> <span class="toc-text">三.常见的Widget</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%AE%B9%E5%99%A8"><span class="toc-number">4.0.1.</span> <span class="toc-text">1.容器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E9%A1%B5%E9%9D%A2"><span class="toc-number">4.0.2.</span> <span class="toc-text">2.页面</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9B-widget%E4%BA%8B%E4%BB%B6"><span class="toc-number">5.</span> <span class="toc-text">四. widget事件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-widget-%E6%9C%AC%E8%BA%AB%E6%94%AF%E6%8C%81%E4%BA%8B%E4%BB%B6"><span class="toc-number">5.0.1.</span> <span class="toc-text">1.widget 本身支持事件,</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-widget-%E6%9C%AC%E8%BA%AB%E4%B8%8D%E6%94%AF%E6%8C%81%E4%BA%8B%E4%BB%B6"><span class="toc-number">5.0.2.</span> <span class="toc-text">2. widget 本身不支持事件,</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-widget-%E6%89%8B%E5%8A%BF%E4%BA%8B%E4%BB%B6"><span class="toc-number">5.0.3.</span> <span class="toc-text">3. widget 手势事件</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%94-%E8%B7%AF%E7%94%B1%E5%92%8C%E5%AF%BC%E8%88%AA"><span class="toc-number">6.</span> <span class="toc-text">五.路由和导航</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%97%A0%E5%90%8D%E8%B7%AF%E7%94%B1%E8%B7%B3%E8%BD%AC"><span class="toc-number">6.0.1.</span> <span class="toc-text">1.无名路由跳转</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%91%BD%E5%90%8D%E8%B7%AF%E7%94%B1%E8%B7%B3%E8%BD%AC"><span class="toc-number">6.0.2.</span> <span class="toc-text">2.命名路由跳转</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E7%95%8C%E9%9D%A2%E4%B9%8B%E9%97%B4%E4%BC%A0%E9%80%92%E5%8F%82%E6%95%B0"><span class="toc-number">6.0.3.</span> <span class="toc-text">3.界面之间传递参数</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E9%80%9A%E8%BF%87%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E4%B8%AD%E4%BC%A0%E9%80%92%E6%95%B0%E6%8D%AE"><span class="toc-number">6.0.3.0.1.</span> <span class="toc-text">(1. )通过构造方法中传递数据</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%B0%86%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E7%BB%99%E6%8C%87%E5%AE%9A%E8%B7%AF%E7%94%B1"><span class="toc-number">6.0.3.0.2.</span> <span class="toc-text">(2.)将参数传递给指定路由</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E8%BF%94%E5%9B%9E%E5%8F%82%E6%95%B0"><span class="toc-number">6.0.4.</span> <span class="toc-text">4.返回参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E8%B7%AF%E7%94%B1%E6%8B%A6%E6%88%AA"><span class="toc-number">6.0.5.</span> <span class="toc-text">5. 路由拦截</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E8%B7%AF%E7%94%B1%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93"><span class="toc-number">6.0.6.</span> <span class="toc-text">5.路由使用总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AD-%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86"><span class="toc-number">7.</span> <span class="toc-text">六. 资源管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%8A%A0%E8%BD%BD%E5%9B%BE%E7%89%87"><span class="toc-number">7.0.1.</span> <span class="toc-text">1.加载图片</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%A3%B0%E6%98%8E%E5%88%86%E8%BE%A8%E7%8E%87%E7%9B%B8%E5%85%B3%E7%9A%84%E5%9B%BE%E7%89%87-assets"><span class="toc-number">7.0.1.0.1.</span> <span class="toc-text">(1.)声明分辨率相关的图片 assets</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E7%89%B9%E5%AE%9A%E5%B9%B3%E5%8F%B0-assets"><span class="toc-number">7.0.2.</span> <span class="toc-text">2. 特定平台 assets</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E8%AE%BE%E7%BD%AEAPP%E5%90%AF%E5%8A%A8%E5%9B%BE%E6%A0%87"><span class="toc-number">7.0.2.0.1.</span> <span class="toc-text">(1.)设置APP启动图标</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%90%AF%E5%8A%A8%E9%A1%B5"><span class="toc-number">7.0.2.0.2.</span> <span class="toc-text">(2.)启动页</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%83-%E5%8C%85%E7%AE%A1%E7%90%86%E4%B8%8E%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93%E5%BC%95%E5%85%A5"><span class="toc-number">8.</span> <span class="toc-text">七.包管理与第三方库引入</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-YAML%E5%8C%85%E7%AE%A1%E7%90%86"><span class="toc-number">8.0.1.</span> <span class="toc-text">1. YAML包管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%BE%9D%E8%B5%96%E6%96%B9%E5%BC%8F"><span class="toc-number">8.0.2.</span> <span class="toc-text">2.依赖方式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E4%BE%9D%E8%B5%96Pub%E4%BB%93%E5%BA%93"><span class="toc-number">8.0.2.0.1.</span> <span class="toc-text">1. 依赖Pub仓库</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E4%BE%9D%E8%B5%96%E6%9C%AC%E5%9C%B0%E5%8C%85"><span class="toc-number">8.0.2.0.2.</span> <span class="toc-text">3. 依赖本地包</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%E4%BE%9D%E8%B5%96git%E4%BB%93%E5%BA%93"><span class="toc-number">8.0.2.0.3.</span> <span class="toc-text">3依赖git仓库</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AB-Json%E8%A7%A3%E6%9E%90"><span class="toc-number">9.</span> <span class="toc-text">八.Json解析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%89%8B%E5%8A%A8%E5%BA%8F%E5%88%97%E5%8C%96JSON"><span class="toc-number">9.0.1.</span> <span class="toc-text">1. 手动序列化JSON</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E9%80%9A%E8%BF%87%E4%BD%BF%E7%94%A8-json-serializable%E7%94%9F%E6%88%90JsonModel"><span class="toc-number">9.0.2.</span> <span class="toc-text">2.通过使用 json_serializable生成JsonModel</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%BC%95%E5%85%A5%E4%BE%9D%E8%B5%96"><span class="toc-number">9.0.2.0.1.</span> <span class="toc-text">(1.)引入依赖</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E7%94%9F%E6%88%90%E6%A8%A1%E5%9E%8B%E7%B1%BB"><span class="toc-number">9.0.2.0.2.</span> <span class="toc-text">(2.)生成模型类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E6%89%A7%E8%A1%8C%E5%91%BD%E4%BB%A4%E6%A0%B9%E6%8D%AE%E6%A8%A1%E5%9E%8B%E7%B1%BB-%E7%94%9F%E6%88%90%E6%A8%A1%E5%9E%8B%E7%B1%BB%E4%BB%A3%E7%A0%81"><span class="toc-number">9.0.2.0.3.</span> <span class="toc-text">(3.)执行命令根据模型类,生成模型类代码.</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E4%BD%BF%E7%94%A8"><span class="toc-number">9.0.2.0.4.</span> <span class="toc-text">(4.)使用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E9%80%9A%E8%BF%87%E5%9C%A8%E7%BA%BF%E6%88%96%E8%80%85%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7json-to-dart%E6%8F%92%E4%BB%B6%E7%94%9F%E6%88%90"><span class="toc-number">9.0.3.</span> <span class="toc-text">2.通过在线或者开发工具json-to-dart插件生成</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B9%9D-%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82"><span class="toc-number">10.</span> <span class="toc-text">九.网络请求</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%8E%9F%E7%94%9F%E6%96%B9%E5%BC%8F-%E4%B8%8D%E5%BB%BA%E8%AE%AE%E4%BD%BF%E7%94%A8"><span class="toc-number">10.0.1.</span> <span class="toc-text">1. 原生方式(不建议使用)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%BA%93http-%E4%B8%8D%E5%BB%BA%E8%AE%AE%E4%BD%BF%E7%94%A8"><span class="toc-number">10.0.2.</span> <span class="toc-text">2.库http(不建议使用)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-get-%E8%AF%B7%E6%B1%82"><span class="toc-number">10.0.2.0.1.</span> <span class="toc-text">(1.)get 请求</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-post-%E8%AF%B7%E6%B1%82"><span class="toc-number">10.0.2.0.2.</span> <span class="toc-text">(2.)post 请求</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%BA%93-dio-%E6%8E%A8%E8%8D%90%E4%BD%BF%E7%94%A8"><span class="toc-number">10.0.3.</span> <span class="toc-text">3. 库 dio(推荐使用)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-get-%E8%AF%B7%E6%B1%82-1"><span class="toc-number">10.0.3.0.1.</span> <span class="toc-text">(1.)get 请求</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-post-%E8%AF%B7%E6%B1%82-1"><span class="toc-number">10.0.3.0.2.</span> <span class="toc-text">(2.)post 请求</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81-%E5%BC%B9%E7%AA%97Dialog"><span class="toc-number">11.</span> <span class="toc-text">十.弹窗Dialog</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-SimpleDialog"><span class="toc-number">11.0.1.</span> <span class="toc-text">1. SimpleDialog</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-AlertDialog"><span class="toc-number">11.0.2.</span> <span class="toc-text">2. AlertDialog</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-BottomSheet"><span class="toc-number">11.0.3.</span> <span class="toc-text">3. BottomSheet</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%B9%E7%AA%97"><span class="toc-number">11.0.4.</span> <span class="toc-text">4. 自定义弹窗</span></a></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer" style="background: linear-gradient(20deg, #0062be, #925696, #cc426e, #fb0347);"><div id="footer-wrap"><div class="copyright">&copy;2015 - 2025 By peng</div><div class="footer_custom_text"> <a target="_blank" rel="nofollow noopener"><span>千里之行</span></a> <i class="iconfont icon-love"></i> <a target="_blank" rel="nofollow noopener"><span>始于足下</span></a> </div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.isShuoshuo
  const option = null

  const getGiscusTheme = theme => theme === 'dark' ? 'dark' : 'light'

  const createScriptElement = config => {
    const ele = document.createElement('script')
    Object.entries(config).forEach(([key, value]) => {
      ele.setAttribute(key, value)
    })
    return ele
  }

  const loadGiscus = (el = document, key) => {
    const mappingConfig = isShuoshuo
      ? { 'data-mapping': 'specific', 'data-term': key }
      : { 'data-mapping': (option && option['data-mapping']) || 'pathname' }

    const giscusConfig = {
      src: 'https://giscus.app/client.js',
      'data-repo': 'lxlfpeng/blog_comments',
      'data-repo-id': 'R_kgDONYoexA',
      'data-category-id': 'DIC_kwDONYoexM4Ck4JQ',
      'data-theme': getGiscusTheme(document.documentElement.getAttribute('data-theme')),
      'data-reactions-enabled': '1',
      crossorigin: 'anonymous',
      async: true,
      ...option,
      ...mappingConfig
    }

    const scriptElement = createScriptElement(giscusConfig)

    el.querySelector('#giscus-wrap').appendChild(scriptElement)

    if (isShuoshuo) {
      window.shuoshuoComment.destroyGiscus = () => {
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }
  }

  const changeGiscusTheme = theme => {
    const iframe = document.querySelector('#giscus-wrap iframe')
    if (iframe) {
      const message = {
        giscus: {
          setConfig: {
            theme: getGiscusTheme(theme)
          }
        }
      }
      iframe.contentWindow.postMessage(message, 'https://giscus.app')
    }
  }

  btf.addGlobalFn('themeChange', changeGiscusTheme, 'giscus')

  if (isShuoshuo) {
    'Giscus' === 'Giscus'
      ? window.shuoshuoComment = { loadComment: loadGiscus }
      : window.loadOtherComment = loadGiscus
    return
  }

  if ('Giscus' === 'Giscus' || !false) {
    if (false) btf.loadComment(document.getElementById('giscus-wrap'), loadGiscus)
    else loadGiscus()
  } else {
    window.loadOtherComment = loadGiscus
  }
})()</script></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="false"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>